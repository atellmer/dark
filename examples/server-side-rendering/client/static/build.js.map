{"version":3,"file":"build.js","mappings":"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","sources":["webpack:///webpack/runtime/load script","webpack:///../../../packages/core/src/component/component.ts","webpack:///../../../packages/core/src/constants.ts","webpack:///../../../packages/core/src/context/context.ts","webpack:///../../../packages/core/src/element/element.ts","webpack:///../../../packages/core/src/fiber/fiber.ts","webpack:///../../../packages/core/src/fiber/types.ts","webpack:///../../../packages/core/src/fragment/fragment.ts","webpack:///../../../packages/core/src/helpers/index.ts","webpack:///../../../packages/core/src/memo/memo.ts","webpack:///../../../packages/core/src/platform/platform.ts","webpack:///../../../packages/core/src/scope/scope.ts","webpack:///../../../packages/core/src/unmount/unmount.ts","webpack:///../../../packages/core/src/use-callback/use-callback.ts","webpack:///../../../packages/core/src/use-effect/use-effect.ts","webpack:///../../../packages/core/src/use-insertion-effect/use-insertion-effect.ts","webpack:///../../../packages/core/src/use-layout-effect/use-layout-effect.ts","webpack:///../../../packages/core/src/use-memo/use-memo.ts","webpack:///../../../packages/core/src/use-state/use-state.ts","webpack:///../../../packages/core/src/use-update/use-update.ts","webpack:///../../../packages/core/src/batch/batch.ts","webpack:///../../../packages/core/src/view/types.ts","webpack:///../../../packages/core/src/view/view.ts","webpack:///../../../packages/core/src/walk/walk.ts","webpack:///../../../packages/web-router/src/constants.ts","webpack:///../../../packages/web-router/src/context/context.tsx","webpack:///../../../packages/web-router/src/create-routes/create-routes.ts","webpack:///../../../packages/web-router/src/router-link/router-link.tsx","webpack:///../../../packages/core/src/use-event/use-event.ts","webpack:///../../../packages/web-router/src/use-history/use-history.ts","webpack:///../../../packages/web-router/src/use-location/use-location.ts","webpack:///../../../packages/web-router/src/utils/utils.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/ensure chunk","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/jsonp chunk loading","webpack:///../../../packages/core/src/ref/ref.ts","webpack:///../../../packages/core/src/suspense/suspense.ts","webpack:///../../../packages/core/src/lazy/lazy.ts","webpack:///../../../packages/platform-browser/src/portal/portal.tsx","webpack:///../../../packages/platform-browser/src/events/events.ts","webpack:///../../../packages/platform-browser/src/dom/dom.ts","webpack:///../../../packages/platform-browser/src/constants.ts","webpack:///../../../packages/platform-browser/src/scheduler/scheduler.ts","webpack:///../../../packages/platform-browser/src/render/render.ts","webpack:///../../../packages/platform-browser/src/create-root/create-root.tsx","webpack:///../../../packages/platform-browser/src/hydrate-root/hydrate-root.tsx","webpack:///../../../packages/web-router/src/history/history.ts","webpack:///../../../packages/web-router/src/location/location.ts","webpack:///../../../packages/web-router/src/router/router.tsx","webpack:///../../../packages/core/src/use-imperative-handle/use-imperative-handle.ts","webpack:///./components/spinner.tsx","webpack:///./components/app.tsx","webpack:///./bootstrap/app.client.tsx","webpack:///./index.tsx"],"sourcesContent":["var inProgress = {};\n// data-webpack is not used as build has no uniqueName\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","import { ATTR_KEY, ATTR_FLAG, Flag } from '../constants';\r\nimport type { DarkElementKey, DarkElementInstance } from '../shared';\r\nimport { error, detectIsEmpty } from '../helpers';\r\nimport type { Ref } from '../ref';\r\nimport type { CreateElement, ComponentOptions, ShouldUpdate, StandardComponentProps } from './types';\r\n\r\nconst $$component = Symbol('component');\r\nconst defaultOptions: ComponentOptions<any> = {\r\n  displayName: '',\r\n  defaultProps: {},\r\n  token: $$component,\r\n};\r\nclass ComponentFactory<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public token: Symbol;\r\n  public props: P;\r\n  public ref: Ref<R>;\r\n  public displayName: string;\r\n  public children: Array<DarkElementInstance> = [];\r\n  public shouldUpdate?: ShouldUpdate<P>;\r\n\r\n  constructor(\r\n    type: CreateElement<P>,\r\n    token: Symbol,\r\n    props: P,\r\n    ref: Ref<R>,\r\n    shouldUpdate: ShouldUpdate<P>,\r\n    displayName: string,\r\n  ) {\r\n    this.type = type || null;\r\n    this.token = token || null;\r\n    this.props = props || null;\r\n    this.ref = ref || null;\r\n    this.shouldUpdate = shouldUpdate || null;\r\n    this.displayName = displayName || '';\r\n  }\r\n}\r\n\r\nfunction createComponent<P, R = unknown>(type: CreateElement<P, R>, options: ComponentOptions<P> = {}) {\r\n  const computedOptions = { ...defaultOptions, ...options } as ComponentOptions<P>;\r\n  const { token, defaultProps, displayName, shouldUpdate } = computedOptions;\r\n  const component = (\r\n    props = {} as P & StandardComponentProps,\r\n    ref?: Ref<R>,\r\n  ): ComponentFactory<P & StandardComponentProps> => {\r\n    const mprops = { ...defaultProps, ...props };\r\n\r\n    if (mprops.ref) {\r\n      delete mprops.ref;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        error(`[Dark]: To use ref you need to wrap the createComponent with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return new ComponentFactory(type, token, mprops, ref, shouldUpdate, displayName);\r\n  };\r\n\r\n  return component;\r\n}\r\n\r\nconst detectIsComponentFactory = (factory: unknown): factory is ComponentFactory => factory instanceof ComponentFactory;\r\n\r\nconst getComponentFactoryKey = (factory: ComponentFactory): DarkElementKey =>\r\n  !detectIsEmpty(factory.props[ATTR_KEY]) ? factory.props[ATTR_KEY] : null;\r\n\r\nconst getComponentFactoryFlag = (factory: ComponentFactory): Record<Flag, boolean> | null =>\r\n  factory.props[ATTR_FLAG] || null;\r\n\r\nexport { ComponentFactory, createComponent, detectIsComponentFactory, getComponentFactoryKey, getComponentFactoryFlag };\r\n","export const ROOT = 'root';\r\nexport const REPLACER = 'dark:matter';\r\nexport const INDEX_KEY = 'dark:idx';\r\nexport const TYPE = 'type';\r\nexport const ATTR_KEY = 'key';\r\nexport const ATTR_REF = 'ref';\r\nexport const ATTR_FLAG = 'flag';\r\n\r\nexport enum TaskPriority {\r\n  ANIMATION = 3,\r\n  HIGH = 2,\r\n  NORMAL = 1,\r\n  LOW = 0,\r\n}\r\n\r\nexport enum Flag {\r\n  HAS_NO_MOVES = 'HAS_NO_MOVES',\r\n}\r\n","import type { DarkElement } from '../shared';\r\nimport type { Fiber } from '../fiber';\r\nimport { detectIsFunction } from '../helpers';\r\nimport { currentFiberStore } from '../scope';\r\nimport { createComponent } from '../component';\r\nimport { useEffect } from '../use-effect';\r\nimport { useMemo } from '../use-memo';\r\nimport { useUpdate } from '../use-update';\r\nimport type { Context, ContexProviderProps, ContextProviderValue } from './types';\r\n\r\ntype CreateContextOptions = {\r\n  displayName?: string;\r\n};\r\n\r\nfunction createContext<T>(defaultValue: T, options?: CreateContextOptions): Context<T> {\r\n  const { displayName = 'Context' } = options || {};\r\n  const context: Context<T> = {\r\n    displayName,\r\n    defaultValue,\r\n    Provider: null,\r\n    Consumer: null,\r\n  };\r\n\r\n  context.Provider = createProvider(context, defaultValue, displayName);\r\n  context.Consumer = createConsumer(context, displayName);\r\n\r\n  return context;\r\n}\r\n\r\nfunction createProvider<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  return createComponent<ContexProviderProps<T>>(\r\n    ({ value = defaultValue, slot }) => {\r\n      const fiber = currentFiberStore.get();\r\n\r\n      if (!fiber.provider) {\r\n        const providerValue: ContextProviderValue<T> = {\r\n          value,\r\n          subscribers: new Set(),\r\n          subscribe: (subscriber: (value: T) => void) => {\r\n            providerValue.subscribers.add(subscriber);\r\n\r\n            return () => providerValue.subscribers.delete(subscriber);\r\n          },\r\n        };\r\n\r\n        fiber.provider = new Map();\r\n        fiber.provider.set(context, providerValue);\r\n      }\r\n\r\n      const provider = fiber.provider.get(context);\r\n\r\n      useEffect(() => {\r\n        provider.subscribers.forEach(fn => fn(value));\r\n      }, [value]);\r\n\r\n      provider.value = value;\r\n\r\n      return slot;\r\n    },\r\n    { displayName: `${displayName}.Provider` },\r\n  );\r\n}\r\n\r\ntype ConsumerProps<T> = {\r\n  slot: (value: T) => DarkElement;\r\n};\r\n\r\nfunction createConsumer<T>(context: Context<T>, displayName: string) {\r\n  return createComponent<ConsumerProps<T>>(\r\n    ({ slot }) => {\r\n      const value = useContext(context);\r\n\r\n      return detectIsFunction(slot) ? slot(value) : null;\r\n    },\r\n    { displayName: `${displayName}.Consumer` },\r\n  );\r\n}\r\n\r\nfunction useContext<T>(context: Context<T>): T {\r\n  const { defaultValue } = context;\r\n  const fiber = currentFiberStore.get();\r\n  const provider = useMemo(() => getProvider<T>(context, fiber), []);\r\n  const value = provider ? provider.value : defaultValue;\r\n  const update = useUpdate();\r\n  const scope = useMemo(() => ({ value }), []);\r\n  const hasProvider = Boolean(provider);\r\n\r\n  useEffect(() => {\r\n    if (!hasProvider) return;\r\n    const unsubscribe = provider.subscribe((value: T) => {\r\n      if (!Object.is(scope.value, value)) {\r\n        update();\r\n      }\r\n    });\r\n\r\n    return () => unsubscribe();\r\n  }, [hasProvider]);\r\n\r\n  scope.value = value;\r\n\r\n  return value;\r\n}\r\n\r\nfunction getProvider<T>(context: Context<T>, fiber: Fiber): ContextProviderValue<T> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.provider && nextFiber.provider.get(context)) {\r\n      return nextFiber.provider.get(context) as ContextProviderValue<T>;\r\n    }\r\n\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createContext, useContext };\r\n","import { detectIsNumber, detectIsString, detectIsFunction } from '../helpers';\r\nimport { View, Text, type TagVirtualNodeFactory } from '../view';\r\nimport { type ComponentFactory } from '../component';\r\n\r\nfunction getChildren(children: Array<any>) {\r\n  children = children.map(x => (detectIsString(x) || detectIsNumber(x) ? Text(x.toString()) : x));\r\n\r\n  return children ? (Array.isArray(children) ? [...children] : [children]) : [];\r\n}\r\n\r\nfunction createElement(\r\n  tag: string | Function,\r\n  props: any,\r\n  ...children: Array<any>\r\n): ComponentFactory | TagVirtualNodeFactory | null {\r\n  if (detectIsString(tag)) {\r\n    return View({\r\n      ...props,\r\n      as: tag,\r\n      slot: getChildren(children),\r\n    });\r\n  }\r\n\r\n  if (detectIsFunction(tag)) {\r\n    let slot = getChildren(children);\r\n\r\n    slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return tag({ ...props, slot });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement, createElement as h };\r\n","import {\r\n  flatten,\r\n  error,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  detectIsArray,\r\n  detectIsString,\r\n  detectIsNumber,\r\n  detectIsFunction,\r\n} from '../helpers';\r\nimport { platform } from '../platform';\r\nimport {\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  deletionsStore,\r\n  fiberMountStore,\r\n  currentFiberStore,\r\n  isUpdateHookZone,\r\n  rootStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  insertionEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isInsertionEffectsZone,\r\n  detectHasRegisteredLazy,\r\n  isHydrateZone,\r\n} from '../scope';\r\nimport {\r\n  type ComponentFactory,\r\n  detectIsComponentFactory,\r\n  getComponentFactoryKey,\r\n  getComponentFactoryFlag,\r\n} from '../component';\r\nimport {\r\n  type TagVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  getTagVirtualNodeKey,\r\n  getVirtualNodeFactoryKey,\r\n  getTagVirtualNodeFlag,\r\n  getVirtualNodeFactoryFlag,\r\n  detectIsTextVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsPlainVirtualNode,\r\n  createReplacer,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo';\r\nimport type { Context, ContextProviderValue } from '../context';\r\nimport type { DarkElementKey, DarkElement, DarkElementInstance } from '../shared';\r\nimport { INDEX_KEY, TYPE, Flag } from '../constants';\r\nimport { type NativeElement, type Hook, EffectTag } from './types';\r\nimport { hasEffects } from '../use-effect';\r\nimport { hasLayoutEffects } from '../use-layout-effect';\r\nimport { hasInsertionEffects } from '../use-insertion-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { unmountFiber } from '../unmount';\r\nimport { Text } from '../view';\r\nimport { Fragment, detectIsFragment } from '../fragment';\r\n\r\nconst cloneTagMap = {\r\n  [EffectTag.CREATE]: true,\r\n};\r\n\r\nclass Fiber<N = NativeElement> {\r\n  public id = 0;\r\n  public nativeElement: N = null;\r\n  public parent: Fiber<N> = null;\r\n  public child: Fiber<N> = null;\r\n  public nextSibling: Fiber<N> = null;\r\n  public alternate: Fiber<N> = null;\r\n  public move = false;\r\n  public effectTag: EffectTag = null;\r\n  public instance: DarkElementInstance = null;\r\n  public hook: Hook | null = null;\r\n  public provider: Map<Context, ContextProviderValue> = null;\r\n  public effectHost = false;\r\n  public layoutEffectHost = false;\r\n  public insertionEffectHost = false;\r\n  public portalHost = false;\r\n  public childrenCount = 0;\r\n  public childrenElementsCount = 0;\r\n  public marker = '';\r\n  public isUsed = false;\r\n  public idx = 0;\r\n  public elementIdx = 0;\r\n  public batched: number | null = null;\r\n  public catchException: (error: Error) => void;\r\n  private static nextId = 0;\r\n\r\n  constructor(hook: Hook = null, provider: Fiber['provider'] = null, idx = 0) {\r\n    this.id = ++Fiber.nextId;\r\n    this.hook = hook;\r\n    this.provider = provider;\r\n    this.idx = idx;\r\n  }\r\n\r\n  public mutate(options: Partial<Fiber<N>>) {\r\n    const keys = Object.keys(options);\r\n\r\n    for (const key of keys) {\r\n      this[key] = options[key];\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  public markEffectHost() {\r\n    this.effectHost = true;\r\n    this.parent && !this.parent.effectHost && this.parent.markEffectHost();\r\n  }\r\n\r\n  public markLayoutEffectHost() {\r\n    this.layoutEffectHost = true;\r\n    this.parent && !this.parent.layoutEffectHost && this.parent.markLayoutEffectHost();\r\n  }\r\n\r\n  public markInsertionEffectHost() {\r\n    this.insertionEffectHost = true;\r\n    this.parent && !this.parent.insertionEffectHost && this.parent.markInsertionEffectHost();\r\n  }\r\n\r\n  public markPortalHost() {\r\n    this.portalHost = true;\r\n    this.parent && !this.parent.portalHost && this.parent.markPortalHost();\r\n  }\r\n\r\n  public incrementChildrenElementsCount(count = 1, force = false) {\r\n    incrementChildrenElementsCount(this, count, force);\r\n  }\r\n\r\n  public setError(error: Error) {\r\n    if (detectIsFunction(this.catchException)) {\r\n      this.catchException(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop() {\r\n  const wipFiber = wipRootStore.get();\r\n  let nextUnitOfWork = nextUnitOfWorkStore.get();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(nextUnitOfWork);\r\n\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    nextUnitOfWorkStore.set(nextUnitOfWork);\r\n    hasMoreWork = Boolean(nextUnitOfWork);\r\n    shouldYield = platform.shouldYeildToHost();\r\n  }\r\n\r\n  if (!nextUnitOfWork && wipFiber) {\r\n    commitChanges();\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber) {\r\n  let isDeepWalking = true;\r\n  let nextFiber = fiber;\r\n  let instance = fiber.instance;\r\n\r\n  while (true) {\r\n    isDeepWalking = fiberMountStore.deepWalking.get();\r\n    nextFiber.hook && (nextFiber.hook.idx = 0);\r\n\r\n    if (isDeepWalking) {\r\n      const hasChildren = hasChildrenProp(instance) && instance.children.length > 0;\r\n\r\n      if (hasChildren) {\r\n        const { fiber$, instance$ } = performChild(nextFiber, instance);\r\n\r\n        nextFiber = fiber$;\r\n        instance = instance$;\r\n\r\n        if (fiber$) return fiber$;\r\n      } else {\r\n        const { fiber$$, fiber$, instance$ } = performSibling(nextFiber, instance);\r\n\r\n        nextFiber = fiber$;\r\n        instance = instance$;\r\n\r\n        if (fiber$$) return fiber$$;\r\n      }\r\n    } else {\r\n      const { fiber$$, fiber$, instance$ } = performSibling(nextFiber, instance);\r\n\r\n      nextFiber = fiber$;\r\n      instance = instance$;\r\n\r\n      if (fiber$$) return fiber$$;\r\n    }\r\n\r\n    if (nextFiber.parent === null) return null;\r\n  }\r\n}\r\n\r\nfunction performChild(nextFiber: Fiber, instance: DarkElementInstance) {\r\n  fiberMountStore.jumpToChild();\r\n  const childrenIdx = 0;\r\n  const alternate = nextFiber.alternate ? nextFiber.alternate.child : null;\r\n  const prevInstance: DarkElementInstance = alternate ? alternate.instance : null;\r\n  const nextInstance: DarkElementInstance = hasChildrenProp(instance) ? instance.children[childrenIdx] || null : null;\r\n  const hook = getHook(alternate, prevInstance, nextInstance);\r\n  const provider = alternate ? alternate.provider : null;\r\n  const fiber = new Fiber(hook, provider, childrenIdx);\r\n\r\n  currentFiberStore.set(fiber);\r\n  fiber.parent = nextFiber;\r\n  nextFiber.child = fiber;\r\n  fiber.elementIdx = nextFiber.nativeElement ? 0 : nextFiber.elementIdx;\r\n  instance = pertformInstance(instance, childrenIdx, fiber) || instance;\r\n  alternate && performAlternate(alternate, instance);\r\n  performFiber(fiber, alternate, instance);\r\n  alternate && detectIsMemo(fiber.instance) && performMemo(fiber, alternate, instance);\r\n\r\n  return {\r\n    fiber$: fiber,\r\n    instance$: instance,\r\n  };\r\n}\r\n\r\nfunction performSibling(nextFiber: Fiber, instance: DarkElementInstance) {\r\n  fiberMountStore.jumpToSibling();\r\n  const parentInstance = nextFiber.parent.instance;\r\n  const childrenIdx = fiberMountStore.getIndex();\r\n  const hasSibling = hasChildrenProp(parentInstance) && parentInstance.children[childrenIdx];\r\n\r\n  if (hasSibling) {\r\n    fiberMountStore.deepWalking.set(true);\r\n    const alternate = nextFiber.alternate ? nextFiber.alternate.nextSibling : null;\r\n    const prevInstance: DarkElementInstance = alternate ? alternate.instance : null;\r\n    const nextInstance: DarkElementInstance = hasChildrenProp(parentInstance)\r\n      ? parentInstance.children[childrenIdx] || null\r\n      : null;\r\n    const hook = getHook(alternate, prevInstance, nextInstance);\r\n    const provider = alternate ? alternate.provider : null;\r\n    const fiber = new Fiber(hook, provider, childrenIdx);\r\n\r\n    currentFiberStore.set(fiber);\r\n    fiber.parent = nextFiber.parent;\r\n    nextFiber.nextSibling = fiber;\r\n    fiber.elementIdx = nextFiber.elementIdx + (nextFiber.nativeElement ? 1 : nextFiber.childrenElementsCount);\r\n    instance = pertformInstance(parentInstance, childrenIdx, fiber) || instance;\r\n    alternate && performAlternate(alternate, instance);\r\n    performFiber(fiber, alternate, instance);\r\n    alternate && detectIsMemo(fiber.instance) && performMemo(fiber, alternate, instance);\r\n\r\n    return {\r\n      fiber$$: fiber,\r\n      fiber$: fiber,\r\n      instance$: instance,\r\n    };\r\n  } else {\r\n    fiberMountStore.jumpToParent();\r\n    fiberMountStore.deepWalking.set(false);\r\n    nextFiber = nextFiber.parent;\r\n    instance = nextFiber.instance;\r\n\r\n    if (hasChildrenProp(nextFiber.instance)) {\r\n      nextFiber.instance.children = [];\r\n    }\r\n  }\r\n\r\n  return {\r\n    fiber$$: null,\r\n    fiber$: nextFiber,\r\n    instance$: instance,\r\n  };\r\n}\r\n\r\nfunction incrementChildrenElementsCount(fiber: Fiber, count = 1, force = false) {\r\n  if (!fiber.parent) return;\r\n  const fromUpdate = isUpdateHookZone.get();\r\n  const wipFiber = wipRootStore.get();\r\n  const stop = fromUpdate && wipFiber.parent === fiber.parent;\r\n\r\n  if (\r\n    detectIsTextVirtualNode(fiber.instance) ||\r\n    detectIsCommentVirtualNode(fiber.instance) ||\r\n    (detectIsTagVirtualNode(fiber.instance) && fiber.instance.children.length === 0)\r\n  ) {\r\n    fiber.childrenElementsCount = 1;\r\n  }\r\n\r\n  if (fromUpdate && stop && !force) return;\r\n\r\n  fiber.parent.childrenElementsCount += count;\r\n\r\n  if (!fiber.parent.nativeElement) {\r\n    fiber.parent.incrementChildrenElementsCount(count);\r\n  }\r\n}\r\n\r\nfunction performFiber(fiber: Fiber, alternate: Fiber, instance: DarkElementInstance) {\r\n  let isUpdate = false;\r\n\r\n  cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n  if (fiber.effectTag !== EffectTag.CREATE) {\r\n    const hasAlternate = Boolean(alternate);\r\n    const prevKey = hasAlternate ? getElementKey(alternate.instance) : null;\r\n    const nextKey = hasAlternate ? getElementKey(instance) : null;\r\n    const isSameKeys = prevKey === nextKey;\r\n    const isSameTypes = hasAlternate && getInstanceType(alternate.instance) === getInstanceType(instance);\r\n\r\n    isUpdate = isSameTypes && isSameKeys;\r\n  }\r\n\r\n  fiber.instance = instance;\r\n  fiber.alternate = alternate || null;\r\n  fiber.nativeElement = isUpdate ? alternate.nativeElement : null;\r\n  fiber.effectTag = isUpdate ? EffectTag.UPDATE : EffectTag.CREATE;\r\n\r\n  if (alternate && alternate.move) {\r\n    fiber.move = alternate.move;\r\n    alternate.move = false;\r\n  }\r\n\r\n  if (hasChildrenProp(fiber.instance)) {\r\n    fiber.childrenCount = fiber.instance.children.length;\r\n  }\r\n\r\n  if (!fiber.nativeElement && detectIsVirtualNode(fiber.instance)) {\r\n    fiber.nativeElement = platform.createNativeElement(fiber.instance);\r\n    fiber.effectTag = EffectTag.CREATE;\r\n  }\r\n\r\n  if (fiber.nativeElement) {\r\n    fiber.incrementChildrenElementsCount();\r\n  }\r\n}\r\n\r\nfunction insertToFiber(idx: number, fiber: Fiber, child: Fiber) {\r\n  if (idx === 0 || (fiber.child && fiber.child.effectTag === EffectTag.DELETE)) {\r\n    fiber.child = child;\r\n    child.parent = fiber;\r\n  } else {\r\n    fiber.nextSibling = child;\r\n    child.parent = fiber.parent;\r\n  }\r\n\r\n  return child;\r\n}\r\n\r\nfunction createConditionalFiber(alternate: Fiber, marker?: DarkElementKey) {\r\n  const vNode = createReplacer();\r\n\r\n  return new Fiber().mutate({\r\n    instance: vNode,\r\n    parent: alternate,\r\n    marker: marker + '',\r\n    effectTag: EffectTag.CREATE,\r\n  });\r\n}\r\n\r\nfunction canAddToDeletions(fiber: Fiber) {\r\n  let nextFiber = fiber.parent;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.effectTag === EffectTag.DELETE) return false;\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction performAlternate(alternate: Fiber, instance: DarkElementInstance) {\r\n  const alternateType = getInstanceType(alternate.instance);\r\n  const elementType = getInstanceType(instance);\r\n  const isSameType = elementType === alternateType;\r\n  const flag = getElementFlag(instance);\r\n  const hasNoMovesFlag = flag && flag[Flag.HAS_NO_MOVES];\r\n\r\n  alternate.isUsed = true;\r\n\r\n  if (!isSameType) {\r\n    if (canAddToDeletions(alternate)) {\r\n      alternate.effectTag = EffectTag.DELETE;\r\n      deletionsStore.add(alternate);\r\n    }\r\n  } else if (\r\n    hasChildrenProp(alternate.instance) &&\r\n    hasChildrenProp(instance) &&\r\n    (hasNoMovesFlag ? alternate.childrenCount !== instance.children.length : true)\r\n  ) {\r\n    const { prevKeys, nextKeys, prevKeysMap, nextKeysMap, keyedFibersMap } = extractKeys(\r\n      alternate.child,\r\n      instance.children,\r\n    );\r\n    let result: Array<[DarkElement | [DarkElementKey, DarkElementKey], string]> = [];\r\n    let size = Math.max(prevKeys.length, nextKeys.length);\r\n    let nextFiber = alternate;\r\n    let idx = 0;\r\n    let p = 0;\r\n    let n = 0;\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      const nextKey = nextKeys[i - n] ?? null;\r\n      const prevKey = prevKeys[i - p] ?? null;\r\n      const prevKeyFiber = keyedFibersMap[prevKey] || null;\r\n      const nextKeyFiber = keyedFibersMap[nextKey] || createConditionalFiber(alternate, nextKey);\r\n\r\n      if (nextKey !== prevKey) {\r\n        if (nextKey !== null && !prevKeysMap[nextKey]) {\r\n          if (prevKey !== null && !nextKeysMap[prevKey]) {\r\n            result.push([[nextKey, prevKey], 'replace']);\r\n            nextKeyFiber.effectTag = EffectTag.CREATE;\r\n            prevKeyFiber.effectTag = EffectTag.DELETE;\r\n            deletionsStore.add(prevKeyFiber);\r\n          } else {\r\n            result.push([nextKey, 'insert']);\r\n            nextKeyFiber.effectTag = EffectTag.CREATE;\r\n            p++;\r\n            size++;\r\n          }\r\n          nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n        } else if (!nextKeysMap[prevKey]) {\r\n          result.push([prevKey, 'remove']);\r\n          prevKeyFiber.effectTag = EffectTag.DELETE;\r\n          deletionsStore.add(prevKeyFiber);\r\n          n++;\r\n          idx--;\r\n          size++;\r\n        } else if (nextKeysMap[prevKey] && nextKeysMap[nextKey]) {\r\n          result.push([[nextKey, prevKey], 'move']);\r\n          nextKeyFiber.effectTag = EffectTag.UPDATE;\r\n          prevKeyFiber.effectTag = EffectTag.UPDATE;\r\n          nextKeyFiber.move = true;\r\n          nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n        }\r\n      } else if (nextKey !== null) {\r\n        result.push([nextKey, 'stable']);\r\n        nextKeyFiber.effectTag = EffectTag.UPDATE;\r\n        nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n      }\r\n\r\n      nextKeyFiber.idx = idx;\r\n      idx++;\r\n    }\r\n\r\n    result = [];\r\n  }\r\n}\r\n\r\nfunction performMemo(fiber: Fiber, alternate: Fiber, instance: DarkElementInstance) {\r\n  const prevFactory = alternate.instance as ComponentFactory;\r\n  const nextFactory = instance as ComponentFactory;\r\n  if (fiber.move || nextFactory.type !== prevFactory.type) return;\r\n  const prevProps = prevFactory.props;\r\n  const nextProps = nextFactory.props;\r\n  const skip = !nextFactory.shouldUpdate(prevProps, nextProps);\r\n\r\n  if (skip) {\r\n    fiberMountStore.deepWalking.set(false);\r\n    const diff = fiber.elementIdx - alternate.elementIdx;\r\n    const deep = diff !== 0;\r\n\r\n    fiber.mutate({\r\n      ...alternate,\r\n      alternate,\r\n      id: fiber.id,\r\n      idx: fiber.idx,\r\n      parent: fiber.parent,\r\n      nextSibling: fiber.nextSibling,\r\n      elementIdx: fiber.elementIdx,\r\n      effectTag: EffectTag.SKIP,\r\n    });\r\n\r\n    walkFiber(fiber.child, ({ nextFiber, stop }) => {\r\n      if (nextFiber === fiber.nextSibling || nextFiber === fiber.parent) {\r\n        return stop();\r\n      }\r\n\r\n      if (nextFiber.parent === alternate) {\r\n        nextFiber.parent = fiber;\r\n      }\r\n\r\n      if (deep) {\r\n        nextFiber.elementIdx += diff;\r\n        if (nextFiber.parent !== fiber && nextFiber.nativeElement) return stop();\r\n      } else if (nextFiber === alternate.child.child) return stop();\r\n    });\r\n\r\n    fiber.incrementChildrenElementsCount(alternate.childrenElementsCount);\r\n\r\n    if (alternate.effectHost) {\r\n      fiber.markEffectHost();\r\n    }\r\n\r\n    if (alternate.layoutEffectHost) {\r\n      fiber.markLayoutEffectHost();\r\n    }\r\n\r\n    if (alternate.insertionEffectHost) {\r\n      fiber.markInsertionEffectHost();\r\n    }\r\n\r\n    if (alternate.portalHost) {\r\n      fiber.markPortalHost();\r\n    }\r\n  }\r\n}\r\n\r\nfunction pertformInstance(instance: DarkElementInstance, idx: number, fiber: Fiber) {\r\n  let performedInstance: DarkElementInstance = null;\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    const elements = detectIsArray(instance.children[idx])\r\n      ? flatten([instance.children[idx]])\r\n      : [instance.children[idx]];\r\n\r\n    instance.children.splice(idx, 1, ...elements);\r\n\r\n    performedInstance = instance.children[idx];\r\n    performedInstance = mountInstance(fiber, performedInstance);\r\n  }\r\n\r\n  if (detectIsComponentFactory(performedInstance)) {\r\n    if (hasEffects(fiber)) {\r\n      fiber.markEffectHost();\r\n    }\r\n\r\n    if (hasLayoutEffects(fiber)) {\r\n      fiber.markLayoutEffectHost();\r\n    }\r\n\r\n    if (hasInsertionEffects(fiber)) {\r\n      fiber.markInsertionEffectHost();\r\n    }\r\n\r\n    if (platform.detectIsPortal(performedInstance)) {\r\n      fiber.markPortalHost();\r\n    }\r\n  }\r\n\r\n  return performedInstance;\r\n}\r\n\r\nfunction mountInstance(fiber: Fiber, instance: DarkElementInstance) {\r\n  const isComponentFactory = detectIsComponentFactory(instance);\r\n  const factory = instance as ComponentFactory;\r\n\r\n  if (isComponentFactory) {\r\n    try {\r\n      let result = factory.type(factory.props, factory.ref);\r\n\r\n      if (detectIsArray(result) && !detectIsFragment(factory)) {\r\n        result = Fragment({ slot: result });\r\n      } else if (detectIsString(result) || detectIsNumber(result)) {\r\n        result = Text(result);\r\n      }\r\n\r\n      factory.children = detectIsArray(result)\r\n        ? (flatten([result]) as Array<DarkElementInstance>)\r\n        : ([result] as Array<DarkElementInstance>);\r\n    } catch (err) {\r\n      factory.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(instance)) {\r\n    instance = instance();\r\n  }\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    for (let i = 0; i < instance.children.length; i++) {\r\n      if (!instance.children[i]) {\r\n        instance.children[i] = supportConditional(instance.children[i]) as DarkElementInstance;\r\n      }\r\n    }\r\n\r\n    instance.children = isComponentFactory\r\n      ? instance.children\r\n      : detectIsArray(instance.children)\r\n      ? flatten([instance.children])\r\n      : [instance.children];\r\n\r\n    if (isComponentFactory && factory.children.length === 0) {\r\n      factory.children.push(createReplacer());\r\n    }\r\n  }\r\n\r\n  return instance;\r\n}\r\n\r\nfunction extractKeys(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n  const prevKeys: Array<DarkElementKey> = [];\r\n  const nextKeys: Array<DarkElementKey> = [];\r\n  const prevKeysMap: Record<DarkElementKey, boolean> = {};\r\n  const nextKeysMap: Record<DarkElementKey, boolean> = {};\r\n  const keyedFibersMap: Record<DarkElementKey, Fiber> = {};\r\n  const usedKeysMap: Record<DarkElementKey, boolean> = {};\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    if (nextFiber) {\r\n      const key = getElementKey(nextFiber.instance);\r\n      const prevKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      prevKeys.push(prevKey);\r\n      prevKeysMap[prevKey] = true;\r\n      keyedFibersMap[prevKey] = nextFiber;\r\n    }\r\n\r\n    if (children[idx]) {\r\n      const instance = children[idx];\r\n      const key = getElementKey(instance);\r\n      const nextKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        if (usedKeysMap[nextKey]) {\r\n          error(`[Dark]: The key of node [${nextKey}] already has been used!`, [instance]);\r\n        }\r\n\r\n        usedKeysMap[nextKey] = true;\r\n      }\r\n\r\n      nextKeys.push(nextKey);\r\n      nextKeysMap[nextKey] = true;\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.nextSibling : null;\r\n    idx++;\r\n  }\r\n\r\n  return {\r\n    prevKeys,\r\n    nextKeys,\r\n    prevKeysMap,\r\n    nextKeysMap,\r\n    keyedFibersMap,\r\n  };\r\n}\r\n\r\nfunction createIndexKey(idx: number) {\r\n  return `${INDEX_KEY}:${idx}`;\r\n}\r\n\r\nfunction getElementKey(instance: DarkElementInstance): DarkElementKey | null {\r\n  const key = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryKey(instance)\r\n    : detectIsVirtualNodeFactory(instance)\r\n    ? getVirtualNodeFactoryKey(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getTagVirtualNodeKey(instance)\r\n    : null;\r\n\r\n  return key;\r\n}\r\n\r\nfunction getElementFlag(instance: DarkElementInstance): Record<Flag, boolean> | null {\r\n  const flag = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryFlag(instance)\r\n    : detectIsVirtualNodeFactory(instance)\r\n    ? getVirtualNodeFactoryFlag(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getTagVirtualNodeFlag(instance)\r\n    : null;\r\n\r\n  return flag;\r\n}\r\n\r\nfunction supportConditional(instance: DarkElement) {\r\n  return detectIsFalsy(instance) ? createReplacer() : instance;\r\n}\r\n\r\nfunction getInstanceType(instance: DarkElementInstance): string | Function {\r\n  return detectIsVirtualNodeFactory(instance)\r\n    ? instance[TYPE]\r\n    : detectIsTagVirtualNode(instance)\r\n    ? instance.name\r\n    : detectIsVirtualNode(instance)\r\n    ? instance.type\r\n    : detectIsComponentFactory(instance)\r\n    ? instance.type\r\n    : null;\r\n}\r\n\r\nfunction hasChildrenProp(element: DarkElementInstance): element is TagVirtualNode | ComponentFactory {\r\n  return detectIsTagVirtualNode(element) || detectIsComponentFactory(element);\r\n}\r\n\r\nfunction detectIsSameComponentFactoryTypesWithSameKeys(\r\n  prevInstance: DarkElementInstance | null,\r\n  nextInstance: DarkElementInstance | null,\r\n) {\r\n  if (\r\n    prevInstance &&\r\n    nextInstance &&\r\n    detectIsComponentFactory(prevInstance) &&\r\n    detectIsComponentFactory(nextInstance) &&\r\n    prevInstance.type === nextInstance.type\r\n  ) {\r\n    const prevKey = prevInstance ? getElementKey(prevInstance) : null;\r\n    const nextKey = nextInstance ? getElementKey(nextInstance) : null;\r\n\r\n    return prevKey === nextKey;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getHook(alternate: Fiber, prevInstance: DarkElementInstance, nextInstance: DarkElementInstance): Hook | null {\r\n  if (alternate && detectIsSameComponentFactoryTypesWithSameKeys(prevInstance, nextInstance)) {\r\n    return alternate.hook;\r\n  }\r\n\r\n  if (detectIsComponentFactory(nextInstance)) {\r\n    return createHook();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction createHook(): Hook {\r\n  return {\r\n    idx: 0,\r\n    values: [],\r\n  };\r\n}\r\n\r\nfunction commitChanges() {\r\n  if (isHydrateZone.get() && detectHasRegisteredLazy()) return flush(null); // important order\r\n  const wipFiber = wipRootStore.get();\r\n  const isDynamic = platform.detectIsDynamic();\r\n  const insertionEffects = insertionEffectsStore.get();\r\n  const deletions = deletionsStore.get();\r\n  const fromUpdate = isUpdateHookZone.get();\r\n\r\n  // important order\r\n  for (const fiber of deletions) {\r\n    unmountFiber(fiber);\r\n    platform.applyCommit(fiber);\r\n  }\r\n\r\n  isInsertionEffectsZone.set(true);\r\n  isDynamic && insertionEffects.forEach(fn => fn());\r\n  isInsertionEffectsZone.set(false);\r\n\r\n  fromUpdate && syncElementIndices(wipFiber);\r\n\r\n  commitWork(wipFiber, () => {\r\n    const layoutEffects = layoutEffectsStore.get();\r\n    const effects = effectsStore.get();\r\n\r\n    isLayoutEffectsZone.set(true);\r\n    isDynamic && layoutEffects.forEach(fn => fn());\r\n    isLayoutEffectsZone.set(false);\r\n\r\n    setTimeout(() => {\r\n      isDynamic && effects.forEach(fn => fn());\r\n    });\r\n\r\n    flush(wipFiber);\r\n  });\r\n}\r\n\r\nfunction flush(wipFiber: Fiber) {\r\n  const fromUpdate = isUpdateHookZone.get();\r\n\r\n  wipRootStore.set(null); // important order\r\n  deletionsStore.reset();\r\n  insertionEffectsStore.reset();\r\n  layoutEffectsStore.reset();\r\n  effectsStore.reset();\r\n\r\n  if (fromUpdate) {\r\n    isUpdateHookZone.set(false);\r\n  } else {\r\n    currentRootStore.set(wipFiber);\r\n  }\r\n}\r\n\r\nfunction commitWork(fiber: Fiber, onComplete: Function) {\r\n  walkFiber(fiber.child, ({ nextFiber, isReturn, resetIsDeepWalking, stop }) => {\r\n    const skip = nextFiber.effectTag === EffectTag.SKIP;\r\n\r\n    if (nextFiber === fiber) return stop();\r\n\r\n    if (skip) {\r\n      resetIsDeepWalking();\r\n    } else if (!isReturn) {\r\n      platform.applyCommit(nextFiber);\r\n    }\r\n\r\n    nextFiber.alternate = null;\r\n  });\r\n\r\n  fiber.alternate = null;\r\n  platform.finishCommitWork();\r\n  onComplete();\r\n}\r\n\r\nfunction getParentFiberWithNativeElement(fiber: Fiber) {\r\n  let parentFiber = fiber;\r\n\r\n  while (parentFiber) {\r\n    parentFiber = parentFiber.parent;\r\n\r\n    if (parentFiber && parentFiber.nativeElement) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return parentFiber;\r\n}\r\n\r\nfunction syncElementIndices(fiber: Fiber) {\r\n  const diff = fiber.childrenElementsCount - fiber.alternate.childrenElementsCount;\r\n  if (diff === 0) return;\r\n  const parentFiber = getParentFiberWithNativeElement(fiber);\r\n  let isRight = false;\r\n\r\n  fiber.incrementChildrenElementsCount(diff, true);\r\n\r\n  walkFiber(parentFiber.child, ({ nextFiber, resetIsDeepWalking, isReturn, stop }) => {\r\n    if (nextFiber === parentFiber) return stop();\r\n    if (nextFiber === fiber) {\r\n      isRight = true;\r\n      return resetIsDeepWalking();\r\n    }\r\n\r\n    if (nextFiber.nativeElement) {\r\n      resetIsDeepWalking();\r\n    }\r\n\r\n    if (isRight && !isReturn) {\r\n      nextFiber.elementIdx += diff;\r\n    }\r\n  });\r\n}\r\n\r\ntype CreateUpdateCallbackOptions = {\r\n  rootId: number;\r\n  fiber: Fiber;\r\n  forceStart?: boolean;\r\n  onStart: () => void;\r\n};\r\n\r\nfunction createUpdateCallback(options: CreateUpdateCallbackOptions) {\r\n  const { rootId, fiber, forceStart = false, onStart } = options;\r\n  const callback = () => {\r\n    if (fiber.effectTag === EffectTag.DELETE) return;\r\n    forceStart && onStart();\r\n    if (fiber.isUsed) return;\r\n    !forceStart && onStart();\r\n    rootStore.set(rootId); // important order!\r\n    isUpdateHookZone.set(true);\r\n    fiberMountStore.reset();\r\n\r\n    fiber.alternate = new Fiber().mutate({ ...fiber });\r\n    fiber.marker = '';\r\n    fiber.effectTag = EffectTag.UPDATE;\r\n    fiber.childrenElementsCount = 0;\r\n    fiber.child = null;\r\n\r\n    wipRootStore.set(fiber);\r\n    currentFiberStore.set(fiber);\r\n    fiber.instance = mountInstance(fiber, fiber.instance);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nexport { Fiber, workLoop, createUpdateCallback };\r\n","export enum EffectTag {\r\n  CREATE = 'CREATE',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE',\r\n  SKIP = 'SKIP',\r\n}\r\n\r\nexport type NativeElement = unknown;\r\n\r\nexport type HookValue<T = any> = {\r\n  token?: Symbol;\r\n  deps: Array<any>;\r\n  value: T;\r\n};\r\n\r\nexport type Hook<T = any> = {\r\n  idx: number;\r\n  values: Array<T>;\r\n};\r\n","import { createComponent, detectIsComponentFactory } from '../component';\r\nimport type { KeyProps, SlotProps } from '../shared';\r\n\r\ntype FragmentProps = Required<SlotProps> & KeyProps;\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = createComponent<FragmentProps>(({ slot }) => slot || null, {\r\n  token: $$fragment,\r\n});\r\n\r\nconst detectIsFragment = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import type { NestedArray } from '../shared';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\n\r\nconst detectIsUndefined = (o: any): o is undefined => typeof o === 'undefined';\r\n\r\nconst detectIsNumber = (o: any): o is number => typeof o === 'number';\r\n\r\nconst detectIsString = (o: any): o is string => typeof o === 'string';\r\n\r\nconst detectIsObject = (o: any): o is object => typeof o === 'object';\r\n\r\nconst detectIsBoolean = (o: any): o is boolean => typeof o === 'boolean';\r\n\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\n\r\nconst detectIsNull = (o: any): o is null => o === null;\r\n\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nconst detectIsFalsy = (o: any) => detectIsNull(o) || detectIsUndefined(o) || o === false;\r\n\r\nconst getTime = () => Date.now();\r\n\r\nconst dummyFn = () => {};\r\n\r\nfunction error(...args: Array<any>) {\r\n  !detectIsUndefined(console) && console.error(...args);\r\n}\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>): Array<T> {\r\n  const list = [];\r\n  const levelMap = { 0: { idx: 0, source } };\r\n  let level = 0;\r\n\r\n  do {\r\n    const { source, idx } = levelMap[level];\r\n    const item = source[idx];\r\n\r\n    if (idx >= source.length) {\r\n      level--;\r\n      levelMap[level].idx++;\r\n      continue;\r\n    }\r\n\r\n    if (detectIsArray(item)) {\r\n      level++;\r\n      levelMap[level] = {\r\n        idx: 0,\r\n        source: item,\r\n      };\r\n    } else {\r\n      list.push(item);\r\n      levelMap[level].idx++;\r\n    }\r\n  } while (level > 0 || levelMap[level].idx < levelMap[level].source.length);\r\n\r\n  return list;\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction detectIsDepsDifferent(deps: Array<unknown>, prevDeps: Array<unknown>): boolean {\r\n  if (!detectIsUndefined(deps) && !detectIsUndefined(prevDeps) && deps.length > 0 && prevDeps.length > 0) {\r\n    for (let i = 0; i < prevDeps.length; i++) {\r\n      if (prevDeps[i] !== deps[i]) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  getTime,\r\n  dummyFn,\r\n  error,\r\n  flatten,\r\n  keyBy,\r\n  detectIsDepsDifferent,\r\n};\r\n","import {\r\n  type Component,\r\n  type ComponentFactory,\r\n  type StandardComponentProps,\r\n  type ShouldUpdate,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n} from '../component';\r\nimport type { RefProps, SlotProps } from '../shared';\r\nimport { type Ref, forwardRef } from '../ref';\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst defaultShouldUpdate = (props: {}, nextProps: {}): boolean => {\r\n  const keys = Object.keys(nextProps);\r\n\r\n  for (const key of keys) {\r\n    if (key !== 'slot' && nextProps[key] !== props[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst detectIsMemo = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$memo;\r\n\r\nfunction memo<T>(\r\n  component: (props?: T, ref?: Ref) => ComponentFactory<T>,\r\n  shouldUpdate: ShouldUpdate<T & SlotProps> = defaultShouldUpdate,\r\n): Component<T & StandardComponentProps> {\r\n  return forwardRef(\r\n    createComponent(\r\n      (props: T & RefProps, ref) => {\r\n        ref && (props.ref = ref);\r\n\r\n        return component(props);\r\n      },\r\n      { token: $$memo, shouldUpdate },\r\n    ),\r\n  );\r\n}\r\n\r\nexport { $$memo, memo, detectIsMemo };\r\n","import { type Fiber } from '../fiber';\r\nimport { type TaskPriority } from '../constants';\r\nimport { type VirtualNode } from '../view';\r\n\r\nexport type Platform = {\r\n  createNativeElement: <N>(vNode: VirtualNode) => N;\r\n  requestAnimationFrame: typeof requestAnimationFrame;\r\n  cancelAnimationFrame: typeof cancelAnimationFrame;\r\n  scheduleCallback: (callback: () => void, options?: ScheduleCallbackOptions) => void;\r\n  shouldYeildToHost: () => boolean;\r\n  applyCommit: (fiber: Fiber) => void;\r\n  finishCommitWork: () => void;\r\n  detectIsDynamic: () => boolean;\r\n  detectIsPortal: (factory: unknown) => boolean;\r\n  unmountPortal: (fiber: Fiber) => void;\r\n  restart: () => void;\r\n};\r\n\r\nexport type ScheduleCallbackOptions = {\r\n  priority?: TaskPriority;\r\n  timeoutMs?: number;\r\n  forceSync?: boolean;\r\n};\r\n\r\nconst platform: Platform = {\r\n  createNativeElement: () => {\r\n    throw new Error(msg('createNativeElement'));\r\n  },\r\n  requestAnimationFrame: () => {\r\n    throw new Error(msg('requestAnimationFrame'));\r\n  },\r\n  cancelAnimationFrame: () => {\r\n    throw new Error(msg('cancelAnimationFrame'));\r\n  },\r\n  scheduleCallback: () => {\r\n    throw new Error(msg('scheduleCallback'));\r\n  },\r\n  shouldYeildToHost: () => {\r\n    throw new Error(msg('shouldYeildToHost'));\r\n  },\r\n  applyCommit: () => {\r\n    throw new Error(msg('applyCommit'));\r\n  },\r\n  finishCommitWork: () => {\r\n    throw new Error(msg('finishCommitWork'));\r\n  },\r\n  detectIsDynamic: () => {\r\n    throw new Error(msg('detectIsDynamic'));\r\n  },\r\n  detectIsPortal: () => {\r\n    throw new Error(msg('detectIsPortal'));\r\n  },\r\n  unmountPortal: () => {\r\n    throw new Error(msg('unmountPortal'));\r\n  },\r\n  restart: () => {\r\n    throw new Error(msg('restart'));\r\n  },\r\n};\r\n\r\nconst msg = (x: string) => `${x} not installed by renderer`;\r\n\r\nconst detectIsServer = () => !platform.detectIsDynamic();\r\n\r\nexport { platform, detectIsServer };\r\n","import type { Fiber } from '../fiber';\r\n\r\nlet rootId: number = null;\r\n\r\nconst stores = new Map<number, Store>();\r\n\r\nclass Store {\r\n  public wipRoot: Fiber = null;\r\n  public currentRoot: Fiber = null;\r\n  public nextUnitOfWork: Fiber = null;\r\n  public events: Map<string, WeakMap<object, Function>> = new Map();\r\n  public unsubscribers: Array<() => void> = [];\r\n  public deletions: Set<Fiber> = new Set();\r\n  public fiberMount: FiberMountStore = {\r\n    level: 0,\r\n    navigation: {},\r\n    isDeepWalking: true,\r\n  };\r\n  public componentFiber: Fiber = null;\r\n  public effects: Array<() => void> = [];\r\n  public layoutEffects: Array<() => void> = [];\r\n  public insertionEffects: Array<() => void> = [];\r\n  public isLayoutEffectsZone = false;\r\n  public isInserionEffectsZone = false;\r\n  public isUpdateHookZone = false;\r\n  public isBatchZone = false;\r\n  public isHydrateZone = false;\r\n  public lazy: Set<number> = new Set();\r\n}\r\n\r\ntype FiberMountStore = {\r\n  level: number;\r\n  navigation: Record<number, number>;\r\n  isDeepWalking: boolean;\r\n};\r\n\r\nconst rootStore = {\r\n  set: (id: number) => {\r\n    rootId = id;\r\n    !stores.get(rootId) && stores.set(rootId, new Store());\r\n  },\r\n  remove: (id: number) => stores.delete(id),\r\n};\r\n\r\nconst getRootId = () => rootId;\r\n\r\nconst store = {\r\n  get: (id: number = rootId) => stores.get(id),\r\n};\r\n\r\nconst wipRootStore = {\r\n  get: () => store.get()?.wipRoot || null,\r\n  set: (fiber: Fiber) => (store.get().wipRoot = fiber),\r\n};\r\n\r\nconst currentRootStore = {\r\n  get: (id?: number) => store.get(id)?.currentRoot || null,\r\n  set: (fiber: Fiber) => (store.get().currentRoot = fiber),\r\n};\r\n\r\nconst nextUnitOfWorkStore = {\r\n  get: () => store.get()?.nextUnitOfWork || null,\r\n  set: (fiber: Fiber) => (store.get().nextUnitOfWork = fiber),\r\n};\r\n\r\nconst currentFiberStore = {\r\n  get: () => store.get()?.componentFiber,\r\n  set: (fiber: Fiber) => (store.get().componentFiber = fiber),\r\n};\r\n\r\nconst eventsStore = {\r\n  get: () => store.get().events,\r\n  addUnsubscriber: (fn: () => void) => store.get().unsubscribers.push(fn),\r\n  unsubscribe: (id: number) => store.get(id).unsubscribers.forEach(fn => fn()),\r\n};\r\n\r\nconst deletionsStore = {\r\n  get: () => store.get().deletions,\r\n  add: (fiber: Fiber) => store.get().deletions.add(fiber),\r\n  has: (fiber: Fiber) => store.get().deletions.has(fiber),\r\n  set: (deletions: Set<Fiber>) => (store.get().deletions = deletions),\r\n  reset: () => (store.get().deletions = new Set()),\r\n};\r\n\r\nconst fiberMountStore = {\r\n  reset: () => {\r\n    store.get().fiberMount = {\r\n      level: 0,\r\n      navigation: {},\r\n      isDeepWalking: true,\r\n    };\r\n  },\r\n  getIndex: () => store.get().fiberMount.navigation[store.get().fiberMount.level],\r\n  jumpToChild: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level + 1;\r\n\r\n    fiberMount.level = nextLevel;\r\n    fiberMount.navigation[nextLevel] = 0;\r\n  },\r\n  jumpToParent: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level - 1;\r\n\r\n    fiberMount.navigation[level] = 0;\r\n    fiberMount.level = nextLevel;\r\n  },\r\n  jumpToSibling: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const idx = fiberMount.navigation[level] + 1;\r\n\r\n    fiberMount.navigation[level] = idx;\r\n  },\r\n  deepWalking: {\r\n    get: () => store.get().fiberMount.isDeepWalking,\r\n    set: (value: boolean) => (store.get().fiberMount.isDeepWalking = value),\r\n  },\r\n};\r\n\r\nconst effectsStore = {\r\n  get: () => store.get().effects,\r\n  reset: () => (store.get().effects = []),\r\n  add: (effect: () => void) => store.get().effects.push(effect),\r\n};\r\n\r\nconst layoutEffectsStore = {\r\n  get: () => store.get().layoutEffects,\r\n  reset: () => (store.get().layoutEffects = []),\r\n  add: (effect: () => void) => store.get().layoutEffects.push(effect),\r\n};\r\n\r\nconst insertionEffectsStore = {\r\n  get: () => store.get().insertionEffects,\r\n  reset: () => (store.get().insertionEffects = []),\r\n  add: (effect: () => void) => store.get().insertionEffects.push(effect),\r\n};\r\n\r\nconst isLayoutEffectsZone = {\r\n  get: () => store.get()?.isLayoutEffectsZone || false,\r\n  set: (value: boolean) => (store.get().isLayoutEffectsZone = value),\r\n};\r\n\r\nconst isInsertionEffectsZone = {\r\n  get: (id?: number) => store.get(id)?.isInserionEffectsZone || false,\r\n  set: (value: boolean) => (store.get().isInserionEffectsZone = value),\r\n};\r\n\r\nconst isUpdateHookZone = {\r\n  get: () => store.get()?.isUpdateHookZone || false,\r\n  set: (value: boolean) => (store.get().isUpdateHookZone = value),\r\n};\r\n\r\nconst isBatchZone = {\r\n  get: () => store.get()?.isBatchZone || false,\r\n  set: (value: boolean) => (store.get().isBatchZone = value),\r\n};\r\n\r\nconst isHydrateZone = {\r\n  get: () => store.get()?.isHydrateZone || false,\r\n  set: (value: boolean) => (store.get().isHydrateZone = value),\r\n};\r\n\r\nconst registerLazy = () => {\r\n  const { id } = currentFiberStore.get();\r\n\r\n  store.get().lazy.add(id);\r\n\r\n  return id;\r\n};\r\n\r\nconst unregisterLazy = (id: number) => store.get().lazy.delete(id);\r\n\r\nconst detectHasRegisteredLazy = () => store.get().lazy.size > 0;\r\n\r\nexport {\r\n  getRootId,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  currentFiberStore,\r\n  eventsStore,\r\n  deletionsStore,\r\n  fiberMountStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  insertionEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isInsertionEffectsZone,\r\n  isUpdateHookZone,\r\n  isBatchZone,\r\n  isHydrateZone,\r\n  registerLazy,\r\n  unregisterLazy,\r\n  detectHasRegisteredLazy,\r\n};\r\n","import { type Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { detectIsComponentFactory } from '../component';\r\nimport { dropEffects } from '../use-effect';\r\nimport { dropLayoutEffects } from '../use-layout-effect';\r\nimport { dropInsertionEffects } from '../use-insertion-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { detectIsUndefined } from '../helpers';\r\nimport { currentRootStore, eventsStore, rootStore } from '../scope';\r\n\r\nfunction unmountFiber(fiber: Fiber) {\r\n  if (!fiber.insertionEffectHost && !fiber.layoutEffectHost && !fiber.effectHost && !fiber.portalHost) return;\r\n\r\n  walkFiber(fiber, ({ nextFiber, isReturn, stop }) => {\r\n    if (nextFiber === fiber.nextSibling) return stop();\r\n    if (!isReturn && detectIsComponentFactory(nextFiber.instance)) {\r\n      // important order\r\n      nextFiber.insertionEffectHost && dropInsertionEffects(nextFiber.hook);\r\n      nextFiber.layoutEffectHost && dropLayoutEffects(nextFiber.hook);\r\n      nextFiber.effectHost && dropEffects(nextFiber.hook);\r\n      nextFiber.portalHost && platform.unmountPortal(nextFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction unmountRoot(rootId: number, onComplete: () => void) {\r\n  if (detectIsUndefined(rootId)) return;\r\n\r\n  unmountFiber(currentRootStore.get(rootId));\r\n  eventsStore.unsubscribe(rootId);\r\n  rootStore.remove(rootId);\r\n  onComplete();\r\n}\r\n\r\nexport { unmountFiber, unmountRoot };\r\n","import { useMemo } from '../use-memo';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const value = useMemo(() => callback, deps);\r\n\r\n  return value;\r\n}\r\n\r\nexport { useCallback };\r\n","import { detectIsUndefined, detectIsFunction, detectIsDepsDifferent } from '../helpers';\r\nimport { currentFiberStore, effectsStore } from '../scope';\r\nimport type { Fiber, Hook, HookValue } from '../fiber';\r\nimport type { Effect, DropEffect } from './types';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\n\r\nconst { useEffect, hasEffects, dropEffects } = createEffect($$useEffect, effectsStore);\r\n\r\nfunction createEffect(token: Symbol, store: typeof effectsStore) {\r\n  function useEffect(effect: Effect, deps?: Array<any>) {\r\n    const fiber = currentFiberStore.get();\r\n    const hook = fiber.hook as Hook<HookValue<DropEffect>>;\r\n    const { idx, values } = hook;\r\n    const runEffect = () => {\r\n      values[idx] = {\r\n        deps,\r\n        token,\r\n        value: undefined,\r\n      };\r\n\r\n      store.add(() => {\r\n        values[idx].value = effect();\r\n      });\r\n    };\r\n\r\n    if (detectIsUndefined(values[idx])) {\r\n      runEffect();\r\n    } else {\r\n      const { deps: prevDeps, value: cleanup } = values[idx];\r\n      const isDepsDifferent = deps ? detectIsDepsDifferent(deps, prevDeps) : true;\r\n\r\n      if (isDepsDifferent) {\r\n        detectIsFunction(cleanup) && cleanup();\r\n        runEffect();\r\n      }\r\n    }\r\n\r\n    hook.idx++;\r\n  }\r\n\r\n  function hasEffects(fiber: Fiber) {\r\n    const { values } = fiber.hook as Hook<HookValue>;\r\n    const hasEffect = values.some(x => x?.token === token);\r\n\r\n    return hasEffect;\r\n  }\r\n\r\n  function dropEffects(hook: Hook<HookValue<DropEffect>>) {\r\n    const { values } = hook;\r\n\r\n    for (const value of values) {\r\n      if (value.token === token) {\r\n        const cleanup = value.value;\r\n\r\n        detectIsFunction(cleanup) && cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    useEffect,\r\n    hasEffects,\r\n    dropEffects,\r\n  };\r\n}\r\n\r\nexport { useEffect, hasEffects, dropEffects, createEffect };\r\n","import { insertionEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useInsertionEffect = Symbol('use-insertion-effect');\r\n\r\nconst {\r\n  useEffect: useInsertionEffect,\r\n  hasEffects: hasInsertionEffects,\r\n  dropEffects: dropInsertionEffects,\r\n} = createEffect($$useInsertionEffect, insertionEffectsStore);\r\n\r\nexport { useInsertionEffect, hasInsertionEffects, dropInsertionEffects };\r\n","import { layoutEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useLayoutEffect = Symbol('use-layout-effect');\r\n\r\nconst {\r\n  useEffect: useLayoutEffect,\r\n  hasEffects: hasLayoutEffects,\r\n  dropEffects: dropLayoutEffects,\r\n} = createEffect($$useLayoutEffect, layoutEffectsStore);\r\n\r\nexport { useLayoutEffect, hasLayoutEffects, dropLayoutEffects };\r\n","import type { DarkElement, SlotProps } from '../shared';\r\nimport { detectIsUndefined, detectIsArray, detectIsDepsDifferent } from '../helpers';\r\nimport { detectIsComponentFactory, createComponent } from '../component';\r\nimport { detectIsVirtualNodeFactory } from '../view';\r\nimport { currentFiberStore } from '../scope';\r\nimport { Fragment } from '../fragment';\r\nimport { $$memo } from '../memo';\r\n\r\ntype MemoProps = Required<SlotProps>;\r\n\r\nconst Memo = createComponent<MemoProps>(({ slot }) => slot, { token: $$memo });\r\n\r\nfunction wrap<T>(value: T, isDepsDifferent: boolean) {\r\n  const check = (value: T) => detectIsVirtualNodeFactory(value) || detectIsComponentFactory(value);\r\n\r\n  if (detectIsArray(value) ? check(value[0]) : check(value)) {\r\n    const slot = value as unknown as DarkElement;\r\n    const factory = Memo({\r\n      slot: Fragment({ slot }),\r\n    });\r\n\r\n    factory.shouldUpdate = () => isDepsDifferent;\r\n\r\n    return factory;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction processValue<T>(getValue: () => T, isDepsDifferent = false) {\r\n  return wrap(getValue(), isDepsDifferent);\r\n}\r\n\r\nfunction useMemo<T>(getValue: () => T, deps: Array<any>): T {\r\n  const fiber = currentFiberStore.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    const value = processValue(getValue);\r\n\r\n    values[idx] = {\r\n      deps,\r\n      value,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return value as T;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const prevDeps = hookValue.deps as Array<any>;\r\n  const isDepsDifferent = detectIsDepsDifferent(deps, prevDeps);\r\n  const computedGetValue = isDepsDifferent ? getValue : () => hookValue.value;\r\n\r\n  hookValue.deps = deps;\r\n  hookValue.value = processValue(computedGetValue, isDepsDifferent);\r\n\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useMemo };\r\n","import { type ScheduleCallbackOptions } from '../platform';\r\nimport { detectIsFunction } from '../helpers';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\n\r\nfunction useState<T = unknown>(\r\n  initialValue: T | (() => T),\r\n  options?: ScheduleCallbackOptions,\r\n): [T, (value: Value<T>) => void] {\r\n  const update = useUpdate(options);\r\n  const store = useMemo(\r\n    () => ({\r\n      value: detectIsFunction(initialValue) ? initialValue() : initialValue,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    const prevValue = store.value;\r\n    const newValue = detectIsFunction(sourceValue) ? sourceValue(prevValue) : sourceValue;\r\n\r\n    if (!Object.is(prevValue, newValue)) {\r\n      const setValue = () => (store.value = newValue);\r\n\r\n      if (options?.priority === TaskPriority.LOW) {\r\n        update(() => setValue());\r\n      } else {\r\n        setValue();\r\n        update();\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  return [store.value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { platform, type ScheduleCallbackOptions } from '../platform';\r\nimport { getRootId, currentFiberStore, isInsertionEffectsZone, isLayoutEffectsZone, isBatchZone } from '../scope';\r\nimport { createUpdateCallback } from '../fiber';\r\nimport { useMemo } from '../use-memo';\r\nimport { dummyFn } from '../helpers';\r\nimport { runBatch as batch } from '../batch';\r\n\r\nfunction useUpdate(options?: ScheduleCallbackOptions) {\r\n  const rootId = getRootId();\r\n  const scope = useMemo(() => ({ fiber: null }), []);\r\n\r\n  scope.fiber = currentFiberStore.get();\r\n\r\n  const update = (onStart?: () => void) => {\r\n    if (isInsertionEffectsZone.get()) return;\r\n    const callback = createUpdateCallback({\r\n      rootId,\r\n      fiber: scope.fiber,\r\n      forceStart: Boolean(options?.timeoutMs),\r\n      onStart: onStart || dummyFn,\r\n    });\r\n\r\n    if (isLayoutEffectsZone.get()) {\r\n      options = {\r\n        ...(options || {}),\r\n        forceSync: true,\r\n      };\r\n    }\r\n\r\n    if (isBatchZone.get()) {\r\n      batch(scope.fiber, () => platform.scheduleCallback(callback, options));\r\n    } else {\r\n      platform.scheduleCallback(callback, options);\r\n    }\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { type Fiber } from '../fiber';\r\nimport { isBatchZone } from '../scope';\r\n\r\nfunction batch(callback: () => void) {\r\n  isBatchZone.set(true);\r\n  callback();\r\n}\r\n\r\nfunction runBatch(fiber: Fiber, callback: () => void) {\r\n  fiber.batched && window.clearTimeout(fiber.batched);\r\n  fiber.batched = window.setTimeout(() => {\r\n    isBatchZone.set(false);\r\n    fiber.batched = null;\r\n    callback();\r\n  });\r\n}\r\n\r\nexport { batch, runBatch };\r\n","import { SlotProps, RefProps, KeyProps, FlagProps } from '../shared';\r\n\r\nexport type ViewDef = {\r\n  as: string;\r\n  _void?: boolean;\r\n  [prop: string]: any;\r\n} & Partial<SlotProps> &\r\n  RefProps &\r\n  KeyProps &\r\n  FlagProps;\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import { REPLACER, ATTR_KEY, ATTR_FLAG, TYPE, Flag } from '../constants';\r\nimport { detectIsArray, detectIsEmpty, detectIsFunction } from '../helpers';\r\nimport type { DarkElementKey, DarkElement } from '../shared';\r\nimport type { ComponentFactory } from '../component';\r\nimport { NodeType, type ViewDef } from './types';\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type TextVirtualNodeFactory = () => TextVirtualNode;\r\nexport type CommentVirtualNodeFactory = () => CommentVirtualNode;\r\n\r\nconst $$virtualNode = Symbol('virtual-node');\r\n\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(type: NodeType) {\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public name: string = null;\r\n  public attrs: Record<string, any> = {};\r\n  public children: Array<VirtualNodeFactory | ComponentFactory> = [];\r\n\r\n  constructor(name: string, attrs: TagVirtualNode['attrs'], children: TagVirtualNode['children']) {\r\n    super(NodeType.TAG);\r\n    this.name = name || this.name;\r\n    this.attrs = attrs || this.attrs;\r\n    this.children = children || this.children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.TEXT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.COMMENT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\n\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\n\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\n\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$virtualNode] === true;\r\n\r\nconst getTagVirtualNodeKey = (vNode: TagVirtualNode): DarkElementKey | null =>\r\n  !detectIsEmpty(vNode.attrs[ATTR_KEY]) ? vNode.attrs[ATTR_KEY] : null;\r\n\r\nconst getTagVirtualNodeFlag = (vNode: TagVirtualNode): Record<Flag, boolean> | null => vNode.attrs[ATTR_FLAG] || null;\r\n\r\nconst getVirtualNodeFactoryKey = (factory: VirtualNodeFactory): DarkElementKey | null =>\r\n  !detectIsEmpty(factory[ATTR_KEY]) ? factory[ATTR_KEY] : null;\r\n\r\nconst getVirtualNodeFactoryFlag = (factory: VirtualNodeFactory): Record<Flag, boolean> | null =>\r\n  factory[ATTR_FLAG] || null;\r\n\r\nconst createReplacer = () => new CommentVirtualNode(REPLACER);\r\n\r\nconst detectIsPlainVirtualNode = (vNode: unknown) =>\r\n  detectIsTextVirtualNode(vNode) || detectIsCommentVirtualNode(vNode);\r\n\r\nfunction View(def: ViewDef): TagVirtualNodeFactory {\r\n  const factory = () => {\r\n    const { as: name, slot, _void = false, ...attrs } = def;\r\n    const children = (_void ? [] : detectIsArray(slot) ? slot : slot ? [slot] : []) as TagVirtualNode['children'];\r\n\r\n    return new TagVirtualNode(name, attrs, children);\r\n  };\r\n\r\n  factory[$$virtualNode] = true;\r\n  factory[ATTR_KEY] = def.key;\r\n  factory[ATTR_FLAG] = def.flag;\r\n  factory[TYPE] = def.as;\r\n\r\n  return factory;\r\n}\r\n\r\nfunction Text(source: string | number): TextVirtualNode {\r\n  return new TextVirtualNode(source + '');\r\n}\r\n\r\nText.from = (source: DarkElement) => (detectIsTextVirtualNode(source) ? source.value : source + '');\r\n\r\nfunction Comment(text: string): CommentVirtualNodeFactory {\r\n  const factory = () => new CommentVirtualNode(text);\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nexport {\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsPlainVirtualNode,\r\n  getTagVirtualNodeKey,\r\n  getTagVirtualNodeFlag,\r\n  getVirtualNodeFactoryKey,\r\n  getVirtualNodeFactoryFlag,\r\n  createReplacer,\r\n  detectIsVirtualNodeFactory,\r\n  View,\r\n  Text,\r\n  Comment,\r\n};\r\n","import { type Fiber } from '../fiber';\r\n\r\ntype OnLoopOptions<T> = {\r\n  nextFiber: Fiber<T>;\r\n  isReturn: boolean;\r\n  resetIsDeepWalking: () => void;\r\n  stop: () => void;\r\n};\r\n\r\nfunction walkFiber<T = unknown>(fiber: Fiber<T>, onLoop: (options: OnLoopOptions<T>) => void) {\r\n  let nextFiber = fiber;\r\n  let isDeepWalking = true;\r\n  let isReturn = false;\r\n  let isStopped = false;\r\n  const visitedMap: Record<number, boolean> = {};\r\n  const detectCanVisit = (id: number) => !visitedMap[id];\r\n  const resetIsDeepWalking = () => (isDeepWalking = false);\r\n  const stop = () => (isStopped = true);\r\n\r\n  while (nextFiber) {\r\n    onLoop({\r\n      nextFiber: nextFiber as Fiber<T>,\r\n      isReturn,\r\n      resetIsDeepWalking,\r\n      stop,\r\n    });\r\n\r\n    if (isStopped) {\r\n      break;\r\n    }\r\n\r\n    if (nextFiber.child && isDeepWalking && detectCanVisit(nextFiber.child.id)) {\r\n      const newFiber = nextFiber.child;\r\n\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (nextFiber.nextSibling && detectCanVisit(nextFiber.nextSibling.id)) {\r\n      const newFiber = nextFiber.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (\r\n      nextFiber.parent &&\r\n      nextFiber.parent === fiber &&\r\n      nextFiber.parent.nextSibling &&\r\n      detectCanVisit(nextFiber.parent.nextSibling.id)\r\n    ) {\r\n      const newFiber = nextFiber.parent.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (nextFiber.parent && nextFiber.parent !== fiber) {\r\n      isDeepWalking = false;\r\n      isReturn = true;\r\n      nextFiber = nextFiber.parent;\r\n    } else {\r\n      nextFiber = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport { walkFiber };\r\n","export const SLASH = '/';\r\nexport const PARAMETER = ':';\r\nexport const WILDCARD = '**';\r\nexport const PROTOCOL_MARK = '://';\r\nexport const SEARCH_MARK = '?';\r\nexport const HASH_MARK = '#';\r\nexport const ROOT = '_ROOT_';\r\n","import { createContext, useContext } from '@dark-engine/core';\r\nimport { type RouterLocation } from '../location';\r\nimport { type RouterHistory } from '../history';\r\nimport { type Route } from '../create-routes';\r\n\r\nexport type ActiveRouteContextValue = {\r\n  location: RouterLocation;\r\n  params: Map<string, string>;\r\n  activeRoute: Route;\r\n};\r\n\r\nconst ActiveRouteContext = createContext<ActiveRouteContextValue>(null, { displayName: 'ActiveRoute' });\r\n\r\nfunction useActiveRouteContext() {\r\n  const value = useContext(ActiveRouteContext);\r\n\r\n  return value;\r\n}\r\n\r\nexport type RouterHistoryContextValue = {\r\n  history: RouterHistory;\r\n};\r\n\r\nconst RouterHistoryContext = createContext<RouterHistoryContextValue>(null, { displayName: 'RouterHistory' });\r\n\r\nfunction useRouterHistoryContext() {\r\n  const value = useContext(RouterHistoryContext);\r\n\r\n  return value;\r\n}\r\n\r\nconst CurrentPathContext = createContext<string>(null, { displayName: 'CurrentPath' });\r\n\r\nfunction useCurrentPathContext() {\r\n  const value = useContext(CurrentPathContext);\r\n\r\n  return value;\r\n}\r\n\r\nfunction checkContextValue(value: ActiveRouteContextValue | RouterHistoryContextValue) {\r\n  if (!value) {\r\n    throw new Error('[web-router]:  Illegal invoke hook outside router!');\r\n  }\r\n}\r\n\r\nexport {\r\n  ActiveRouteContext,\r\n  useActiveRouteContext,\r\n  RouterHistoryContext,\r\n  useRouterHistoryContext,\r\n  CurrentPathContext,\r\n  useCurrentPathContext,\r\n  checkContextValue,\r\n};\r\n","import { type DarkElement, type Component, type SlotProps, keyBy, detectIsString } from '@dark-engine/core';\r\n\r\nimport { SLASH, WILDCARD, ROOT } from '../constants';\r\nimport { pipe, splitPath, normalaizePathname, detectIsParam, getParamName, sort } from '../utils';\r\nimport { CurrentPathContext } from '../context';\r\nimport type { Routes, RouteDescriptor, PathMatchStrategy, Params } from './types';\r\n\r\ntype RouteConstructorOptions = {\r\n  prefix: string;\r\n  parent: Route;\r\n} & RouteDescriptor;\r\n\r\nclass Route {\r\n  public path = '';\r\n  public pathMatch?: PathMatchStrategy;\r\n  public parent: Route = null;\r\n  public children: Array<Route> = [];\r\n  public level: number = null;\r\n  public marker = '';\r\n  public redirectTo: {\r\n    path: string;\r\n    route: Route;\r\n  };\r\n  public component: RouteConstructorOptions['component'] | null;\r\n\r\n  constructor(options: RouteConstructorOptions) {\r\n    const { prefix, path, redirectTo, pathMatch = 'prefix', children = [], parent, component } = options;\r\n    const rootPath = createRootPath(path);\r\n    const path$ = createPath(pathMatch, prefix, rootPath);\r\n\r\n    this.path = path$;\r\n    this.pathMatch = pathMatch;\r\n    this.parent = parent;\r\n    this.children = createRoutes(children, path$, this);\r\n    this.level = parent ? parent.level + 1 : 0;\r\n    this.marker = rootPath;\r\n    this.redirectTo = detectIsString(redirectTo)\r\n      ? {\r\n          path: createPath(pathMatch, prefix, createRootPath(redirectTo)),\r\n          route: null,\r\n        }\r\n      : null;\r\n    this.component = component || null;\r\n  }\r\n\r\n  private getRoute(): Route {\r\n    return this;\r\n  }\r\n\r\n  public getPath() {\r\n    return this.path.replaceAll(ROOT + SLASH, '');\r\n  }\r\n\r\n  public render(): DarkElement {\r\n    let slot = null;\r\n    let nextRoute = this.getRoute();\r\n\r\n    while (nextRoute) {\r\n      const value = nextRoute.getPath();\r\n      const component = nextRoute.component as Component<SlotProps>;\r\n\r\n      slot = CurrentPathContext.Provider({ value, slot: [component({ slot })] });\r\n      nextRoute = nextRoute.parent;\r\n    }\r\n\r\n    return slot;\r\n  }\r\n}\r\n\r\nfunction createRoutes(routes: Routes, prefix = SLASH, parent: Route = null): Array<Route> {\r\n  const routes$: Array<Route> = [];\r\n\r\n  for (const route of routes) {\r\n    const route$ = new Route({ ...route, prefix, parent });\r\n\r\n    routes$.push(route$, ...route$.children);\r\n  }\r\n\r\n  if (!parent) {\r\n    const map = keyBy(routes$, x => x.path, true) as Record<string, Route>;\r\n\r\n    for (const route$ of routes$) {\r\n      if (route$.redirectTo) {\r\n        route$.redirectTo.route = map[route$.redirectTo.path] || null;\r\n      }\r\n    }\r\n  }\r\n\r\n  return routes$;\r\n}\r\n\r\nfunction resolve(pathname: string, routes: Array<Route>): Route {\r\n  const route = pipe<Route>(\r\n    match(pathname, routes),\r\n    redirect(),\r\n    wildcard(pathname, routes),\r\n    redirect(),\r\n    root(),\r\n    redirect(),\r\n    canRender(),\r\n  )();\r\n\r\n  return route;\r\n}\r\n\r\nfunction match(pathname: string, routes: Array<Route>) {\r\n  return (): Route => {\r\n    const [route] = pipe<Array<Route>>(\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchByFirstStrategy(pathname, x.path)),\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchBySecondStrategy(pathname, x.path)),\r\n    )(routes);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction redirect() {\r\n  return (route: Route): Route => {\r\n    if (route?.redirectTo) return redirect()(route.redirectTo.route);\r\n    if (route?.parent?.redirectTo) return redirect()(route.parent.redirectTo.route);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction wildcard(pathname: string, routes: Array<Route>) {\r\n  return (route$: Route): Route => {\r\n    if (route$) return route$;\r\n    const [route] = pipe<Array<Route>>(\r\n      (routes: Array<Route>) => routes.filter(x => x.marker === WILDCARD),\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchAsWildcard(pathname, x.path)) || null,\r\n      (routes: Array<Route>) => sort('desc', routes, x => x.level),\r\n    )(routes);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction root() {\r\n  return (route: Route): Route => {\r\n    const root = route?.children.find(x => x.marker === ROOT) || route;\r\n\r\n    return pick(root);\r\n  };\r\n}\r\n\r\nfunction canRender() {\r\n  return (route: Route): Route => {\r\n    if (route?.component) return route;\r\n\r\n    if (process.env.NODE_ENV !== 'test') {\r\n      throw new Error('[web-router]: Route not found or it has no component!');\r\n    }\r\n\r\n    return null;\r\n  };\r\n}\r\n\r\nconst pick = (route: Route): Route | null => route || null;\r\n\r\nfunction detectIsMatchByFirstStrategy(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: (_, b) => b,\r\n    skip: ({ isRoot, isParam }) => isRoot || isParam,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\nfunction detectIsMatchBySecondStrategy(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: a => a,\r\n    skip: ({ isParam }) => isParam,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\nfunction detectIsMatchAsWildcard(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: (_, b) => b,\r\n    skip: ({ isRoot, isParam, isWildcard }) => isRoot || isParam || isWildcard,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\ntype CreateMatcherOptions = {\r\n  space: (a: Array<string>, b: Array<string>) => Array<string>;\r\n  skip: (options: SkipOptions) => boolean;\r\n};\r\n\r\ntype SkipOptions = {\r\n  isRoot: boolean;\r\n  isWildcard: boolean;\r\n  isParam: boolean;\r\n};\r\n\r\nfunction createMatcher(options: CreateMatcherOptions) {\r\n  const { space, skip } = options;\r\n  return (urlPath: string, routePath: string) => {\r\n    const sUrlPath = splitPath(urlPath);\r\n    const sRoutePath = splitPath(routePath);\r\n\r\n    for (let i = 0; i < space(sUrlPath, sRoutePath).length; i++) {\r\n      const segment = sRoutePath[i];\r\n      const isRoot = segment === ROOT;\r\n      const isWildcard = segment === WILDCARD;\r\n      const isParam = detectIsParam(segment);\r\n\r\n      if (segment !== sUrlPath[i] && !skip({ isRoot, isWildcard, isParam })) return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n}\r\n\r\nfunction createPathname(urlPath: string, routePath: string): string {\r\n  const sUrlPath = splitPath(urlPath);\r\n  const sRoutePath = splitPath(routePath);\r\n  const parts: Array<string> = [];\r\n\r\n  for (let i = 0; i < sRoutePath.length; i++) {\r\n    const isParam = detectIsParam(sRoutePath[i]);\r\n\r\n    if (isParam) {\r\n      const param = sUrlPath[i] || 'null';\r\n\r\n      parts.push(param);\r\n    } else {\r\n      parts.push(sRoutePath[i]);\r\n    }\r\n  }\r\n\r\n  let newPathname = normalaizePathname(parts.join(SLASH));\r\n\r\n  if (newPathname[0] !== SLASH) {\r\n    newPathname = SLASH + newPathname;\r\n  }\r\n\r\n  return newPathname;\r\n}\r\n\r\nfunction createPath(pathMatch: PathMatchStrategy, prefix: string, path: string): string {\r\n  const prefix$ = pathMatch === 'prefix' ? normalaizePathname(prefix) : '';\r\n\r\n  return normalaizePathname(prefix$ ? `${prefix$}${path}` : path);\r\n}\r\n\r\nfunction createRootPath(path: string): string {\r\n  return path === SLASH || path === '' ? ROOT : path;\r\n}\r\n\r\nconst getParamsMap = (pathname: string, route: Route): Params => {\r\n  const sPathname = splitPath(pathname);\r\n  const sPath = splitPath(route.path);\r\n  const map = new Map();\r\n\r\n  for (let i = 0; i < sPath.length; i++) {\r\n    if (detectIsParam(sPath[i])) {\r\n      map.set(getParamName(sPath[i]), sPathname[i]);\r\n    }\r\n  }\r\n\r\n  return map;\r\n};\r\n\r\nfunction resolveRoute(pathname: string, routes: Array<Route>) {\r\n  const activeRoute = resolve(pathname, routes);\r\n  const slot = activeRoute ? activeRoute.render() : null;\r\n  const params = activeRoute ? getParamsMap(pathname, activeRoute) : null;\r\n  const value = { activeRoute, slot, params };\r\n\r\n  return value;\r\n}\r\n\r\nexport { type Route, createRoutes, resolve, resolveRoute, createPathname };\r\n","import { h, createComponent, useMemo, useEvent, detectIsFunction, type DarkElement } from '@dark-engine/core';\r\nimport { type SyntheticEvent } from '@dark-engine/platform-browser';\r\nimport { useHistory } from '../use-history';\r\nimport { useLocation } from '../use-location';\r\nimport { normalaizePathname, cm, parseURL } from '../utils';\r\n\r\nexport type RoutreLinkProps = {\r\n  to: string;\r\n  activeClassName?: string;\r\n  className?: string;\r\n  title?: string;\r\n  slot: DarkElement;\r\n  onClick?: (e: SyntheticEvent<MouseEvent, HTMLLinkElement>) => void;\r\n};\r\n\r\nconst RouterLink = createComponent<RoutreLinkProps>(\r\n  ({ to, activeClassName, className: sourceClassName, slot, onClick, ...rest }) => {\r\n    const history = useHistory();\r\n    const { pathname, hash } = useLocation();\r\n    const isActive = useMemo(() => detectIsActiveLink(pathname, hash, to), [pathname, hash]);\r\n    const className = useMemo(\r\n      () => cm(sourceClassName, isActive ? activeClassName : ''),\r\n      [sourceClassName, activeClassName, isActive],\r\n    );\r\n\r\n    const handleClick = useEvent((e: SyntheticEvent<MouseEvent, HTMLLinkElement>) => {\r\n      e.preventDefault();\r\n      history.push(to);\r\n      detectIsFunction(onClick) && onClick(e);\r\n    });\r\n\r\n    return (\r\n      <a {...rest} href={to} class={className} onClick={handleClick}>\r\n        {slot}\r\n      </a>\r\n    );\r\n  },\r\n  {\r\n    defaultProps: {\r\n      activeClassName: 'router-link-active',\r\n    },\r\n  },\r\n);\r\n\r\nfunction detectIsActiveLink(pathname: string, hash: string, to: string): boolean {\r\n  const { pathname: to$, hash: hash$ } = parseURL(to);\r\n\r\n  return normalaizePathname(pathname).indexOf(to$) !== -1 && hash === hash$;\r\n}\r\n\r\nexport { RouterLink };\r\n","import { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\n\r\nfunction useEvent<T extends (...args: Array<any>) => any>(fn: T) {\r\n  const scope = useMemo(() => ({ fn }), []);\r\n\r\n  scope.fn = fn;\r\n\r\n  const callback = useCallback((...args: Array<any>) => {\r\n    return scope.fn(...args);\r\n  }, []);\r\n\r\n  return callback as unknown as T;\r\n}\r\n\r\nexport { useEvent };\r\n","import { useRouterHistoryContext, checkContextValue } from '../context';\r\n\r\nfunction useHistory() {\r\n  const value = useRouterHistoryContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.history;\r\n}\r\n\r\nexport { useHistory };\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\n\r\nfunction useLocation() {\r\n  const activeRoute = useActiveRouteContext();\r\n\r\n  checkContextValue(activeRoute);\r\n\r\n  return activeRoute.location;\r\n}\r\n\r\nexport { useLocation };\r\n","import { SLASH, PARAMETER, PROTOCOL_MARK, HASH_MARK, SEARCH_MARK } from '../constants';\r\n\r\nfunction pipe<T>(...fns: Array<Function>): (...args: Array<any>) => T {\r\n  const [fn, ...rest] = fns;\r\n\r\n  return (...args: Array<any>) => {\r\n    return rest.reduce(\r\n      (fn1, fn2) => () => fn2(fn1()),\r\n      () => fn(...args),\r\n    )();\r\n  };\r\n}\r\n\r\nfunction parseURL(url: string) {\r\n  let body = url;\r\n  let protocol = '';\r\n  let host = '';\r\n  let pathname = '';\r\n  let hash = '';\r\n  let search = '';\r\n\r\n  if (body.indexOf(PROTOCOL_MARK) !== -1) {\r\n    [protocol, body] = body.split(PROTOCOL_MARK).filter(Boolean);\r\n  }\r\n\r\n  const splitted = body.split('');\r\n  const idx = splitted.findIndex(x => x === SLASH);\r\n\r\n  if (idx !== -1) {\r\n    host = splitted.filter((_, idx1) => idx1 < idx).join('');\r\n    pathname = splitted.filter((_, idx1) => idx1 >= idx).join('');\r\n  } else {\r\n    host = body;\r\n    pathname = pathname || SLASH;\r\n  }\r\n\r\n  if (pathname.indexOf(SEARCH_MARK) !== -1) {\r\n    [pathname, search] = split(pathname, SEARCH_MARK);\r\n  }\r\n\r\n  if (body.indexOf(HASH_MARK) !== -1) {\r\n    if (search) {\r\n      [search, hash] = split(search, HASH_MARK);\r\n    } else {\r\n      [pathname, hash] = split(pathname, HASH_MARK);\r\n    }\r\n  }\r\n\r\n  return {\r\n    protocol,\r\n    host,\r\n    pathname: lastSlash(pathname),\r\n    search: createSearch(search),\r\n    hash: createHash(hash),\r\n  };\r\n}\r\n\r\nconst createSearch = (value: string) => (value ? `${SEARCH_MARK}${value}` : '');\r\n\r\nconst createHash = (value: string) => (value ? `${HASH_MARK}${value}` : '');\r\n\r\nconst detectIsParam = (value: string) => value && value.startsWith(PARAMETER);\r\n\r\nconst getParamName = (value: string) => (detectIsParam(value) ? value.slice(1, value.length) : null);\r\n\r\nconst split = (value: string, token: string) => value.split(token).filter(Boolean);\r\n\r\nconst splitPath = (path: string) => split(path, SLASH);\r\n\r\nconst firstSlash = (spath: string) => (spath.startsWith(SLASH) ? spath : SLASH + spath);\r\n\r\nconst lastSlash = (spath: string) => (spath.endsWith(SLASH) ? spath : spath + SLASH);\r\n\r\nfunction normalaizePathname(spath: string) {\r\n  const { pathname, search, hash } = parseURL(firstSlash(spath));\r\n  const newSpath = pathname + search + hash;\r\n\r\n  return newSpath;\r\n}\r\n\r\nfunction sort<T>(type: 'asc' | 'desc', list: Array<T>, selector: (x: T) => number) {\r\n  const asc = (a: T, b: T) => selector(a) - selector(b);\r\n  const desc = (a: T, b: T) => selector(b) - selector(a);\r\n  const compare = type === 'asc' ? asc : desc;\r\n\r\n  return list.sort(compare);\r\n}\r\n\r\nconst cm = (...args: Array<string>) => [...args].filter(Boolean).join(' ').trim() || undefined;\r\n\r\nexport { pipe, parseURL, detectIsParam, getParamName, splitPath, normalaizePathname, sort, cm };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".build.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","import { detectIsObject, detectIsNull } from '../helpers';\r\nimport type { Component, ComponentFactory } from '../component';\r\nimport type { RefProps } from '../shared';\r\nimport type { MutableRef } from './types';\r\n\r\nfunction forwardRef<P, R>(component: Component<P, R>) {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return (props: Props) => {\r\n    const { ref, ...rest } = props || {};\r\n\r\n    return component(rest as P, ref) as ComponentFactory<P, R>;\r\n  };\r\n}\r\n\r\nconst detectIsMutableRef = (ref: unknown): ref is MutableRef => {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport { forwardRef, detectIsMutableRef };\r\n","import { createComponent } from '../component';\r\nimport { createContext } from '../context';\r\nimport { useMemo } from '../use-memo';\r\nimport type { DarkElement, SlotProps } from '../shared';\r\n\r\ntype SuspenseProps = {\r\n  fallback: DarkElement;\r\n} & Required<SlotProps>;\r\n\r\ntype SuspenseContextValue = {} & Pick<SuspenseProps, 'fallback'>;\r\n\r\nconst SuspenseContext = createContext<SuspenseContextValue>({ fallback: null });\r\n\r\nconst Suspense = createComponent<SuspenseProps>(({ fallback, slot }) => {\r\n  if (!fallback) {\r\n    throw new Error(`[Dark]: Suspense fallback not found!`);\r\n  }\r\n  const value = useMemo(() => ({ fallback }), []);\r\n\r\n  value.fallback = fallback;\r\n\r\n  return SuspenseContext.Provider({ value, slot });\r\n});\r\n\r\nexport { SuspenseContext, Suspense };\r\n","import { type Component, createComponent, detectIsComponentFactory } from '../component';\r\nimport { detectIsFunction } from '../helpers';\r\nimport { useUpdate } from '../use-update';\r\nimport { useContext } from '../context';\r\nimport { forwardRef } from '../ref';\r\nimport { SuspenseContext } from '../suspense';\r\nimport { detectIsServer, platform } from '../platform';\r\nimport { registerLazy, unregisterLazy, detectHasRegisteredLazy, isHydrateZone } from '../scope';\r\n\r\nconst $$lazy = Symbol('lazy');\r\n\r\nconst componentsMap: Map<Function, Component> = new Map();\r\n\r\nfunction lazy<P, R = unknown>(module: () => Promise<{ default: Component<P> }>, done?: () => void) {\r\n  return forwardRef(\r\n    createComponent<P, R>(\r\n      (props, ref) => {\r\n        if (detectIsServer()) {\r\n          throw new Error('[Dark]: You should render only non-lazy components on the server!');\r\n        }\r\n        const { fallback } = useContext(SuspenseContext);\r\n        const update = useUpdate();\r\n        const component = componentsMap.get(module) || null;\r\n\r\n        if (!component) {\r\n          const id = registerLazy();\r\n\r\n          fetchModule(module).then(component => {\r\n            componentsMap.set(module, component);\r\n\r\n            unregisterLazy(id);\r\n\r\n            if (isHydrateZone.get()) {\r\n              if (!detectHasRegisteredLazy()) {\r\n                platform.restart();\r\n              }\r\n            } else {\r\n              update();\r\n            }\r\n\r\n            detectIsFunction(done) && done();\r\n          });\r\n        }\r\n\r\n        return component ? component(props, ref) : fallback;\r\n      },\r\n      { token: $$lazy },\r\n    ),\r\n  );\r\n}\r\n\r\nconst detectIsLazy = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$lazy;\r\n\r\nfunction fetchModule(module: () => Promise<{ default: Component }>) {\r\n  return new Promise<Component>(resolve => {\r\n    module().then(module => {\r\n      if (!module.default) {\r\n        throw new Error('[Dark]: Lazy loaded component should be exported as default!');\r\n      }\r\n\r\n      resolve(module.default);\r\n    });\r\n  });\r\n}\r\n\r\nexport { lazy, detectIsLazy, fetchModule };\r\n","import {\r\n  type Fiber,\r\n  type DarkElement,\r\n  type ComponentFactory,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n  useMemo,\r\n} from '@dark-engine/core';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nconst $$portal = Symbol('portal');\r\n\r\nfunction createPortal(slot: DarkElement, container: TagNativeElement) {\r\n  if (!(container instanceof Element)) {\r\n    throw new Error(`[Dark]: createPortal receives only Element as container!`);\r\n  }\r\n\r\n  return Portal({ [$$portal]: container, slot });\r\n}\r\n\r\ntype PortalProps = {\r\n  [$$portal]: TagNativeElement;\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Portal = createComponent<PortalProps>(\r\n  ({ slot, ...rest }) => {\r\n    useMemo(() => (rest[$$portal].innerHTML = ''), []);\r\n\r\n    return slot;\r\n  },\r\n  { token: $$portal },\r\n);\r\n\r\nconst detectIsPortal = (factory: unknown): factory is ComponentFactory =>\r\n  detectIsComponentFactory(factory) && factory.token === $$portal;\r\n\r\nconst getPortalContainer = (factory: unknown): TagNativeElement | null =>\r\n  detectIsPortal(factory) ? factory.props[$$portal] : null;\r\n\r\nfunction unmountPortal(fiber: Fiber<TagNativeElement>) {\r\n  const container = getPortalContainer(fiber.instance);\r\n\r\n  if (container) {\r\n    container.innerHTML = '';\r\n  }\r\n}\r\n\r\nexport { createPortal, detectIsPortal, getPortalContainer, unmountPortal };\r\n","import { detectIsFunction, eventsStore } from '@dark-engine/core';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\ntype BrowserEventConstructor = (type: string, event: Event) => void;\r\n\r\nclass SyntheticEvent<E extends Event, T = TagNativeElement> {\r\n  public type = '';\r\n  public sourceEvent: E = null;\r\n  public target: T = null;\r\n  private propagation = true;\r\n\r\n  constructor(options: Pick<SyntheticEvent<E, T>, 'sourceEvent' | 'target'>) {\r\n    this.type = options.sourceEvent.type;\r\n    this.sourceEvent = options.sourceEvent;\r\n    this.target = options.target;\r\n  }\r\n\r\n  public stopPropagation() {\r\n    this.propagation = false;\r\n    this.sourceEvent.stopPropagation();\r\n  }\r\n\r\n  public preventDefault() {\r\n    this.sourceEvent.preventDefault();\r\n  }\r\n\r\n  public getPropagation() {\r\n    return this.propagation;\r\n  }\r\n}\r\n\r\ntype DelegateEventOptions = {\r\n  target: Element;\r\n  eventName: string;\r\n  handler: (e: Event) => void;\r\n};\r\n\r\nfunction delegateEvent(options: DelegateEventOptions) {\r\n  const { target, eventName, handler } = options;\r\n  const eventsMap = eventsStore.get();\r\n  const handlerMap = eventsMap.get(eventName);\r\n\r\n  if (!handlerMap) {\r\n    const rootHandler = (event: Event) => {\r\n      const fireEvent = eventsMap.get(eventName).get(event.target);\r\n      const target = event.target as TagNativeElement;\r\n      let syntheticEvent: SyntheticEvent<Event> = null;\r\n\r\n      if (detectIsFunction(fireEvent)) {\r\n        syntheticEvent = new SyntheticEvent({\r\n          sourceEvent: event,\r\n          target,\r\n        });\r\n        fireEvent(syntheticEvent);\r\n      }\r\n\r\n      if (syntheticEvent ? syntheticEvent.getPropagation() : target.parentElement) {\r\n        target.parentElement.dispatchEvent(new (event.constructor as BrowserEventConstructor)(event.type, event));\r\n      }\r\n    };\r\n\r\n    eventsMap.set(eventName, new WeakMap([[target, handler]]));\r\n    document.addEventListener(eventName, rootHandler, true);\r\n    eventsStore.addUnsubscriber(() => document.removeEventListener(eventName, rootHandler, true));\r\n  } else {\r\n    handlerMap.set(target, handler);\r\n  }\r\n}\r\n\r\nconst detectIsEvent = (attrName: string) => attrName.startsWith('on');\r\n\r\nconst getEventName = (attrName: string) => attrName.slice(2, attrName.length).toLowerCase();\r\n\r\nexport { SyntheticEvent, delegateEvent, detectIsEvent, getEventName };\r\n","import {\r\n  type Fiber,\r\n  type VirtualNode,\r\n  type TagVirtualNode,\r\n  type TextVirtualNode,\r\n  type CommentVirtualNode,\r\n  type Ref,\r\n  ATTR_KEY,\r\n  ATTR_REF,\r\n  ATTR_FLAG,\r\n  EffectTag,\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsBoolean,\r\n  keyBy,\r\n  NodeType,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsMutableRef,\r\n  walkFiber,\r\n  isHydrateZone,\r\n} from '@dark-engine/core';\r\nimport { detectIsPortal, getPortalContainer } from '../portal';\r\nimport { delegateEvent, detectIsEvent, getEventName } from '../events';\r\nimport { SVG_TAG_NAMES, VOID_TAG_NAMES } from '../constants';\r\nimport type {\r\n  NativeElement,\r\n  TagNativeElement,\r\n  TextNativeElement,\r\n  CommentNativeElement,\r\n  AttributeValue,\r\n} from '../native-element';\r\n\r\ntype DOMFragment = {\r\n  fragment: DocumentFragment;\r\n  callback: () => void;\r\n};\r\n\r\nconst attrBlackListMap = {\r\n  [ATTR_KEY]: true,\r\n  [ATTR_REF]: true,\r\n  [ATTR_FLAG]: true,\r\n};\r\nlet fragmentsMap: Map<NativeElement, DOMFragment> = new Map();\r\nlet moves: Array<() => void> = [];\r\nlet trackUpdate: (nativeElement: NativeElement) => void = null;\r\nconst svgTagNamesMap = keyBy(SVG_TAG_NAMES.split(','), x => x);\r\nconst voidTagNamesMap = keyBy(VOID_TAG_NAMES.split(','), x => x);\r\n\r\nconst createNativeElementMap = {\r\n  [NodeType.TAG]: (vNode: VirtualNode): TagNativeElement => {\r\n    const tagNode = vNode as TagVirtualNode;\r\n    const node = detectIsSvgElement(tagNode.name)\r\n      ? document.createElementNS('http://www.w3.org/2000/svg', tagNode.name)\r\n      : document.createElement(tagNode.name);\r\n\r\n    return node;\r\n  },\r\n  [NodeType.TEXT]: (vNode: VirtualNode): TextNativeElement => {\r\n    const textNode = vNode as TextVirtualNode;\r\n    const node = document.createTextNode(textNode.value);\r\n\r\n    return node;\r\n  },\r\n  [NodeType.COMMENT]: (vNode: VirtualNode): CommentNativeElement => {\r\n    const commentNode = vNode as CommentVirtualNode;\r\n    const node = document.createComment(commentNode.value);\r\n\r\n    return node;\r\n  },\r\n};\r\n\r\nfunction createNativeElement(vNode: VirtualNode): NativeElement {\r\n  return createNativeElementMap[vNode.type](vNode);\r\n}\r\n\r\nfunction detectIsSvgElement(tagName: string) {\r\n  return Boolean(svgTagNamesMap[tagName]);\r\n}\r\n\r\nfunction detectIsVoidElement(tagName: string) {\r\n  return Boolean(voidTagNamesMap[tagName]);\r\n}\r\n\r\nfunction applyRef(ref: Ref<NativeElement>, element: NativeElement) {\r\n  if (detectIsFunction(ref)) {\r\n    ref(element);\r\n  } else if (detectIsMutableRef(ref)) {\r\n    ref.current = element;\r\n  }\r\n}\r\n\r\nfunction addAttributes(element: NativeElement, vNode: VirtualNode) {\r\n  if (!detectIsTagVirtualNode(vNode)) return;\r\n  const attrNames = Object.keys(vNode.attrs);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const attrValue = vNode.attrs[attrName];\r\n\r\n    if (attrName === ATTR_REF) {\r\n      applyRef(attrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (detectIsFunction(attrValue)) {\r\n      if (detectIsEvent(attrName)) {\r\n        delegateEvent({\r\n          target: tagElement,\r\n          handler: attrValue,\r\n          eventName: getEventName(attrName),\r\n        });\r\n      }\r\n    } else if (!detectIsUndefined(attrValue) && !attrBlackListMap[attrName]) {\r\n      const stop = patchProperties({\r\n        tagName: vNode.name,\r\n        element: tagElement,\r\n        attrValue,\r\n        attrName,\r\n      });\r\n\r\n      !stop && tagElement.setAttribute(attrName, attrValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateAttributes(element: NativeElement, vNode: TagVirtualNode, nextVNode: TagVirtualNode) {\r\n  const attrNames = new Set([...Object.keys(vNode.attrs), ...Object.keys(nextVNode.attrs)]);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const prevAttrValue = vNode.attrs[attrName];\r\n    const nextAttrValue = nextVNode.attrs[attrName];\r\n\r\n    if (attrName === ATTR_REF) {\r\n      applyRef(prevAttrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (!detectIsUndefined(nextAttrValue)) {\r\n      if (detectIsFunction(prevAttrValue)) {\r\n        if (detectIsEvent(attrName) && prevAttrValue !== nextAttrValue) {\r\n          delegateEvent({\r\n            target: tagElement,\r\n            handler: nextAttrValue,\r\n            eventName: getEventName(attrName),\r\n          });\r\n        }\r\n      } else if (!attrBlackListMap[attrName] && prevAttrValue !== nextAttrValue) {\r\n        const stop = patchProperties({\r\n          tagName: nextVNode.name,\r\n          element: tagElement,\r\n          attrValue: nextAttrValue,\r\n          attrName,\r\n        });\r\n\r\n        !stop && tagElement.setAttribute(attrName, nextAttrValue);\r\n      }\r\n    } else {\r\n      tagElement.removeAttribute(attrName);\r\n    }\r\n  }\r\n}\r\n\r\ntype PatchPropertiesOptions = {\r\n  tagName: string;\r\n  element: TagNativeElement;\r\n  attrName: string;\r\n  attrValue: AttributeValue;\r\n};\r\n\r\nfunction patchProperties(options: PatchPropertiesOptions): boolean {\r\n  const { tagName, element, attrName, attrValue } = options;\r\n  const fn = patchPropertiesSpecialCasesMap[tagName];\r\n  let stop = fn ? fn(element, attrName, attrValue) : false;\r\n\r\n  if (canSetProperty(Object.getPrototypeOf(element), attrName)) {\r\n    element[attrName] = attrValue;\r\n  }\r\n\r\n  if (!stop && detectIsBoolean(attrValue)) {\r\n    stop = !attrName.includes('-');\r\n  }\r\n\r\n  return stop;\r\n}\r\n\r\nfunction canSetProperty(prototype: TagNativeElement, key: string) {\r\n  return prototype.hasOwnProperty(key) && Boolean(Object.getOwnPropertyDescriptor(prototype, key)?.set);\r\n}\r\n\r\nconst patchPropertiesSpecialCasesMap: Record<\r\n  string,\r\n  (element: NativeElement, attrName: string, attrValue: AttributeValue) => boolean\r\n> = {\r\n  input: (element: HTMLInputElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value' && detectIsBoolean(attrValue)) {\r\n      element.checked = attrValue;\r\n    } else if (attrName === 'autoFocus') {\r\n      element.autofocus = Boolean(attrValue);\r\n    }\r\n\r\n    return false;\r\n  },\r\n  textarea: (element: HTMLTextAreaElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value') {\r\n      element.innerHTML = String(attrValue);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  },\r\n};\r\n\r\nfunction getParentFiberWithNativeElement(fiber: Fiber<NativeElement>): Fiber<TagNativeElement> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    nextFiber = nextFiber.parent;\r\n\r\n    if (detectIsPortal(nextFiber.instance)) {\r\n      nextFiber.nativeElement = getPortalContainer(nextFiber.instance);\r\n    }\r\n\r\n    if (nextFiber.nativeElement) return nextFiber as Fiber<TagNativeElement>;\r\n  }\r\n\r\n  return nextFiber as Fiber<TagNativeElement>;\r\n}\r\n\r\nfunction append(fiber: Fiber<NativeElement>, parentElement: TagNativeElement) {\r\n  const { fragment } =\r\n    fragmentsMap.get(parentElement) ||\r\n    ({\r\n      fragment: document.createDocumentFragment(),\r\n      callback: () => {},\r\n    } as DOMFragment);\r\n\r\n  fragmentsMap.set(parentElement, {\r\n    fragment,\r\n    callback: () => {\r\n      parentElement.appendChild(fragment);\r\n    },\r\n  });\r\n  fragment.appendChild(fiber.nativeElement);\r\n}\r\n\r\nfunction insert(fiber: Fiber<NativeElement>, parentElement: TagNativeElement) {\r\n  parentElement.insertBefore(fiber.nativeElement, parentElement.childNodes[fiber.elementIdx]);\r\n}\r\n\r\nfunction commitCreation(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getParentFiberWithNativeElement(fiber);\r\n  const parentElement = parentFiber.nativeElement;\r\n  const childNodes = parentElement.childNodes;\r\n\r\n  if (isHydrateZone.get()) {\r\n    const nativeElement = childNodes[fiber.elementIdx] as NativeElement;\r\n\r\n    if (\r\n      detectIsTextVirtualNode(fiber.instance) &&\r\n      nativeElement instanceof Text &&\r\n      fiber.instance.value.length !== nativeElement.length\r\n    ) {\r\n      nativeElement.splitText(fiber.instance.value.length);\r\n    }\r\n\r\n    fiber.nativeElement = nativeElement;\r\n  } else {\r\n    if (childNodes.length === 0 || fiber.elementIdx > childNodes.length - 1) {\r\n      const vNode = parentFiber.instance as TagVirtualNode;\r\n\r\n      !detectIsVoidElement(vNode.name) && append(fiber, parentElement);\r\n    } else {\r\n      insert(fiber, parentElement);\r\n    }\r\n  }\r\n\r\n  addAttributes(fiber.nativeElement, fiber.instance as VirtualNode);\r\n}\r\n\r\nfunction commitUpdate(fiber: Fiber<NativeElement>) {\r\n  const element = fiber.nativeElement;\r\n  const prevInstance = fiber.alternate.instance as VirtualNode;\r\n  const nextInstance = fiber.instance as VirtualNode;\r\n\r\n  if (\r\n    detectIsTextVirtualNode(prevInstance) &&\r\n    detectIsTextVirtualNode(nextInstance) &&\r\n    prevInstance.value !== nextInstance.value\r\n  ) {\r\n    return (element.textContent = nextInstance.value);\r\n  }\r\n\r\n  if (detectIsTagVirtualNode(prevInstance) && detectIsTagVirtualNode(nextInstance)) {\r\n    return updateAttributes(element, prevInstance, nextInstance);\r\n  }\r\n}\r\n\r\nfunction commitDeletion(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getParentFiberWithNativeElement(fiber);\r\n\r\n  walkFiber<NativeElement>(fiber, ({ nextFiber, isReturn, resetIsDeepWalking, stop }) => {\r\n    if (nextFiber === fiber.nextSibling || nextFiber === fiber.parent) {\r\n      return stop();\r\n    }\r\n\r\n    if (!isReturn && nextFiber.nativeElement) {\r\n      !detectIsPortal(nextFiber.instance) && parentFiber.nativeElement.removeChild(nextFiber.nativeElement);\r\n\r\n      return resetIsDeepWalking();\r\n    }\r\n  });\r\n}\r\n\r\nfunction move(fiber: Fiber<NativeElement>) {\r\n  const sourceNodes = collectElements(fiber);\r\n  const sourceNode = sourceNodes[0];\r\n  const parentElement = sourceNode.parentElement;\r\n  const sourceFragment = new DocumentFragment();\r\n  const elementIdx = fiber.elementIdx;\r\n  let idx = 0;\r\n  const move = () => {\r\n    for (let i = 1; i < sourceNodes.length; i++) {\r\n      parentElement.removeChild(parentElement.childNodes[elementIdx + 1]);\r\n    }\r\n\r\n    parentElement.replaceChild(sourceFragment, parentElement.childNodes[elementIdx]);\r\n  };\r\n\r\n  for (const node of sourceNodes) {\r\n    parentElement.insertBefore(document.createComment(`${elementIdx}:${idx}`), node);\r\n    sourceFragment.appendChild(node);\r\n    idx++;\r\n  }\r\n\r\n  moves.push(move);\r\n}\r\n\r\nfunction collectElements(fiber: Fiber<NativeElement>) {\r\n  const store: Array<NativeElement> = [];\r\n\r\n  walkFiber<NativeElement>(fiber, ({ nextFiber, isReturn, resetIsDeepWalking, stop }) => {\r\n    if (nextFiber === fiber.nextSibling || nextFiber === fiber.parent) {\r\n      return stop();\r\n    }\r\n\r\n    if (!isReturn && nextFiber.nativeElement) {\r\n      !detectIsPortal(nextFiber.instance) && store.push(nextFiber.nativeElement);\r\n\r\n      return resetIsDeepWalking();\r\n    }\r\n  });\r\n\r\n  return store;\r\n}\r\n\r\nconst applyCommitMap: Record<EffectTag, (fiber: Fiber<NativeElement>) => void> = {\r\n  [EffectTag.CREATE]: (fiber: Fiber<NativeElement>) => {\r\n    if (fiber.nativeElement === null) return;\r\n    trackUpdate && trackUpdate(fiber.nativeElement);\r\n    commitCreation(fiber);\r\n  },\r\n  [EffectTag.UPDATE]: (fiber: Fiber<NativeElement>) => {\r\n    if (fiber.move) {\r\n      move(fiber);\r\n      fiber.move = false;\r\n    }\r\n\r\n    if (\r\n      fiber.nativeElement === null ||\r\n      !detectIsVirtualNode(fiber.alternate.instance) ||\r\n      !detectIsVirtualNode(fiber.instance)\r\n    ) {\r\n      return;\r\n    }\r\n    trackUpdate && trackUpdate(fiber.nativeElement);\r\n    commitUpdate(fiber);\r\n  },\r\n  [EffectTag.DELETE]: (fiber: Fiber<NativeElement>) => commitDeletion(fiber),\r\n  [EffectTag.SKIP]: () => {},\r\n};\r\n\r\nfunction applyCommit(fiber: Fiber<NativeElement>) {\r\n  applyCommitMap[fiber.effectTag](fiber);\r\n}\r\n\r\nfunction finishCommitWork() {\r\n  for (const { callback } of fragmentsMap.values()) {\r\n    callback();\r\n  }\r\n\r\n  for (const move of moves) {\r\n    move();\r\n  }\r\n\r\n  fragmentsMap = new Map();\r\n  moves = [];\r\n  isHydrateZone.set(false);\r\n}\r\n\r\nfunction setTrackUpdate(fn: typeof trackUpdate) {\r\n  trackUpdate = fn;\r\n}\r\n\r\nexport { createNativeElement, applyCommit, finishCommitWork, setTrackUpdate };\r\n","export const SVG_TAG_NAMES =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,defs,desc,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,image,line,linearGradient,marker,mask,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,stop,switch,symbol,text,textPath,tspan,use,view';\r\nexport const VOID_TAG_NAMES = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n","import { type ScheduleCallbackOptions, getTime, workLoop, wipRootStore, TaskPriority } from '@dark-engine/core';\r\n\r\ntype Callback = () => boolean;\r\n\r\ntype QueueByPriority = {\r\n  animations: Array<Task>;\r\n  hight: Array<Task>;\r\n  normal: Array<Task>;\r\n  low1: Array<Task>;\r\n  low2: Array<Task>;\r\n};\r\n\r\nconst queueByPriority: QueueByPriority = {\r\n  animations: [],\r\n  hight: [],\r\n  normal: [],\r\n  low1: [],\r\n  low2: [],\r\n};\r\nconst YEILD_INTERVAL = 4;\r\nconst MAX_LOW_PRIORITY_TASKS_LIMIT = 100000;\r\nlet scheduledCallback: Callback = null;\r\nlet deadline = 0;\r\nlet isMessageLoopRunning = false;\r\nlet currentTask: Task = null;\r\n\r\nclass Task {\r\n  public static nextTaskId = 0;\r\n  public id: number;\r\n  public time: number;\r\n  public timeoutMs: number;\r\n  public priority: TaskPriority;\r\n  public forceSync: boolean;\r\n  public callback: () => void;\r\n\r\n  constructor(options: Omit<Task, 'id'>) {\r\n    this.id = ++Task.nextTaskId;\r\n    this.time = options.time;\r\n    this.timeoutMs = options.timeoutMs;\r\n    this.priority = options.priority;\r\n    this.forceSync = options.forceSync;\r\n    this.callback = options.callback;\r\n  }\r\n}\r\n\r\nconst shouldYeildToHost = () => getTime() >= deadline;\r\n\r\nfunction scheduleCallback(callback: () => void, options?: ScheduleCallbackOptions) {\r\n  const { priority = TaskPriority.NORMAL, timeoutMs = 0, forceSync = false } = options || {};\r\n  const task = new Task({ time: getTime(), timeoutMs, priority, forceSync, callback });\r\n  const map: Record<TaskPriority, () => void> = {\r\n    [TaskPriority.ANIMATION]: () => queueByPriority.animations.push(task),\r\n    [TaskPriority.HIGH]: () => queueByPriority.hight.push(task),\r\n    [TaskPriority.NORMAL]: () => queueByPriority.normal.push(task),\r\n    [TaskPriority.LOW]: () => (task.timeoutMs > 0 ? queueByPriority.low2.push(task) : queueByPriority.low1.push(task)),\r\n  };\r\n\r\n  map[task.priority]();\r\n  executeTasks();\r\n}\r\n\r\nfunction pick(queue: Array<Task>) {\r\n  if (!queue.length) return false;\r\n  currentTask = queue.shift();\r\n  const isAnimation = currentTask.priority === TaskPriority.ANIMATION;\r\n\r\n  currentTask.callback();\r\n\r\n  if (currentTask.forceSync || isAnimation) {\r\n    requestCallbackSync(workLoop);\r\n  } else {\r\n    requestCallback(workLoop);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction executeTasks() {\r\n  const isBusy = Boolean(wipRootStore.get());\r\n\r\n  if (!isBusy) {\r\n    checkOverdueTasks() ||\r\n      gc() ||\r\n      pick(queueByPriority.animations) ||\r\n      pick(queueByPriority.hight) ||\r\n      pick(queueByPriority.normal) ||\r\n      requestIdleCallback(() => pick(queueByPriority.low1) || pick(queueByPriority.low2));\r\n  }\r\n}\r\n\r\nfunction gc() {\r\n  if (queueByPriority.low1.length > MAX_LOW_PRIORITY_TASKS_LIMIT) {\r\n    queueByPriority.low1 = [];\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkOverdueTasks() {\r\n  const [task] = queueByPriority.low2;\r\n\r\n  if (task && getTime() - task.time > task.timeoutMs) {\r\n    pick(queueByPriority.low2);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction performWorkUntilDeadline() {\r\n  if (scheduledCallback) {\r\n    deadline = getTime() + YEILD_INTERVAL;\r\n\r\n    try {\r\n      const hasMoreWork = scheduledCallback();\r\n\r\n      if (!hasMoreWork) {\r\n        currentTask = null;\r\n        isMessageLoopRunning = false;\r\n        scheduledCallback = null;\r\n        executeTasks();\r\n      } else {\r\n        port.postMessage(null);\r\n      }\r\n    } catch (error) {\r\n      port.postMessage(null);\r\n      throw error;\r\n    }\r\n  } else {\r\n    isMessageLoopRunning = false;\r\n  }\r\n}\r\n\r\nfunction requestCallback(callback: Callback) {\r\n  if (process.env.NODE_ENV === 'test') {\r\n    return requestCallbackSync(callback);\r\n  }\r\n\r\n  scheduledCallback = callback;\r\n\r\n  if (!isMessageLoopRunning) {\r\n    isMessageLoopRunning = true;\r\n    port.postMessage(null);\r\n  }\r\n}\r\n\r\nfunction requestCallbackSync(callback: Callback) {\r\n  while (callback()) {\r\n    //\r\n  }\r\n  executeTasks();\r\n  currentTask = null;\r\n}\r\n\r\nlet channel: MessageChannel = null;\r\nlet port: MessagePort = null;\r\n\r\nfunction setup() {\r\n  if (process.env.NODE_ENV === 'test') {\r\n    return;\r\n  }\r\n\r\n  channel = new MessageChannel();\r\n  port = channel.port2;\r\n\r\n  channel.port1.onmessage = performWorkUntilDeadline;\r\n}\r\n\r\nsetup();\r\n\r\nexport { shouldYeildToHost, scheduleCallback };\r\n","import {\r\n  type DarkElement,\r\n  ROOT,\r\n  Fiber,\r\n  EffectTag,\r\n  platform,\r\n  flatten,\r\n  detectIsUndefined,\r\n  TagVirtualNode,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  fiberMountStore,\r\n  TaskPriority,\r\n  createReplacer,\r\n  isInsertionEffectsZone,\r\n  isLayoutEffectsZone,\r\n  isHydrateZone,\r\n} from '@dark-engine/core';\r\nimport type { TagNativeElement } from '../native-element';\r\nimport { createNativeElement, applyCommit, finishCommitWork } from '../dom';\r\nimport { detectIsPortal, unmountPortal } from '../portal';\r\nimport { scheduleCallback, shouldYeildToHost } from '../scheduler';\r\n\r\nlet isInjected = false;\r\nconst roots = new Map<Element, number>();\r\n\r\nfunction inject() {\r\n  platform.createNativeElement = createNativeElement as typeof platform.createNativeElement;\r\n  platform.requestAnimationFrame = requestAnimationFrame.bind(this);\r\n  platform.cancelAnimationFrame = cancelAnimationFrame.bind(this);\r\n  platform.scheduleCallback = scheduleCallback;\r\n  platform.shouldYeildToHost = shouldYeildToHost;\r\n  platform.applyCommit = applyCommit;\r\n  platform.finishCommitWork = finishCommitWork;\r\n  platform.detectIsDynamic = () => true;\r\n  platform.detectIsPortal = detectIsPortal;\r\n  platform.unmountPortal = unmountPortal;\r\n  platform.restart = () => {};\r\n  isInjected = true;\r\n}\r\n\r\nfunction render(element: DarkElement, container: TagNativeElement, hydrate = false) {\r\n  !isInjected && inject();\r\n\r\n  if (!(container instanceof Element)) {\r\n    throw new Error(`[Dark]: render receives only Element as container!`);\r\n  }\r\n\r\n  const isMounted = !detectIsUndefined(roots.get(container));\r\n  let rootId: number = null;\r\n\r\n  if (!isMounted) {\r\n    rootId = roots.size;\r\n\r\n    roots.set(container, rootId);\r\n\r\n    if (!hydrate) {\r\n      container.innerHTML = '';\r\n    }\r\n  } else {\r\n    rootId = roots.get(container);\r\n  }\r\n\r\n  // insertion effect can't schedule renders\r\n  if (isInsertionEffectsZone.get(rootId)) return;\r\n\r\n  const callback = () => {\r\n    rootStore.set(rootId); // important order!\r\n    const currentRoot = currentRootStore.get();\r\n    const isUpdate = Boolean(currentRoot);\r\n    const fiber = new Fiber().mutate({\r\n      nativeElement: container,\r\n      instance: new TagVirtualNode(ROOT, {}, flatten([element || createReplacer()]) as TagVirtualNode['children']),\r\n      alternate: currentRoot,\r\n      effectTag: isUpdate ? EffectTag.UPDATE : EffectTag.CREATE,\r\n    });\r\n\r\n    fiberMountStore.reset();\r\n    wipRootStore.set(fiber);\r\n    isHydrateZone.set(hydrate);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  platform.scheduleCallback(callback, {\r\n    priority: TaskPriority.NORMAL,\r\n    forceSync: hydrate || isLayoutEffectsZone.get(),\r\n  });\r\n}\r\n\r\nexport { render, roots };\r\n","import { type DarkElement, unmountRoot } from '@dark-engine/core';\r\nimport { render, roots } from '../render';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction createRoot(container: TagNativeElement) {\r\n  return {\r\n    render: (element: DarkElement) => render(element, container),\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nfunction unmount(container: TagNativeElement) {\r\n  const rootId = roots.get(container);\r\n\r\n  unmountRoot(rootId, () => {\r\n    roots.delete(container);\r\n    container.innerHTML = '';\r\n  });\r\n}\r\n\r\nexport { createRoot, unmount };\r\n","import { type DarkElement, platform } from '@dark-engine/core';\r\nimport { render } from '../render';\r\nimport { unmount } from '../create-root';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction hydrateRoot(container: TagNativeElement, element: DarkElement) {\r\n  render(element, container, true); //important order\r\n  platform.restart = () => hydrateRoot(container, element);\r\n\r\n  return {\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nexport { hydrateRoot };\r\n","import { detectIsFalsy, type SubscriberWithValue } from '@dark-engine/core';\r\nimport { normalaizePathname, parseURL } from '../utils';\r\n\r\nconst browserHistory = globalThis.history;\r\nclass RouterHistory {\r\n  private stack: Array<string> = [];\r\n  private cursor = -1;\r\n  private subscribers: Set<SubscriberWithValue<string>> = new Set();\r\n  private fromHistory = false;\r\n  public dispose: () => void = null;\r\n\r\n  constructor(url: string) {\r\n    if (detectIsFalsy(url)) {\r\n      throw new Error('[web-router]: RouterHistory must have initial url!');\r\n    }\r\n\r\n    const { pathname, search } = parseURL(url);\r\n    const spathname = pathname + search;\r\n\r\n    this.stack.push(spathname);\r\n    this.cursor = this.stack.length - 1;\r\n\r\n    if (browserHistory) {\r\n      const state = this.getState();\r\n\r\n      if (!state) {\r\n        browserHistory.replaceState(this.createStateBox(), '');\r\n      } else {\r\n        this.stack = state.stack;\r\n        this.cursor = state.cursor;\r\n      }\r\n\r\n      const handleEvent = () => {\r\n        const state = this.getState();\r\n\r\n        if (state) {\r\n          this.stack = state.stack;\r\n          this.cursor = state.cursor;\r\n        }\r\n\r\n        if (!this.fromHistory) {\r\n          this.mapSubscribers();\r\n        }\r\n\r\n        this.fromHistory = false;\r\n      };\r\n\r\n      window.addEventListener('popstate', handleEvent);\r\n\r\n      this.dispose = () => {\r\n        window.removeEventListener('popstate', handleEvent);\r\n        this.subscribers.clear();\r\n        this.stack = [];\r\n        this.cursor = -1;\r\n      };\r\n    }\r\n  }\r\n\r\n  private mapSubscribers() {\r\n    for (const subscriber of this.subscribers) {\r\n      subscriber(this.getValue());\r\n    }\r\n  }\r\n\r\n  private getValue = () => {\r\n    return normalaizePathname(this.stack[this.cursor]);\r\n  };\r\n\r\n  private getState(): State {\r\n    return (browserHistory.state && browserHistory.state[STATE_KEY]) || null;\r\n  }\r\n\r\n  private createStateBox(): StateBox {\r\n    const state = browserHistory.state || {};\r\n\r\n    return { ...state, [STATE_KEY]: { cursor: this.cursor, stack: this.stack } };\r\n  }\r\n\r\n  private syncHistory(action: HistoryAction, spathname: string) {\r\n    if (!browserHistory) return;\r\n    const stateBox = this.createStateBox();\r\n    const spathname$ = normalaizePathname(spathname);\r\n\r\n    switch (action) {\r\n      case HistoryAction.PUSH:\r\n        return browserHistory.pushState(stateBox, '', spathname$);\r\n      case HistoryAction.REPLACE:\r\n        return browserHistory.replaceState(stateBox, '', spathname$);\r\n    }\r\n  }\r\n\r\n  public subscribe = (subscriber: SubscriberWithValue<string>) => {\r\n    this.subscribers.add(subscriber);\r\n\r\n    return () => this.subscribers.delete(subscriber);\r\n  };\r\n\r\n  public push(spathname: string) {\r\n    this.stack.splice(this.cursor + 1, this.stack.length, spathname);\r\n    this.cursor = this.stack.length - 1;\r\n    this.syncHistory(HistoryAction.PUSH, spathname);\r\n    this.mapSubscribers();\r\n  }\r\n\r\n  public replace(spathname: string) {\r\n    this.stack[this.stack.length - 1] = spathname;\r\n    this.syncHistory(HistoryAction.REPLACE, spathname);\r\n    this.mapSubscribers();\r\n  }\r\n\r\n  public forward() {\r\n    this.go(1);\r\n  }\r\n\r\n  public back() {\r\n    this.go(-1);\r\n  }\r\n\r\n  public go(delta: number) {\r\n    this.fromHistory = true;\r\n    this.cursor += delta;\r\n\r\n    if (this.cursor > this.stack.length - 1) {\r\n      this.cursor = this.stack.length - 1;\r\n    } else if (this.cursor < 0) {\r\n      this.cursor = 0;\r\n    }\r\n\r\n    browserHistory?.go(delta);\r\n    this.mapSubscribers();\r\n  }\r\n}\r\n\r\nenum HistoryAction {\r\n  PUSH = 'PUSH',\r\n  REPLACE = 'REPLACE',\r\n}\r\n\r\ntype StateBox = {\r\n  [STATE_KEY]: State;\r\n};\r\n\r\ntype State = {\r\n  cursor: number;\r\n  stack: Array<string>;\r\n};\r\n\r\nconst STATE_KEY = 'web-router';\r\n\r\nconst createRouterHistory = (url: string) => new RouterHistory(url);\r\n\r\nexport { RouterHistory, createRouterHistory };\r\n","import { detectIsFalsy } from '@dark-engine/core';\r\nimport { parseURL } from '../utils';\r\n\r\nclass RouterLocation {\r\n  public url: string;\r\n  public protocol: string;\r\n  public host: string;\r\n  public pathname: string;\r\n  public hash: string;\r\n  public search: string;\r\n  public key: string;\r\n\r\n  constructor(url: string) {\r\n    if (detectIsFalsy(url)) {\r\n      throw new Error('[web-router]: RouterLocation must have initial url!');\r\n    }\r\n\r\n    const { protocol, host, pathname, hash, search } = parseURL(url);\r\n\r\n    this.url = url;\r\n    this.protocol = protocol;\r\n    this.host = host;\r\n    this.pathname = pathname;\r\n    this.hash = hash;\r\n    this.search = search;\r\n    this.key = createKey(pathname);\r\n    Object.freeze(this);\r\n  }\r\n}\r\n\r\nfunction createKey(pathname: string): string {\r\n  return pathname\r\n    .split('')\r\n    .map(x => x.charCodeAt(0))\r\n    .reduce((acc, x) => ((acc += x), acc), 200000)\r\n    .toString(32);\r\n}\r\n\r\nconst createRouterLocation = (url: string) => new RouterLocation(url);\r\n\r\nexport { RouterLocation, createRouterLocation };\r\n","import {\r\n  type DarkElement,\r\n  type MutableRef,\r\n  h,\r\n  createComponent,\r\n  useMemo,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useState,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n} from '@dark-engine/core';\r\n\r\nimport { SLASH, PROTOCOL_MARK } from '../constants';\r\nimport { normalaizePathname } from '../utils';\r\nimport { createRouterHistory } from '../history';\r\nimport { type RouterLocation, createRouterLocation } from '../location';\r\nimport { type Routes, createRoutes, resolveRoute, createPathname } from '../create-routes';\r\nimport {\r\n  type RouterHistoryContextValue,\r\n  type ActiveRouteContextValue,\r\n  RouterHistoryContext,\r\n  ActiveRouteContext,\r\n  useActiveRouteContext,\r\n} from '../context';\r\n\r\nexport type RouterProps = {\r\n  url?: string; // for server-side rendering\r\n  baseURL?: string;\r\n  routes: Routes;\r\n  slot: (slot: DarkElement) => DarkElement;\r\n};\r\n\r\nexport type RouterRef = {\r\n  navigateTo: (pathname: string) => void;\r\n  location: RouterLocation;\r\n};\r\n\r\nconst Router = forwardRef<RouterProps, RouterRef>(\r\n  createComponent(({ url, baseURL = SLASH, routes: sourceRoutes, slot }, ref) => {\r\n    if (useActiveRouteContext()) {\r\n      throw new Error('[web-router]: Parent active route context detected!');\r\n    }\r\n    const sourceURL = url || window.location.href;\r\n    const [location, setLocation] = useState(() => createRouterLocation(sourceURL));\r\n    const history = useMemo(() => createRouterHistory(sourceURL), []);\r\n    const routes = useMemo(() => createRoutes(sourceRoutes, normalaizePathname(baseURL)), []);\r\n    const { protocol, host, pathname, search, hash } = location;\r\n    const { activeRoute, slot: slot$, params } = resolveRoute(pathname, routes);\r\n    const scope = useMemo(() => ({ location }), []);\r\n    const historyContext = useMemo<RouterHistoryContextValue>(() => ({ history }), []);\r\n    const routerContext = useMemo<ActiveRouteContextValue>(\r\n      () => ({ location, activeRoute, params }),\r\n      [pathname, search, hash],\r\n    );\r\n\r\n    scope.location = location;\r\n\r\n    useLayoutEffect(() => {\r\n      if (sourceURL !== scope.location.url) {\r\n        setLocation(createRouterLocation(sourceURL));\r\n      }\r\n    }, [sourceURL]);\r\n\r\n    useLayoutEffect(() => {\r\n      const unsubscribe = history.subscribe(spathname => {\r\n        const url = `${protocol}${PROTOCOL_MARK}${host}${spathname}`;\r\n\r\n        setLocation(createRouterLocation(url));\r\n      });\r\n\r\n      return () => {\r\n        unsubscribe();\r\n        history.dispose();\r\n      };\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n      if (!activeRoute) return;\r\n      const spathname = pathname + search + hash;\r\n      const newSpathname = createPathname(pathname, activeRoute.getPath()) + search + hash;\r\n\r\n      if (spathname !== newSpathname) {\r\n        history.replace(newSpathname);\r\n      }\r\n    }, [pathname, search, hash]);\r\n\r\n    useImperativeHandle(ref as MutableRef<RouterRef>, () => ({\r\n      navigateTo: (pathname: string) => history.push(pathname),\r\n      location,\r\n    }));\r\n\r\n    return (\r\n      <RouterHistoryContext.Provider value={historyContext}>\r\n        <ActiveRouteContext.Provider value={routerContext}>{slot(slot$)}</ActiveRouteContext.Provider>\r\n      </RouterHistoryContext.Provider>\r\n    );\r\n  }),\r\n);\r\n\r\nexport { Router };\r\n","import { useMemo } from '../use-memo';\r\nimport type { MutableRef } from '../ref';\r\n\r\nfunction useImperativeHandle<T>(ref: MutableRef<T>, createHandle: () => T, deps?: Array<any>) {\r\n  const current = useMemo(() => createHandle(), deps || [{}]);\r\n\r\n  if (ref) {\r\n    ref.current = current;\r\n  }\r\n}\r\n\r\nexport { useImperativeHandle };\r\n","import { h, createComponent } from '@dark-engine/core';\r\n\r\nconst Spinner = createComponent(() => (\r\n  <div class='sp-layout'>\r\n    <div class='sp sp-hydrogen'></div>\r\n  </div>\r\n));\r\n\r\nexport { Spinner };\r\n","import { h, createComponent, Suspense, type DarkElement } from '@dark-engine/core';\r\nimport { type Routes, Router, RouterLink } from '@dark-engine/web-router';\r\n\r\nimport { Spinner } from './spinner';\r\n\r\ntype ShellProps = {\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Shell = createComponent<ShellProps>(({ slot }) => {\r\n  return (\r\n    <Suspense fallback={<Spinner />}>\r\n      <header>\r\n        <RouterLink to='/home'>home</RouterLink>\r\n        <RouterLink to='/home#one'>home one</RouterLink>\r\n        <RouterLink to='/home#two'>home two</RouterLink>\r\n        <RouterLink to='/about'>about</RouterLink>\r\n        <RouterLink to='/contacts'>contacts</RouterLink>\r\n      </header>\r\n      <main>{slot}</main>\r\n    </Suspense>\r\n  );\r\n});\r\n\r\nexport type AppProps = {\r\n  url?: string;\r\n  routes: Routes;\r\n};\r\n\r\nconst App = createComponent<AppProps>(({ url, routes }) => {\r\n  return (\r\n    <Router routes={routes} url={url}>\r\n      {slot => <Shell>{slot}</Shell>}\r\n    </Router>\r\n  );\r\n});\r\n\r\nexport { App };\r\n","import { lazy } from '@dark-engine/core';\r\nimport { hydrateRoot, createRoot } from '@dark-engine/platform-browser';\r\nimport { type Routes } from '@dark-engine/web-router';\r\n\r\nimport { App, type AppProps } from '../components/app';\r\n\r\nconst Home = lazy(() => import('../components/home'));\r\nconst HomeChildA = lazy(() => import('../components/child-a'));\r\nconst HomeChildB = lazy(() => import('../components/child-b'));\r\nconst HomeChildC = lazy(() => import('../components/child-c'));\r\nconst About = lazy(() => import('../components/about'));\r\nconst Contacts = lazy(() => import('../components/contacts'));\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: 'home/:id',\r\n    component: Home,\r\n    children: [\r\n      {\r\n        path: 'a',\r\n        component: HomeChildA,\r\n      },\r\n      {\r\n        path: 'b',\r\n        component: HomeChildB,\r\n      },\r\n      {\r\n        path: 'c',\r\n        component: HomeChildC,\r\n      },\r\n      {\r\n        path: '',\r\n        redirectTo: 'a',\r\n      },\r\n      {\r\n        path: '**',\r\n        redirectTo: 'a',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    path: 'about',\r\n    component: About,\r\n  },\r\n  {\r\n    path: 'contacts',\r\n    component: Contacts,\r\n  },\r\n  {\r\n    path: '**',\r\n    redirectTo: 'home/:id',\r\n  },\r\n];\r\n\r\nfunction bootstrap(hydrate = false, props: Omit<AppProps, 'routes'> = {}) {\r\n  hydrate\r\n    ? hydrateRoot(document.getElementById('root'), App({ ...props, routes }))\r\n    : createRoot(document.getElementById('root')).render(App({ ...props, routes }));\r\n}\r\n\r\nexport { bootstrap };\r\n","import { bootstrap } from './bootstrap/app.client';\r\n\r\nbootstrap(true);\r\n"],"names":["inProgress","defaultOptions","displayName","defaultProps","token","Symbol","ComponentFactory","type","props","ref","children","shouldUpdate","constructor","this","createComponent","options","computedOptions","mprops","detectIsComponentFactory","factory","getComponentFactoryKey","getComponentFactoryFlag","ROOT","REPLACER","INDEX_KEY","TYPE","ATTR_KEY","ATTR_REF","ATTR_FLAG","TaskPriority","Flag","createContext","defaultValue","context","Provider","Consumer","value","slot","fiber","provider","providerValue","subscribers","Set","subscribe","subscriber","add","delete","Map","set","get","forEach","fn","createProvider","useContext","createConsumer","nextFiber","parent","getProvider","update","scope","hasProvider","Boolean","unsubscribe","Object","is","getChildren","map","x","toString","Array","isArray","createElement","tag","as","length","cloneTagMap","Fiber","id","nativeElement","child","nextSibling","alternate","move","effectTag","instance","hook","effectHost","layoutEffectHost","insertionEffectHost","portalHost","childrenCount","childrenElementsCount","marker","isUsed","idx","elementIdx","batched","catchException","static","nextId","mutate","keys","key","markEffectHost","markLayoutEffectHost","markInsertionEffectHost","markPortalHost","incrementChildrenElementsCount","count","force","fromUpdate","wipFiber","stop","setError","error","workLoop","nextUnitOfWork","shouldYield","hasMoreWork","performUnitOfWork","flush","isDynamic","insertionEffects","deletions","onComplete","diff","parentFiber","getParentFiberWithNativeElement","isRight","resetIsDeepWalking","isReturn","syncElementIndices","layoutEffects","effects","setTimeout","skip","commitChanges","isDeepWalking","hasChildrenProp","fiber$","instance$","performChild","fiber$$","performSibling","getHook","pertformInstance","performAlternate","performFiber","performMemo","parentInstance","childrenIdx","isUpdate","hasAlternate","isSameKeys","getElementKey","getInstanceType","insertToFiber","createConditionalFiber","vNode","alternateType","isSameType","flag","getElementFlag","hasNoMovesFlag","prevKeys","nextKeys","prevKeysMap","nextKeysMap","keyedFibersMap","prevKey","createIndexKey","push","nextKey","extractKeys","result","size","Math","max","p","n","i","prevKeyFiber","nextKeyFiber","canAddToDeletions","prevFactory","nextFactory","prevProps","nextProps","deep","performedInstance","elements","splice","mountInstance","isComponentFactory","err","supportConditional","name","element","prevInstance","nextInstance","detectIsSameComponentFactoryTypesWithSameKeys","values","createUpdateCallback","rootId","forceStart","onStart","EffectTag","$$fragment","Fragment","detectIsFragment","detectIsFunction","o","detectIsUndefined","detectIsNumber","detectIsString","detectIsObject","detectIsBoolean","detectIsArray","detectIsNull","detectIsEmpty","detectIsFalsy","getTime","Date","now","dummyFn","args","console","flatten","source","list","levelMap","level","item","keyBy","reduce","acc","detectIsDepsDifferent","deps","prevDeps","$$memo","detectIsMemo","platform","createNativeElement","Error","msg","requestAnimationFrame","cancelAnimationFrame","scheduleCallback","shouldYeildToHost","applyCommit","finishCommitWork","detectIsDynamic","detectIsPortal","unmountPortal","restart","detectIsServer","stores","Store","wipRoot","currentRoot","events","unsubscribers","fiberMount","navigation","componentFiber","isLayoutEffectsZone","isInserionEffectsZone","isUpdateHookZone","isBatchZone","isHydrateZone","lazy","rootStore","remove","getRootId","store","wipRootStore","currentRootStore","nextUnitOfWorkStore","currentFiberStore","eventsStore","addUnsubscriber","deletionsStore","has","reset","fiberMountStore","getIndex","jumpToChild","nextLevel","jumpToParent","jumpToSibling","deepWalking","effectsStore","effect","layoutEffectsStore","insertionEffectsStore","isInsertionEffectsZone","registerLazy","unregisterLazy","detectHasRegisteredLazy","unmountFiber","unmountRoot","useCallback","callback","$$useEffect","useEffect","hasEffects","dropEffects","createEffect","runEffect","undefined","cleanup","some","$$useInsertionEffect","useInsertionEffect","hasInsertionEffects","dropInsertionEffects","$$useLayoutEffect","useLayoutEffect","hasLayoutEffects","dropLayoutEffects","Memo","processValue","getValue","isDepsDifferent","check","wrap","useMemo","hookValue","computedGetValue","useState","initialValue","setState","sourceValue","prevValue","newValue","setValue","priority","useUpdate","timeoutMs","forceSync","window","clearTimeout","NodeType","$$virtualNode","VirtualNode","TagVirtualNode","attrs","super","TextVirtualNode","text","CommentVirtualNode","detectIsVirtualNode","detectIsTagVirtualNode","detectIsCommentVirtualNode","detectIsTextVirtualNode","detectIsVirtualNodeFactory","getTagVirtualNodeKey","getTagVirtualNodeFlag","getVirtualNodeFactoryKey","getVirtualNodeFactoryFlag","createReplacer","View","def","_void","Text","from","walkFiber","onLoop","isStopped","visitedMap","detectCanVisit","newFiber","SLASH","PARAMETER","WILDCARD","PROTOCOL_MARK","SEARCH_MARK","HASH_MARK","ActiveRouteContext","useActiveRouteContext","RouterHistoryContext","useRouterHistoryContext","CurrentPathContext","useCurrentPathContext","checkContextValue","Route","path","pathMatch","redirectTo","component","prefix","rootPath","createRootPath","path$","createPath","createRoutes","route","getRoute","getPath","replaceAll","render","nextRoute","routes","routes$","route$","redirect","pick","createMatcher","space","urlPath","routePath","sUrlPath","sRoutePath","segment","isRoot","isWildcard","isParam","createPathname","parts","param","newPathname","join","prefix$","resolveRoute","pathname","activeRoute","filter","detectIsMatchByFirstStrategy","_","b","matcher","detectIsMatchBySecondStrategy","a","match","detectIsMatchAsWildcard","wildcard","root","find","resolve","params","sPathname","sPath","getParamsMap","RouterLink","to","activeClassName","className","sourceClassName","onClick","rest","history","hash","isActive","to$","hash$","indexOf","detectIsActiveLink","cm","handleClick","useEvent","e","preventDefault","href","class","useHistory","useLocation","location","pipe","fns","fn1","fn2","parseURL","url","body","protocol","host","search","split","splitted","findIndex","idx1","lastSlash","createSearch","createHash","detectIsParam","startsWith","getParamName","slice","splitPath","spath","endsWith","normalaizePathname","firstSlash","sort","selector","compare","trim","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","d","definition","defineProperty","enumerable","f","chunkId","Promise","all","promises","u","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","call","l","done","script","needAttach","scripts","document","getElementsByTagName","s","getAttribute","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","doneFns","parentNode","removeChild","bind","target","head","appendChild","r","toStringTag","scriptUrl","importScripts","currentScript","replace","installedChunks","j","installedChunkData","promise","reject","errorType","realSrc","message","request","webpackJsonpCallback","parentChunkLoadingFunction","data","chunkIds","moreModules","runtime","chunkLoadingGlobal","self","forwardRef","SuspenseContext","fallback","Suspense","$$lazy","componentsMap","then","default","fetchModule","$$portal","innerHTML","getPortalContainer","container","SyntheticEvent","sourceEvent","propagation","stopPropagation","getPropagation","delegateEvent","eventName","handler","eventsMap","handlerMap","rootHandler","fireEvent","syntheticEvent","parentElement","dispatchEvent","WeakMap","addEventListener","removeEventListener","detectIsEvent","attrName","getEventName","toLowerCase","attrBlackListMap","fragmentsMap","moves","svgTagNamesMap","voidTagNamesMap","createNativeElementMap","tagNode","tagName","createElementNS","textNode","createTextNode","commentNode","createComment","applyRef","mutableRef","detectIsMutableRef","current","patchProperties","attrValue","patchPropertiesSpecialCasesMap","getPrototypeOf","getOwnPropertyDescriptor","includes","input","checked","autofocus","textarea","String","applyCommitMap","childNodes","splitText","fragment","createDocumentFragment","append","insertBefore","insert","attrNames","tagElement","addAttributes","commitCreation","sourceNodes","walk","collectElements","sourceFragment","DocumentFragment","node","replaceChild","textContent","nextVNode","prevAttrValue","nextAttrValue","removeAttribute","updateAttributes","commitUpdate","commitDeletion","queueByPriority","animations","hight","normal","low1","low2","scheduledCallback","deadline","isMessageLoopRunning","currentTask","Task","time","nextTaskId","task","executeTasks","queue","shift","isAnimation","requestCallbackSync","port","postMessage","checkOverdueTasks","requestIdleCallback","channel","MessageChannel","port2","port1","onmessage","isInjected","roots","hydrate","inject","Element","isMounted","unmount","hydrateRoot","browserHistory","RouterHistory","stack","cursor","fromHistory","dispose","spathname","state","getState","replaceState","createStateBox","handleEvent","mapSubscribers","clear","STATE_KEY","syncHistory","action","stateBox","spathname$","HistoryAction","PUSH","pushState","REPLACE","forward","go","back","delta","RouterLocation","charCodeAt","createKey","freeze","createRouterLocation","Router","baseURL","sourceRoutes","sourceURL","setLocation","createRouterHistory","slot$","historyContext","routerContext","newSpathname","createHandle","navigateTo","useImperativeHandle","Spinner","Shell","App","getElementById","bootstrap"],"sourceRoot":""}