{"version":3,"file":"build.js","mappings":"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","sources":["webpack:///webpack/runtime/load script","webpack:///../../../packages/core/src/component/component.ts","webpack:///../../../packages/core/src/constants.ts","webpack:///../../../packages/core/src/context/context.ts","webpack:///../../../packages/core/src/element/element.ts","webpack:///../../../packages/core/src/emitter/emitter.ts","webpack:///../../../packages/core/src/fiber/fiber.ts","webpack:///../../../packages/core/src/fragment/fragment.ts","webpack:///../../../packages/core/src/lazy/utils.ts","webpack:///../../../packages/core/src/memo/utils.ts","webpack:///../../../packages/core/src/platform/platform.ts","webpack:///../../../packages/core/src/ref/ref.ts","webpack:///../../../packages/core/src/scheduler/scheduler.ts","webpack:///../../../packages/core/src/scope/scope.ts","webpack:///../../../packages/core/src/unmount/unmount.ts","webpack:///../../../packages/core/src/use-callback/use-callback.ts","webpack:///../../../packages/core/src/use-effect/types.ts","webpack:///../../../packages/core/src/use-effect/use-effect.ts","webpack:///../../../packages/core/src/use-insertion-effect/use-insertion-effect.ts","webpack:///../../../packages/core/src/use-layout-effect/use-layout-effect.ts","webpack:///../../../packages/core/src/memo/memo.ts","webpack:///../../../packages/core/src/use-memo/use-memo.ts","webpack:///../../../packages/core/src/use-state/use-state.ts","webpack:///../../../packages/core/src/use-update/use-update.ts","webpack:///../../../packages/core/src/batch/batch.ts","webpack:///../../../packages/core/src/utils/utils.ts","webpack:///../../../packages/core/src/view/types.ts","webpack:///../../../packages/core/src/view/view.ts","webpack:///../../../packages/core/src/walk/walk.ts","webpack:///../../../packages/core/src/workloop/workloop.ts","webpack:///../../../packages/web-router/src/constants.ts","webpack:///../../../packages/web-router/src/context/context.tsx","webpack:///../../../packages/web-router/src/create-routes/create-routes.ts","webpack:///../../../packages/web-router/src/router-link/router-link.tsx","webpack:///../../../packages/core/src/use-event/use-event.ts","webpack:///../../../packages/web-router/src/use-history/use-history.ts","webpack:///../../../packages/web-router/src/use-location/use-location.ts","webpack:///../../../packages/web-router/src/utils/utils.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/ensure chunk","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/jsonp chunk loading","webpack:///../../../packages/platform-browser/src/portal/utils.ts","webpack:///../../../packages/platform-browser/src/events/events.ts","webpack:///../../../packages/platform-browser/src/constants.ts","webpack:///../../../packages/platform-browser/src/dom/dom.ts","webpack:///../../../packages/platform-browser/src/render/render.ts","webpack:///../../../packages/core/src/shadow/utils.ts","webpack:///../../../packages/core/src/shadow/shadow.ts","webpack:///../../../packages/core/src/suspense/suspense.ts","webpack:///../../../packages/core/src/lazy/lazy.ts","webpack:///../../../packages/web-router/src/history/history.ts","webpack:///../../../packages/web-router/src/location/location.ts","webpack:///../../../packages/web-router/src/router/router.tsx","webpack:///../../../packages/core/src/use-imperative-handle/use-imperative-handle.ts","webpack:///./components/spinner.tsx","webpack:///./components/app.tsx","webpack:///./bootstrap/app.client.tsx","webpack:///../../../packages/platform-browser/src/hydrate-root/hydrate-root.tsx","webpack:///../../../packages/platform-browser/src/create-root/create-root.tsx","webpack:///./index.tsx"],"sourcesContent":["var inProgress = {};\n// data-webpack is not used as build has no uniqueName\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","import { type ElementKey, type Instance } from '../shared';\r\nimport { KEY_ATTR } from '../constants';\r\nimport { error } from '../utils';\r\nimport { type Ref } from '../ref';\r\nimport type {\r\n  CreateElement,\r\n  ComponentFactory,\r\n  ComponentOptions,\r\n  ShouldUpdate,\r\n  StandardComponentProps,\r\n  ComponentInject,\r\n  ComponentFactoryWithPossiblyInject,\r\n} from './types';\r\n\r\nconst $$inject = Symbol('inject');\r\nclass Component<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public props: P;\r\n  public ref?: Ref<R>;\r\n  public token?: Symbol;\r\n  public displayName?: string;\r\n  public shouldUpdate?: ShouldUpdate<P>;\r\n  public children: Array<Instance> = [];\r\n\r\n  constructor(\r\n    type: CreateElement<P>,\r\n    token: Symbol,\r\n    props: P,\r\n    ref: Ref<R>,\r\n    shouldUpdate: ShouldUpdate<P>,\r\n    displayName: string,\r\n  ) {\r\n    this.type = type;\r\n    this.props = props;\r\n    ref && (this.ref = ref);\r\n    token && (this.token = token);\r\n    shouldUpdate && (this.shouldUpdate = shouldUpdate);\r\n    displayName && (this.displayName = displayName);\r\n  }\r\n}\r\n\r\nfunction component<P extends object, R = unknown>(type: CreateElement<P, R>, options: ComponentOptions = {}) {\r\n  const { token: $token, displayName } = options;\r\n  type Props = P & StandardComponentProps;\r\n  const factory: ComponentFactoryWithPossiblyInject<Props, R> = (props = {} as Props, ref?: Ref<R>) => {\r\n    const { token = $token, shouldUpdate } = factory[$$inject] || defaultInject;\r\n\r\n    if (props.ref) {\r\n      delete props.ref;\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        process.env.NODE_ENV === 'development' &&\r\n          error(`[Dark]: To use ref you need to wrap the component with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return new Component(type, token, props, ref, shouldUpdate, displayName);\r\n  };\r\n\r\n  return factory as ComponentFactory<Props, R>;\r\n}\r\n\r\nconst defaultInject: ComponentInject = {};\r\n\r\nconst detectIsComponent = (x: unknown): x is Component => x instanceof Component;\r\n\r\nconst getComponentKey = (x: Component): ElementKey => x.props[KEY_ATTR] ?? null;\r\n\r\nconst hasComponentFlag = (inst: Component, flag: string) => Boolean(inst.props[flag]);\r\n\r\nexport { Component, component, $$inject, detectIsComponent, getComponentKey, hasComponentFlag };\r\n","export const VERSION = '0.25.1';\r\nexport const ROOT = 'dark:root';\r\nexport const REPLACER = 'dark:matter';\r\nexport const INDEX_KEY = 'dark:idx';\r\nexport const KEY_ATTR = 'key';\r\nexport const REF_ATTR = 'ref';\r\nexport const CREATE_EFFECT_TAG = 'C';\r\nexport const UPDATE_EFFECT_TAG = 'U';\r\nexport const DELETE_EFFECT_TAG = 'D';\r\nexport const SKIP_EFFECT_TAG = 'S';\r\nexport const INSERTION_EFFECT_HOST_MASK = 1;\r\nexport const LAYOUT_EFFECT_HOST_MASK = 2;\r\nexport const ASYNC_EFFECT_HOST_MASK = 4;\r\nexport const ATOM_HOST_MASK = 8;\r\nexport const PORTAL_HOST_MASK = 16;\r\nexport const SHADOW_MASK = 32;\r\nexport const FLUSH_MASK = 64;\r\nexport const MOVE_MASK = 128;\r\nexport const HOOK_DELIMETER = ':';\r\nexport const RESTART_TIMEOUT = 10;\r\nexport const YIELD_INTERVAL = 6;\r\n\r\nexport enum TaskPriority {\r\n  LOW = 0,\r\n  NORMAL = 1,\r\n  HIGH = 2,\r\n}\r\n\r\nexport enum Flag {\r\n  SKIP_SCAN_OPT = '__skipScanOpt',\r\n  MEMO_SLOT_OPT = '__memoSlotOpt',\r\n  STATIC_SLOT_OPT = '__staticSlotOpt',\r\n}\r\n\r\nexport const FLAGS = {\r\n  __skipScanOpt: true,\r\n  __memoSlotOpt: true,\r\n  __staticSlotOpt: true,\r\n};\r\n\r\nexport const ATTR_BLACK_LIST = {\r\n  [KEY_ATTR]: true,\r\n  [REF_ATTR]: true,\r\n  [Flag.SKIP_SCAN_OPT]: true,\r\n  [Flag.MEMO_SLOT_OPT]: true,\r\n  [Flag.STATIC_SLOT_OPT]: true,\r\n};\r\n","import type { DarkElement } from '../shared';\r\nimport type { Fiber } from '../fiber';\r\nimport { detectIsFunction } from '../utils';\r\nimport { $$scope } from '../scope';\r\nimport { component } from '../component';\r\nimport { useEffect } from '../use-effect';\r\nimport { useMemo } from '../use-memo';\r\nimport { useUpdate } from '../use-update';\r\nimport type { Context, ContexProviderProps, ContextProviderValue } from './types';\r\n\r\ntype CreateContextOptions = {\r\n  displayName?: string;\r\n};\r\n\r\nfunction createContext<T>(defaultValue: T, options?: CreateContextOptions): Context<T> {\r\n  const { displayName = 'Context' } = options || {};\r\n  const context: Context<T> = {\r\n    displayName,\r\n    defaultValue,\r\n    Provider: null,\r\n    Consumer: null,\r\n  };\r\n\r\n  context.Provider = createProvider(context, defaultValue, displayName);\r\n  context.Consumer = createConsumer(context, displayName);\r\n\r\n  return context;\r\n}\r\n\r\nfunction createProvider<T>(context: Context<T>, defaultValue: T, displayName: string) {\r\n  return component<ContexProviderProps<T>>(\r\n    ({ value = defaultValue, slot }) => {\r\n      const fiber = $$scope().getCursorFiber();\r\n\r\n      if (!fiber.provider) {\r\n        const providerValue: ContextProviderValue<T> = {\r\n          value,\r\n          subscribers: new Set(),\r\n          subscribe: (subscriber: (value: T) => void) => {\r\n            providerValue.subscribers.add(subscriber);\r\n\r\n            return () => providerValue.subscribers.delete(subscriber);\r\n          },\r\n        };\r\n\r\n        fiber.provider = new Map();\r\n        fiber.provider.set(context, providerValue);\r\n      }\r\n\r\n      const provider = fiber.provider.get(context);\r\n\r\n      useEffect(() => {\r\n        provider.subscribers.forEach(fn => fn(value));\r\n      }, [value]);\r\n\r\n      provider.value = value;\r\n\r\n      return slot;\r\n    },\r\n    { displayName: `${displayName}.Provider` },\r\n  );\r\n}\r\n\r\ntype ConsumerProps<T> = {\r\n  slot: (value: T) => DarkElement;\r\n};\r\n\r\nfunction createConsumer<T>(context: Context<T>, displayName: string) {\r\n  return component<ConsumerProps<T>>(\r\n    ({ slot }) => {\r\n      const value = useContext(context);\r\n\r\n      return detectIsFunction(slot) ? slot(value) : null;\r\n    },\r\n    { displayName: `${displayName}.Consumer` },\r\n  );\r\n}\r\n\r\nfunction useContext<T>(context: Context<T>): T {\r\n  const { defaultValue } = context;\r\n  const fiber = $$scope().getCursorFiber();\r\n  const provider = useMemo(() => getProvider<T>(context, fiber), []);\r\n  const value = provider ? provider.value : defaultValue;\r\n  const update = useUpdate();\r\n  const scope = useMemo(() => ({ value }), []);\r\n  const hasProvider = Boolean(provider);\r\n\r\n  useEffect(() => {\r\n    if (!hasProvider) return;\r\n    const unsubscribe = provider.subscribe((value: T) => {\r\n      if (!Object.is(scope.value, value)) {\r\n        update();\r\n      }\r\n    });\r\n\r\n    return unsubscribe;\r\n  }, [hasProvider]);\r\n\r\n  scope.value = value;\r\n\r\n  return value;\r\n}\r\n\r\nfunction getProvider<T>(context: Context<T>, fiber: Fiber): ContextProviderValue<T> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    if (nextFiber.provider && nextFiber.provider.get(context)) {\r\n      return nextFiber.provider.get(context) as ContextProviderValue<T>;\r\n    }\r\n\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createContext, useContext };\r\n","import { detectIsString, detectIsFunction } from '../utils';\r\nimport { type TagVirtualNodeFactory, type ViewOptions, View } from '../view';\r\nimport { type ComponentFactory } from '../component';\r\n\r\nfunction createElement(\r\n  element: string | Function,\r\n  props: object,\r\n  ...slot: Array<any>\r\n): ComponentFactory | TagVirtualNodeFactory | null {\r\n  if (detectIsString(element)) {\r\n    const options = (props || {}) as ViewOptions;\r\n\r\n    options.as = element;\r\n    options.slot = slot;\r\n\r\n    return View(options);\r\n  }\r\n\r\n  if (detectIsFunction(element)) {\r\n    const options = (props || {}) as { slot: unknown };\r\n\r\n    options.slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return element(options);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement, createElement as h };\r\n","import { type SubscriberWithValue } from '../shared';\r\n\r\ntype EventName = 'finish' | 'chunk';\r\n\r\nclass EventEmitter<E extends string = EventName, T = unknown> {\r\n  private subscribers: Map<Partial<E>, Set<SubscriberWithValue<unknown>>> = new Map();\r\n\r\n  on<T>(e: E, fn: SubscriberWithValue<T>) {\r\n    !this.subscribers.has(e) && this.subscribers.set(e, new Set());\r\n    this.subscribers.get(e).add(fn);\r\n\r\n    return () => this.subscribers.has(e) && this.subscribers.get(e).delete(fn);\r\n  }\r\n\r\n  emit(e: E, data?: T) {\r\n    this.subscribers.has(e) && this.subscribers.get(e).forEach(x => x(data));\r\n  }\r\n\r\n  kill() {\r\n    this.subscribers = new Map();\r\n  }\r\n\r\n  __getSize() {\r\n    return this.subscribers.size;\r\n  }\r\n}\r\n\r\nexport { EventEmitter };\r\n","import { detectIsTagVirtualNode, detectIsPlainVirtualNode, detectAreSameComponentTypesWithSameKeys } from '../view';\r\nimport { type Instance, type Callback, type TimerId } from '../shared';\r\nimport { type Context, type ContextProviderValue } from '../context';\r\nimport { detectIsComponent } from '../component';\r\nimport { detectIsFunction } from '../utils';\r\nimport { type Atom } from '../atom';\r\nimport { $$scope } from '../scope';\r\n\r\nclass Fiber<N = NativeElement> {\r\n  id = 0;\r\n  cc = 0; // child fibers count\r\n  cec = 0; // child native elements count\r\n  idx = 0; // idx of fiber in the parent fiber\r\n  eidx = 0; // native element idx\r\n  mask = 0; // bit mask\r\n  element: N = null; // native element\r\n  tag: string = null; // effect tag (CREATE, UPDATE, DELETE, SKIP)\r\n  parent: Fiber<N> = null; // parent fiber\r\n  child: Fiber<N> = null; // child fiber\r\n  next: Fiber<N> = null; // next sibling fiber\r\n  alt: Fiber<N> = null; // alternate fiber (previous)\r\n  inst: Instance = null; // instance of component or virtual node\r\n  hook: Hook | null = null; // hook\r\n  provider: Map<Context, ContextProviderValue> = null; // provider of context\r\n  atoms: Map<Atom, Callback> = null;\r\n  marker: string; // for dev\r\n  batch: Batch;\r\n  catch: (error: Error) => void;\r\n\r\n  constructor(hook: Hook = null, provider: Fiber['provider'] = null, idx = 0) {\r\n    this.id = ++Fiber.nextId;\r\n    this.idx = idx;\r\n    hook && (this.hook = hook);\r\n    provider && (this.provider = provider);\r\n  }\r\n\r\n  mutate(fiber: Partial<Fiber<N>>) {\r\n    const keys = Object.keys(fiber);\r\n\r\n    for (const key of keys) {\r\n      this[key] = fiber[key];\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  markHost(mask: number) {\r\n    this.mask |= mask;\r\n    this.parent && !(this.parent.mask & mask) && this.parent.markHost(mask);\r\n  }\r\n\r\n  increment(count = 1, force = false) {\r\n    if (!this.parent) return;\r\n    const $scope = $$scope();\r\n    const isUpdateZone = $scope.getIsUpdateZone();\r\n    const wipFiber = $scope.getWorkInProgress();\r\n    const stop = isUpdateZone && wipFiber.parent === this.parent;\r\n\r\n    if (\r\n      detectIsPlainVirtualNode(this.inst) ||\r\n      (detectIsTagVirtualNode(this.inst) && this.inst.children?.length === 0)\r\n    ) {\r\n      this.cec = 1;\r\n    }\r\n\r\n    if (isUpdateZone && stop && !force) return;\r\n\r\n    this.parent.cec += count;\r\n\r\n    if (!this.parent.element) {\r\n      this.parent.increment(count);\r\n    }\r\n  }\r\n\r\n  setError(error: Error) {\r\n    if (detectIsFunction(this.catch)) {\r\n      this.catch(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n\r\n  static setNextId(id: number) {\r\n    Fiber.nextId = id;\r\n  }\r\n\r\n  private static nextId = 0;\r\n}\r\n\r\nclass Hook<T = any> {\r\n  id = 0;\r\n  idx = 0;\r\n  values: Array<T> = [];\r\n  owner: Fiber = null;\r\n  private static nextId = 0;\r\n\r\n  constructor() {\r\n    this.id = ++Hook.nextId;\r\n  }\r\n}\r\n\r\nfunction getHook(alt: Fiber, prevInst: Instance, nextInst: Instance): Hook | null {\r\n  if (alt && detectAreSameComponentTypesWithSameKeys(prevInst, nextInst)) return alt.hook;\r\n  if (detectIsComponent(nextInst)) return new Hook();\r\n\r\n  return null;\r\n}\r\n\r\ntype Batch = {\r\n  timer: TimerId;\r\n  changes: Array<Callback>;\r\n};\r\n\r\nexport type NativeElement = unknown;\r\nexport type HookValue<T = any> = { deps: Array<any>; value: T };\r\n\r\nexport { Fiber, Hook, getHook };\r\n","import { component, detectIsComponent } from '../component';\r\nimport type { KeyProps, SlotProps } from '../shared';\r\n\r\ntype FragmentProps = Required<SlotProps> & KeyProps;\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = component<FragmentProps>(({ slot }) => slot || null, { token: $$fragment });\r\n\r\nconst detectIsFragment = (instance: unknown) => detectIsComponent(instance) && instance.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import { detectIsComponent } from '../component';\r\n\r\nconst $$lazy = Symbol('lazy');\r\nconst $$loaded = Symbol('loaded');\r\n\r\nconst detectIsLazy = (instance: unknown) => detectIsComponent(instance) && instance.token === $$lazy;\r\n\r\nconst detectIsLoaded = (instance: unknown) => detectIsComponent(instance) && instance.type[$$loaded];\r\n\r\nexport { $$lazy, $$loaded, detectIsLazy, detectIsLoaded };\r\n","import { detectIsComponent } from '../component';\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst detectIsMemo = (instance: unknown) => detectIsComponent(instance) && instance.token === $$memo;\r\n\r\nexport { $$memo, detectIsMemo };\r\n","import { type Fiber } from '../fiber';\r\nimport { type VirtualNode } from '../view';\r\nimport { type Callback } from '../shared';\r\n\r\nexport type Platform = {\r\n  createElement: <N>(vNode: VirtualNode) => N;\r\n  insertElement: <N>(node: N, idx: number, parent: N) => void;\r\n  raf: typeof requestAnimationFrame;\r\n  caf: typeof cancelAnimationFrame;\r\n  spawn: (callback: Callback) => void;\r\n  commit: (fiber: Fiber) => void;\r\n  finishCommit: () => void;\r\n  detectIsDynamic: () => boolean;\r\n  detectIsPortal: (instance: unknown) => boolean;\r\n  unmountPortal: (fiber: Fiber) => void;\r\n  chunk: (fiber: Fiber) => void;\r\n};\r\n\r\nconst defaultRealisation = () => {\r\n  throw new Error('Function not installed by renderer!');\r\n};\r\n\r\nconst platform: Platform = {\r\n  createElement: defaultRealisation,\r\n  insertElement: defaultRealisation,\r\n  raf: defaultRealisation,\r\n  caf: defaultRealisation,\r\n  spawn: defaultRealisation,\r\n  commit: defaultRealisation,\r\n  finishCommit: defaultRealisation,\r\n  detectIsDynamic: defaultRealisation,\r\n  detectIsPortal: defaultRealisation,\r\n  unmountPortal: defaultRealisation,\r\n  chunk: defaultRealisation,\r\n};\r\n\r\nconst detectIsServer = () => !platform.detectIsDynamic();\r\n\r\nexport { platform, detectIsServer };\r\n","import { detectIsObject, detectIsNull, detectIsFunction } from '../utils';\r\nimport type { Component, ComponentFactory } from '../component';\r\nimport type { RefProps, KeyProps, FlagProps } from '../shared';\r\nimport { useMemo } from '../use-memo';\r\nimport type { MutableRef, Ref } from './types';\r\n\r\nfunction forwardRef<P extends object, R>(\r\n  component: ComponentFactory<P, R>,\r\n): ComponentFactory<P & RefProps<R> & KeyProps & FlagProps, R> {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return (props: Props) => {\r\n    const { ref, ...rest } = (props || {}) as Props;\r\n\r\n    return component(rest as P, ref) as Component<P, R>;\r\n  };\r\n}\r\n\r\nfunction detectIsMutableRef(ref: unknown): ref is MutableRef {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction applyRef<T>(ref: Ref<T>, current: T) {\r\n  if (detectIsFunction(ref)) {\r\n    ref(current);\r\n  } else if (detectIsMutableRef(ref)) {\r\n    ref.current = current;\r\n  }\r\n}\r\n\r\nfunction useRef<T>(initialValue: T = null): MutableRef<T> {\r\n  const ref = useMemo(() => ({ current: initialValue }), []) as MutableRef<T>;\r\n\r\n  return ref;\r\n}\r\n\r\nexport { forwardRef, detectIsMutableRef, applyRef, useRef };\r\n","import { type WorkLoop, workLoop, detectIsBusy } from '../workloop';\r\nimport { type SetPendingStatus } from '../start-transition';\r\nimport { type Callback } from '../shared';\r\nimport { type Fiber } from '../fiber';\r\nimport { ROOT, HOOK_DELIMETER, YIELD_INTERVAL, TaskPriority } from '../constants';\r\nimport { getTime, detectIsFunction, nextTick } from '../utils';\r\nimport { EventEmitter } from '../emitter';\r\nimport { platform } from '../platform';\r\n\r\nclass MessageChannel extends EventEmitter<PortEvent> {\r\n  port1: MessagePort = null;\r\n  port2: MessagePort = null;\r\n\r\n  constructor() {\r\n    super();\r\n    this.port1 = new MessagePort(this);\r\n    this.port2 = new MessagePort(this);\r\n  }\r\n}\r\n\r\nclass MessagePort {\r\n  channel: MessageChannel;\r\n  offs: Array<Callback> = [];\r\n\r\n  constructor(channel: MessageChannel) {\r\n    this.channel = channel;\r\n  }\r\n\r\n  on(event: PortEvent, callback: PortListener) {\r\n    const off = this.channel.on(event, callback);\r\n\r\n    this.offs.push(off);\r\n  }\r\n\r\n  postMessage(value: unknown) {\r\n    platform.spawn(() => {\r\n      this.channel.emit('message', value);\r\n    });\r\n  }\r\n\r\n  unref() {\r\n    this.offs.forEach(x => x());\r\n  }\r\n}\r\n\r\nclass Scheduler {\r\n  private queue: Record<TaskPriority, Array<Task>> = {\r\n    [TaskPriority.HIGH]: [],\r\n    [TaskPriority.NORMAL]: [],\r\n    [TaskPriority.LOW]: [],\r\n  };\r\n  private deadline = 0;\r\n  private task: Task = null;\r\n  private scheduledCallback: WorkLoop = null;\r\n  private isMessageLoopRunning = false;\r\n  private channel: MessageChannel = null;\r\n  private port: MessagePort = null;\r\n\r\n  constructor() {\r\n    this.channel = new MessageChannel();\r\n    this.port = this.channel.port2;\r\n    this.channel.port1.on('message', this.performWorkUntilDeadline.bind(this));\r\n  }\r\n\r\n  reset() {\r\n    this.deadline = 0;\r\n    this.task = null;\r\n    this.scheduledCallback = null;\r\n    this.isMessageLoopRunning = false;\r\n  }\r\n\r\n  shouldYield() {\r\n    return getTime() >= this.deadline;\r\n  }\r\n\r\n  schedule(callback: Callback, options?: ScheduleCallbackOptions) {\r\n    const {\r\n      priority = TaskPriority.NORMAL,\r\n      forceAsync = false,\r\n      isTransition = false,\r\n      createLocation,\r\n      setPendingStatus,\r\n    } = options || {};\r\n    const task = new Task(callback, priority, forceAsync);\r\n\r\n    task.setIsTransition(isTransition);\r\n    task.setPendingSetter(setPendingStatus);\r\n    task.setLocationCreator(createLocation || createRootLocation);\r\n    this.put(task);\r\n    this.execute();\r\n  }\r\n\r\n  hasPrimaryTask() {\r\n    if (!this.task.getIsTransition()) return false;\r\n    const { high, normal, low } = this.getQueues();\r\n    const hasPrimary = high.length > 0 || normal.length > 0;\r\n    const hasLow = low.length > 0;\r\n\r\n    if (hasPrimary || hasLow) {\r\n      const loc = this.task.createLocation();\r\n\r\n      if (hasPrimary) {\r\n        const has = Task.detectHasChildUpdate(loc, [...high, ...normal]);\r\n\r\n        if (has) {\r\n          this.task.markAsUnnecessary();\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      if (hasLow) {\r\n        const has = Task.detectHasSameUpdate(loc, low);\r\n\r\n        if (has) {\r\n          this.task.markAsUnnecessary();\r\n\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  cancelTask(fn: TaskRestorer) {\r\n    if (this.task.getIsUnnecessary()) return this.complete(this.task);\r\n    this.task.setTaskRestorer(fn);\r\n    this.defer(this.task);\r\n  }\r\n\r\n  private complete(task: Task) {\r\n    task.pending(false);\r\n  }\r\n\r\n  private put(task: Task) {\r\n    const queue = this.queue[task.getPriority()];\r\n\r\n    queue.push(task);\r\n  }\r\n\r\n  private pick(queue: Array<Task>) {\r\n    if (queue.length === 0) return false;\r\n    this.task = queue.shift();\r\n\r\n    if (this.task.getIsTransition() && this.task.canPending()) {\r\n      const task = this.task;\r\n\r\n      task.markAsPending();\r\n      this.defer(this.task);\r\n      this.task = null;\r\n\r\n      nextTick(() => task.pending(true));\r\n\r\n      return true;\r\n    }\r\n\r\n    this.task.run();\r\n    this.task.getForceAsync() ? this.requestCallbackAsync(workLoop) : this.requestCallback(workLoop);\r\n\r\n    return true;\r\n  }\r\n\r\n  private execute() {\r\n    const isBusy = detectIsBusy();\r\n    const { high, normal, low } = this.getQueues();\r\n\r\n    if (!isBusy && !this.isMessageLoopRunning) {\r\n      this.pick(high) || this.pick(normal) || this.pick(low);\r\n    }\r\n  }\r\n\r\n  private requestCallbackAsync(callback: WorkLoop) {\r\n    this.scheduledCallback = callback;\r\n\r\n    if (!this.isMessageLoopRunning) {\r\n      this.isMessageLoopRunning = true;\r\n      this.port.postMessage(null);\r\n    }\r\n  }\r\n\r\n  private requestCallback(callback: WorkLoop) {\r\n    callback(false);\r\n    this.task = null;\r\n    this.execute();\r\n  }\r\n\r\n  private performWorkUntilDeadline() {\r\n    if (this.scheduledCallback) {\r\n      this.deadline = getTime() + YIELD_INTERVAL;\r\n      const hasMoreWork = this.scheduledCallback(true);\r\n\r\n      if (!hasMoreWork) {\r\n        this.complete(this.task);\r\n        this.reset();\r\n        this.execute();\r\n      } else {\r\n        this.port.postMessage(null);\r\n      }\r\n    } else {\r\n      this.isMessageLoopRunning = false;\r\n    }\r\n  }\r\n\r\n  private defer(task: Task) {\r\n    const { low } = this.getQueues();\r\n\r\n    low.unshift(task);\r\n  }\r\n\r\n  private getQueues() {\r\n    const high = this.queue[TaskPriority.HIGH];\r\n    const normal = this.queue[TaskPriority.NORMAL];\r\n    const low = this.queue[TaskPriority.LOW];\r\n\r\n    return {\r\n      high,\r\n      normal,\r\n      low,\r\n    };\r\n  }\r\n}\r\n\r\ntype TaskCallback = (fn: TaskRestorer) => void;\r\ntype TaskRestorer = (options: RestoreOptions) => void;\r\ntype LocationCreator = () => string;\r\n\r\nclass Task {\r\n  private id: number;\r\n  private priority: TaskPriority;\r\n  private forceAsync: boolean;\r\n  private isTransition: boolean;\r\n  private isPending: boolean;\r\n  private isUnnecessary: boolean;\r\n  private callback: TaskCallback;\r\n  private taskRestorer?: TaskRestorer = null;\r\n  private locationCreator?: LocationCreator;\r\n  private pendingSetter?: SetPendingStatus = null;\r\n  private static nextTaskId = 0;\r\n\r\n  constructor(callback: TaskCallback, priority: TaskPriority, forceAsync: boolean) {\r\n    this.id = ++Task.nextTaskId;\r\n    this.callback = callback;\r\n    this.priority = priority;\r\n    this.forceAsync = forceAsync;\r\n  }\r\n\r\n  getPriority() {\r\n    return this.priority;\r\n  }\r\n\r\n  getForceAsync() {\r\n    return this.forceAsync;\r\n  }\r\n\r\n  setIsTransition(value: boolean) {\r\n    this.isTransition = value;\r\n  }\r\n\r\n  getIsTransition() {\r\n    return this.isTransition;\r\n  }\r\n\r\n  run() {\r\n    this.callback(this.taskRestorer);\r\n    this.taskRestorer = null;\r\n  }\r\n\r\n  pending(value: boolean) {\r\n    this.isTransition && this.pendingSetter && this.pendingSetter(value);\r\n  }\r\n\r\n  markAsPending() {\r\n    this.isPending = true;\r\n  }\r\n\r\n  canPending() {\r\n    return !this.isPending && detectIsFunction(this.pendingSetter);\r\n  }\r\n\r\n  markAsUnnecessary() {\r\n    this.isUnnecessary = true;\r\n  }\r\n\r\n  getIsUnnecessary() {\r\n    return this.isUnnecessary;\r\n  }\r\n\r\n  setTaskRestorer(fn: TaskRestorer) {\r\n    this.taskRestorer = fn;\r\n  }\r\n\r\n  setLocationCreator(fn: LocationCreator) {\r\n    this.locationCreator = fn;\r\n  }\r\n\r\n  createLocation() {\r\n    return this.locationCreator();\r\n  }\r\n\r\n  setPendingSetter(fn: SetPendingStatus) {\r\n    this.pendingSetter = fn;\r\n  }\r\n\r\n  static detectHasSameUpdate(loc: string, tasks: Array<Task>) {\r\n    return tasks.some(x => {\r\n      const $loc = x.createLocation();\r\n      const has = $loc === loc;\r\n\r\n      return has;\r\n    });\r\n  }\r\n\r\n  static detectHasChildUpdate(loc: string, tasks: Array<Task>) {\r\n    const [$loc] = loc.split(HOOK_DELIMETER);\r\n\r\n    return tasks.some(x => {\r\n      const $$loc = x.createLocation();\r\n      const has = $$loc.length > loc.length && $$loc.indexOf($loc) !== -1;\r\n\r\n      return has;\r\n    });\r\n  }\r\n}\r\n\r\nconst createRootLocation: LocationCreator = () => ROOT;\r\n\r\ntype PortEvent = 'message';\r\ntype PortListener = (value: unknown) => void;\r\n\r\nexport type RestoreOptions = {\r\n  fiber: Fiber;\r\n  setValue?: () => void;\r\n  resetValue?: () => void;\r\n};\r\n\r\nexport type ScheduleCallbackOptions = {\r\n  priority?: TaskPriority;\r\n  forceAsync?: boolean;\r\n  isTransition?: boolean;\r\n  createLocation?: () => string;\r\n  setPendingStatus?: SetPendingStatus;\r\n  onCompleted?: () => void;\r\n};\r\n\r\nconst scheduler = new Scheduler();\r\n\r\nexport { scheduler };\r\n","import type { Callback, ElementKey } from '../shared';\r\nimport { type SetPendingStatus } from '../start-transition';\r\nimport { type Fiber } from '../fiber';\r\nimport { EventEmitter } from '../emitter';\r\nimport { platform } from '../platform';\r\n\r\nclass Scope {\r\n  private root: Fiber = null;\r\n  private wip: Fiber = null;\r\n  private cursor: Fiber = null;\r\n  private unit: Fiber = null;\r\n  private mountDeep = true;\r\n  private mountLevel = 0;\r\n  private mountNav: Record<number, number> = {};\r\n  private events: Map<string, WeakMap<object, Function>> = new Map();\r\n  private unsubs: Set<Callback> = new Set();\r\n  private actions: Actions = {};\r\n  private candidates: Set<Fiber> = new Set();\r\n  private deletions: Set<Fiber> = new Set();\r\n  private cancels: Array<Callback> = [];\r\n  private asyncEffects: Set<Callback> = new Set();\r\n  private layoutEffects: Set<Callback> = new Set();\r\n  private insertionEffects: Set<Callback> = new Set();\r\n  private setPendingStatus: SetPendingStatus = null;\r\n  private isLayoutEffectsZone = false;\r\n  private isInsertionEffectsZone = false;\r\n  private isUpdateZone = false;\r\n  private isBatchZone = false;\r\n  private isHydrateZone = false;\r\n  private isStreamZone = false;\r\n  private isTransitionZone = false;\r\n  private isEventZone = false;\r\n  private isHot = false;\r\n  private isDynamic = platform.detectIsDynamic();\r\n  private emitter = new EventEmitter();\r\n\r\n  private resetActions() {\r\n    this.actions = {};\r\n  }\r\n\r\n  getActionsById(id: number) {\r\n    return this.actions[id];\r\n  }\r\n\r\n  addActionMap(id: number, map: Record<ElementKey, Fiber>) {\r\n    this.actions[id] = {\r\n      map,\r\n      replace: null,\r\n      insert: null,\r\n      remove: null,\r\n      move: null,\r\n      stable: null,\r\n    };\r\n  }\r\n\r\n  addReplaceAction(id: number, nextKey: ElementKey) {\r\n    !this.actions[id].replace && (this.actions[id].replace = {});\r\n    this.actions[id].replace[nextKey] = true;\r\n  }\r\n\r\n  addInsertAction(id: number, nextKey: ElementKey) {\r\n    !this.actions[id].insert && (this.actions[id].insert = {});\r\n    this.actions[id].insert[nextKey] = true;\r\n  }\r\n\r\n  addRemoveAction(id: number, prevKey: ElementKey) {\r\n    !this.actions[id].remove && (this.actions[id].remove = {});\r\n    this.actions[id].remove[prevKey] = true;\r\n  }\r\n\r\n  addMoveAction(id: number, nextKey: ElementKey) {\r\n    !this.actions[id].move && (this.actions[id].move = {});\r\n    this.actions[id].move[nextKey] = true;\r\n  }\r\n\r\n  addStableAction(id: number, nextKey: ElementKey) {\r\n    !this.actions[id].stable && (this.actions[id].stable = {});\r\n    this.actions[id].stable[nextKey] = true;\r\n  }\r\n\r\n  copy() {\r\n    const scope = new Scope();\r\n\r\n    scope.root = null;\r\n    scope.wip = null;\r\n    scope.cursor = null;\r\n    scope.unit = this.unit;\r\n    scope.mountDeep = this.mountDeep;\r\n    scope.mountLevel = this.mountLevel;\r\n    scope.mountNav = { ...this.mountNav };\r\n    scope.events = this.events;\r\n    scope.unsubs = this.unsubs;\r\n    scope.actions = { ...this.actions };\r\n    scope.candidates = new Set([...this.candidates]);\r\n    scope.deletions = new Set([...this.deletions]);\r\n    scope.asyncEffects = new Set([...this.asyncEffects]);\r\n    scope.layoutEffects = new Set([...this.layoutEffects]);\r\n    scope.insertionEffects = new Set([...this.insertionEffects]);\r\n    scope.isUpdateZone = this.isUpdateZone;\r\n    scope.emitter = this.emitter;\r\n\r\n    return scope;\r\n  }\r\n\r\n  getRoot() {\r\n    return this.root;\r\n  }\r\n\r\n  setRoot(fiber: Fiber) {\r\n    this.root = fiber;\r\n  }\r\n\r\n  getWorkInProgress() {\r\n    return this.wip;\r\n  }\r\n\r\n  setWorkInProgress(fiber: Fiber) {\r\n    this.wip = fiber;\r\n  }\r\n\r\n  getNextUnitOfWork() {\r\n    return this.unit;\r\n  }\r\n\r\n  setNextUnitOfWork(fiber: Fiber) {\r\n    this.unit = fiber;\r\n  }\r\n\r\n  getCursorFiber() {\r\n    return this.cursor;\r\n  }\r\n\r\n  setCursorFiber(fiber: Fiber) {\r\n    this.cursor = fiber;\r\n  }\r\n\r\n  navToChild() {\r\n    this.mountLevel = this.mountLevel + 1;\r\n    this.mountNav[this.mountLevel] = 0;\r\n  }\r\n\r\n  navToSibling() {\r\n    this.mountNav[this.mountLevel] = this.mountNav[this.mountLevel] + 1;\r\n  }\r\n\r\n  navToParent() {\r\n    this.mountLevel = this.mountLevel - 1;\r\n  }\r\n\r\n  getMountIndex() {\r\n    return this.mountNav[this.mountLevel];\r\n  }\r\n\r\n  getMountDeep() {\r\n    return this.mountDeep;\r\n  }\r\n\r\n  setMountDeep(value: boolean) {\r\n    this.mountDeep = value;\r\n  }\r\n\r\n  resetMount() {\r\n    this.mountLevel = 0;\r\n    this.mountNav = {};\r\n    this.mountDeep = true;\r\n  }\r\n\r\n  getEvents() {\r\n    return this.events;\r\n  }\r\n\r\n  addEventUnsubscriber(fn: Callback) {\r\n    this.unsubs.add(fn);\r\n  }\r\n\r\n  unsubscribeEvents() {\r\n    this.unsubs.forEach(x => x());\r\n    this.unsubs = new Set();\r\n  }\r\n\r\n  getCandidates() {\r\n    return this.candidates;\r\n  }\r\n\r\n  addCandidate(fiber: Fiber) {\r\n    this.candidates.add(fiber);\r\n  }\r\n\r\n  resetCandidates() {\r\n    this.candidates = new Set();\r\n  }\r\n\r\n  getDeletions() {\r\n    return this.deletions;\r\n  }\r\n\r\n  hasDeletion(fiber: Fiber) {\r\n    let nextFiber = fiber;\r\n\r\n    while (nextFiber) {\r\n      if (this.deletions.has(nextFiber)) return true;\r\n      nextFiber = nextFiber.parent;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  addDeletion(fiber: Fiber) {\r\n    !this.hasDeletion(fiber) && this.deletions.add(fiber);\r\n  }\r\n\r\n  resetDeletions() {\r\n    this.deletions = new Set();\r\n  }\r\n\r\n  addAsyncEffect(fn: Callback) {\r\n    this.asyncEffects.add(fn);\r\n  }\r\n\r\n  resetAsyncEffects() {\r\n    this.asyncEffects = new Set();\r\n  }\r\n\r\n  runAsyncEffects() {\r\n    if (!this.isDynamic) return;\r\n    const effects = this.asyncEffects;\r\n    effects.size > 0 && setTimeout(() => effects.forEach(fn => fn()));\r\n  }\r\n\r\n  addLayoutEffect(fn: Callback) {\r\n    this.layoutEffects.add(fn);\r\n  }\r\n\r\n  resetLayoutEffects() {\r\n    this.layoutEffects = new Set();\r\n  }\r\n\r\n  runLayoutEffects() {\r\n    if (!this.isDynamic) return;\r\n    this.setIsLayoutEffectsZone(true);\r\n    this.layoutEffects.forEach(fn => fn());\r\n    this.setIsLayoutEffectsZone(false);\r\n  }\r\n\r\n  addInsertionEffect(fn: Callback) {\r\n    this.insertionEffects.add(fn);\r\n  }\r\n\r\n  resetInsertionEffects() {\r\n    this.insertionEffects = new Set();\r\n  }\r\n\r\n  runInsertionEffects() {\r\n    if (!this.isDynamic) return;\r\n    this.setIsInsertionEffectsZone(true);\r\n    this.insertionEffects.forEach(fn => fn());\r\n    this.setIsInsertionEffectsZone(false);\r\n  }\r\n\r\n  addCancel(fn: Callback) {\r\n    this.cancels.push(fn);\r\n  }\r\n\r\n  applyCancels() {\r\n    for (let i = this.cancels.length - 1; i >= 0; i--) {\r\n      this.cancels[i]();\r\n    }\r\n  }\r\n\r\n  resetCancels() {\r\n    this.cancels = [];\r\n  }\r\n\r\n  getIsLayoutEffectsZone() {\r\n    return this.isLayoutEffectsZone;\r\n  }\r\n\r\n  setIsLayoutEffectsZone(value: boolean) {\r\n    this.isLayoutEffectsZone = value;\r\n  }\r\n\r\n  getIsInsertionEffectsZone() {\r\n    return this.isInsertionEffectsZone;\r\n  }\r\n\r\n  setIsInsertionEffectsZone(value: boolean) {\r\n    this.isInsertionEffectsZone = value;\r\n  }\r\n\r\n  getIsUpdateZone() {\r\n    return this.isUpdateZone;\r\n  }\r\n\r\n  setIsUpdateZone(value: boolean) {\r\n    this.isUpdateZone = value;\r\n  }\r\n\r\n  getIsBatchZone() {\r\n    return this.isBatchZone;\r\n  }\r\n\r\n  setIsBatchZone(value: boolean) {\r\n    this.isBatchZone = value;\r\n  }\r\n\r\n  getIsHydrateZone() {\r\n    return this.isHydrateZone;\r\n  }\r\n\r\n  setIsHydrateZone(value: boolean) {\r\n    this.isHydrateZone = value;\r\n  }\r\n\r\n  getIsStreamZone() {\r\n    return this.isStreamZone;\r\n  }\r\n\r\n  setIsStreamZone(value: boolean) {\r\n    this.isStreamZone = value;\r\n  }\r\n\r\n  getIsTransitionZone() {\r\n    return this.isTransitionZone;\r\n  }\r\n\r\n  setIsTransitionZone(value: boolean) {\r\n    this.isTransitionZone = value;\r\n  }\r\n\r\n  getIsEventZone() {\r\n    return this.isEventZone;\r\n  }\r\n\r\n  setIsEventZone(value: boolean) {\r\n    this.isEventZone = value;\r\n  }\r\n\r\n  getIsHot() {\r\n    return this.isHot;\r\n  }\r\n\r\n  setIsHot(value: boolean) {\r\n    this.isHot = value;\r\n  }\r\n\r\n  getPendingStatusSetter() {\r\n    return this.setPendingStatus;\r\n  }\r\n\r\n  setPendingStatusSetter(fn: SetPendingStatus) {\r\n    this.setPendingStatus = fn;\r\n  }\r\n\r\n  flush() {\r\n    !this.isUpdateZone && this.setRoot(this.wip); // !\r\n    this.setWorkInProgress(null);\r\n    this.setNextUnitOfWork(null);\r\n    this.setCursorFiber(null);\r\n    this.resetMount();\r\n    this.resetCandidates();\r\n    this.resetDeletions();\r\n    this.resetCancels();\r\n    this.resetInsertionEffects();\r\n    this.resetLayoutEffects();\r\n    this.resetAsyncEffects();\r\n    this.setIsHydrateZone(false);\r\n    this.setIsUpdateZone(false);\r\n    this.resetActions();\r\n  }\r\n\r\n  getEmitter() {\r\n    return this.emitter;\r\n  }\r\n}\r\n\r\ntype Actions = Record<\r\n  number,\r\n  {\r\n    map: Record<ElementKey, Fiber>;\r\n    replace: Record<ElementKey, true>;\r\n    insert: Record<ElementKey, true>;\r\n    remove: Record<ElementKey, true>;\r\n    move: Record<ElementKey, true>;\r\n    stable: Record<ElementKey, true>;\r\n  }\r\n>;\r\n\r\nlet rootId: number = null;\r\nconst scopes = new Map<number, Scope>();\r\n\r\nconst getRootId = () => rootId;\r\n\r\nconst setRootId = (id: number) => {\r\n  rootId = id;\r\n  !scopes.has(rootId) && scopes.set(rootId, new Scope());\r\n};\r\n\r\nconst removeScope = (id: number) => scopes.delete(id);\r\n\r\nconst replaceScope = (scope: Scope, id: number = rootId) => {\r\n  Object.assign(scopes.get(id), scope);\r\n};\r\n\r\nconst $$scope = (id: number = rootId) => scopes.get(id);\r\n\r\nexport { type Scope, getRootId, setRootId, removeScope, replaceScope, $$scope };\r\n","import { type Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { dropEffects } from '../use-effect';\r\nimport { dropLayoutEffects } from '../use-layout-effect';\r\nimport { dropInsertionEffects } from '../use-insertion-effect';\r\nimport { walk } from '../walk';\r\nimport { detectIsUndefined } from '../utils';\r\nimport { removeScope, $$scope } from '../scope';\r\nimport {\r\n  INSERTION_EFFECT_HOST_MASK,\r\n  LAYOUT_EFFECT_HOST_MASK,\r\n  ASYNC_EFFECT_HOST_MASK,\r\n  ATOM_HOST_MASK,\r\n  PORTAL_HOST_MASK,\r\n} from '../constants';\r\n\r\nconst combinedMask =\r\n  INSERTION_EFFECT_HOST_MASK | LAYOUT_EFFECT_HOST_MASK | ASYNC_EFFECT_HOST_MASK | ATOM_HOST_MASK | PORTAL_HOST_MASK;\r\n\r\nconst shouldUnmountFiber = (fiber: Fiber) => fiber.mask & combinedMask;\r\n\r\nfunction unmountFiber(fiber: Fiber) {\r\n  if (!shouldUnmountFiber(fiber)) return;\r\n  walk(fiber, (fiber, skip) => {\r\n    if (!shouldUnmountFiber(fiber)) return skip();\r\n\r\n    if (fiber.hook && fiber.hook.values.length > 0) {\r\n      fiber.mask & INSERTION_EFFECT_HOST_MASK && dropInsertionEffects(fiber.hook);\r\n      fiber.mask & LAYOUT_EFFECT_HOST_MASK && dropLayoutEffects(fiber.hook);\r\n      fiber.mask & ASYNC_EFFECT_HOST_MASK && dropEffects(fiber.hook);\r\n    }\r\n\r\n    if (fiber.atoms) {\r\n      for (const [_, cleanup] of fiber.atoms) {\r\n        cleanup();\r\n      }\r\n      fiber.atoms = null;\r\n    }\r\n\r\n    fiber.mask & PORTAL_HOST_MASK && platform.unmountPortal(fiber);\r\n  });\r\n}\r\n\r\nfunction unmountRoot(rootId: number, onCompleted: () => void) {\r\n  if (detectIsUndefined(rootId)) return;\r\n  const $scope = $$scope(rootId);\r\n\r\n  unmountFiber($scope.getRoot());\r\n  $scope.unsubscribeEvents();\r\n  removeScope(rootId);\r\n  onCompleted();\r\n}\r\n\r\nexport { unmountFiber, unmountRoot };\r\n","import { useMemo } from '../use-memo';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const value = useMemo(() => callback, deps);\r\n\r\n  return value;\r\n}\r\n\r\nexport { useCallback };\r\n","export type DropEffect = void | (() => void);\r\n\r\nexport type Effect = () => DropEffect;\r\n\r\nexport enum EffectType {\r\n  ASYNC = 'ASYNC',\r\n  LAYOUT = 'LAYOUT',\r\n  INSERTION = 'INSERTION',\r\n}\r\n","import { detectIsFunction } from '../utils';\r\nimport { INSERTION_EFFECT_HOST_MASK, LAYOUT_EFFECT_HOST_MASK, ASYNC_EFFECT_HOST_MASK } from '../constants';\r\nimport { $$scope } from '../scope';\r\nimport { useMemo } from '../use-memo';\r\nimport { type Hook, type HookValue } from '../fiber';\r\nimport { type Effect, type DropEffect, EffectType } from './types';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\nconst { useEffect, dropEffects } = createEffect($$useEffect, EffectType.ASYNC);\r\n\r\ntype UseEffectValue = {\r\n  token: Symbol;\r\n  cleanup: DropEffect;\r\n};\r\n\r\nfunction createEffect(token: Symbol, type: EffectType) {\r\n  function useEffect(effect: Effect, deps: Array<any> = [{}]) {\r\n    const $scope = $$scope();\r\n    const fiber = $scope.getCursorFiber();\r\n    const scope = useMemo<UseEffectValue>(() => ({ token, cleanup: undefined }), []);\r\n    const isInsertionEffect = type === EffectType.INSERTION;\r\n    const isLayoutEffect = type === EffectType.LAYOUT;\r\n    const isAsyncEffect = type === EffectType.ASYNC;\r\n\r\n    isInsertionEffect && fiber.markHost(INSERTION_EFFECT_HOST_MASK);\r\n    isLayoutEffect && fiber.markHost(LAYOUT_EFFECT_HOST_MASK);\r\n    isAsyncEffect && fiber.markHost(ASYNC_EFFECT_HOST_MASK);\r\n\r\n    useMemo(() => {\r\n      const runEffect = () => (scope.cleanup = effect());\r\n\r\n      isInsertionEffect && $scope.addInsertionEffect(runEffect);\r\n      isLayoutEffect && $scope.addLayoutEffect(runEffect);\r\n      isAsyncEffect && $scope.addAsyncEffect(runEffect);\r\n\r\n      detectIsFunction(scope.cleanup) && scope.cleanup();\r\n\r\n      return null;\r\n    }, deps);\r\n  }\r\n\r\n  function dropEffects(hook: Hook<HookValue<UseEffectValue>>) {\r\n    for (const { value: effect } of hook.values) {\r\n      effect && effect.token === token && detectIsFunction(effect.cleanup) && effect.cleanup();\r\n    }\r\n  }\r\n\r\n  return {\r\n    useEffect,\r\n    dropEffects,\r\n  };\r\n}\r\n\r\nexport { useEffect, dropEffects, createEffect };\r\n","import { createEffect, EffectType } from '../use-effect';\r\n\r\nconst $$useInsertionEffect = Symbol('use-insertion-effect');\r\nconst { useEffect: useInsertionEffect, dropEffects: dropInsertionEffects } = createEffect(\r\n  $$useInsertionEffect,\r\n  EffectType.INSERTION,\r\n);\r\n\r\nexport { useInsertionEffect, dropInsertionEffects };\r\n","import { createEffect, EffectType } from '../use-effect';\r\n\r\nconst $$useLayoutEffect = Symbol('use-layout-effect');\r\nconst { useEffect: useLayoutEffect, dropEffects: dropLayoutEffects } = createEffect(\r\n  $$useLayoutEffect,\r\n  EffectType.LAYOUT,\r\n);\r\n\r\nexport { useLayoutEffect, dropLayoutEffects };\r\n","import {\r\n  type ComponentFactory,\r\n  type StandardComponentProps,\r\n  type ShouldUpdate,\r\n  type ComponentInject,\r\n  $$inject,\r\n} from '../component';\r\nimport type { SlotProps, RefProps } from '../shared';\r\nimport { $$memo } from './utils';\r\n\r\nconst defaultShouldUpdate = (props: {}, nextProps: {}): boolean => {\r\n  const keys = Object.keys(nextProps);\r\n\r\n  for (const key of keys) {\r\n    if (key !== 'slot' && nextProps[key] !== props[key]) return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nfunction memo<P extends object, R = unknown>(\r\n  factory: ComponentFactory<P, R>,\r\n  shouldUpdate: ShouldUpdate<P & SlotProps> = defaultShouldUpdate,\r\n) {\r\n  type P1 = P & Omit<StandardComponentProps, 'ref'> & RefProps<R>;\r\n\r\n  factory[$$inject] = {\r\n    token: $$memo,\r\n    shouldUpdate,\r\n  } as ComponentInject<P1>;\r\n\r\n  return factory as ComponentFactory<P1, R>;\r\n}\r\n\r\nexport { memo };\r\n","import { type VirtualNodeFactory, detectIsVirtualNodeFactory } from '../view';\r\nimport { type Component, detectIsComponent, component } from '../component';\r\nimport { type Hook, type HookValue } from '../fiber';\r\nimport { detectAreDepsDifferent } from '../utils';\r\nimport { $$scope } from '../scope';\r\nimport { memo } from '../memo';\r\n\r\ntype GetMemoValue = () => Component | VirtualNodeFactory;\r\n\r\ntype MemoProps = {\r\n  deps: Array<any>;\r\n  getValue: GetMemoValue;\r\n};\r\n\r\nconst Memo = memo(\r\n  component<MemoProps>(({ getValue }) => getValue()),\r\n  (p, n) => detectAreDepsDifferent(p.deps, n.deps),\r\n);\r\n\r\nfunction detectIsElement<T>(value: T) {\r\n  return detectIsComponent(value) || detectIsVirtualNodeFactory(value);\r\n}\r\n\r\nfunction useMemo<T>(getValue: () => T, deps: Array<any>): T {\r\n  const fiber = $$scope().getCursorFiber();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook as Hook<HookValue<T>>;\r\n  const state =\r\n    values[idx] ||\r\n    (values[idx] = {\r\n      deps,\r\n      value: getValue(),\r\n    });\r\n  let value: T = null;\r\n  let $value: T = null;\r\n\r\n  if (detectIsElement(state.value)) {\r\n    value = state.value;\r\n    $value = Memo({ getValue: getValue as GetMemoValue, deps }) as unknown as T;\r\n  } else {\r\n    value = detectAreDepsDifferent(state.deps, deps) ? getValue() : state.value;\r\n    $value = value;\r\n  }\r\n\r\n  state.deps = deps;\r\n  state.value = value;\r\n  hook.idx++;\r\n\r\n  return $value;\r\n}\r\n\r\nexport { useMemo };\r\n","import { detectIsFunction } from '../utils';\r\nimport { type UpdateOptions, useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { $$scope } from '../scope';\r\nimport { useCallback } from '../use-callback';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\n\r\nfunction useState<T = unknown>(initialValue: T | (() => T)): [T, (value: Value<T>) => void] {\r\n  const update = useUpdate();\r\n  const scope = useMemo(\r\n    () => ({\r\n      value: detectIsFunction(initialValue) ? initialValue() : initialValue,\r\n    }),\r\n    [],\r\n  );\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    const $scope = $$scope();\r\n    const isBatch = $scope.getIsBatchZone();\r\n    const create = (): UpdateOptions => {\r\n      const prevValue = scope.value;\r\n      const newValue = detectIsFunction(sourceValue) ? sourceValue(prevValue) : sourceValue;\r\n      const shouldUpdate = () => isBatch || !Object.is(prevValue, newValue);\r\n      const setValue = () => (scope.value = newValue);\r\n      const resetValue = () => (scope.value = prevValue);\r\n\r\n      return { shouldUpdate, setValue, resetValue };\r\n    };\r\n\r\n    update(create);\r\n  }, []);\r\n\r\n  return [scope.value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { type ScheduleCallbackOptions, scheduler } from '../scheduler';\r\nimport { type UpdateChanger, createUpdate } from '../workloop';\r\nimport { getRootId, $$scope } from '../scope';\r\nimport { TaskPriority } from '../constants';\r\nimport { addBatch } from '../batch';\r\nimport { detectIsFunction } from '../utils';\r\nimport { createHookLocation } from '../walk';\r\n\r\nexport type UpdateOptions = UpdateChanger;\r\n\r\nfunction useUpdate() {\r\n  const rootId = getRootId();\r\n  const fiber = $$scope().getCursorFiber();\r\n  const hook = fiber.hook; // !\r\n  const { idx } = hook;\r\n  const update = (createChanger?: () => UpdateChanger) => {\r\n    const $scope = $$scope();\r\n    if ($scope.getIsInsertionEffectsZone()) return;\r\n    const { owner } = hook;\r\n    const hasChanger = detectIsFunction(createChanger);\r\n    const isTransition = $scope.getIsTransitionZone();\r\n    const isBatch = $scope.getIsBatchZone();\r\n    const isEvent = $scope.getIsEventZone();\r\n    const priority = isTransition ? TaskPriority.LOW : isEvent ? TaskPriority.HIGH : TaskPriority.NORMAL; // !\r\n    const forceAsync = isTransition;\r\n    const setPendingStatus = $scope.getPendingStatusSetter();\r\n    const callback = createUpdate({\r\n      rootId,\r\n      hook,\r\n      isTransition,\r\n      createChanger: hasChanger ? createChanger : undefined,\r\n    });\r\n    const createLocation = () => createHookLocation(rootId, idx, owner);\r\n    const callbackOptions: ScheduleCallbackOptions = {\r\n      priority,\r\n      forceAsync,\r\n      isTransition,\r\n      createLocation,\r\n      setPendingStatus,\r\n    };\r\n\r\n    if (isBatch) {\r\n      addBatch(\r\n        owner,\r\n        () => scheduler.schedule(callback, callbackOptions),\r\n        () => hasChanger && createChanger().setValue(),\r\n      );\r\n    } else {\r\n      scheduler.schedule(callback, callbackOptions);\r\n    }\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { $$scope } from '../scope';\r\nimport { type Fiber } from '../fiber';\r\nimport { type Callback } from '../shared';\r\n\r\nfunction batch(callback: () => void) {\r\n  const $scope = $$scope();\r\n\r\n  $scope.setIsBatchZone(true);\r\n  callback();\r\n  $scope.setIsBatchZone(false);\r\n}\r\n\r\nfunction addBatch(fiber: Fiber, callback: Callback, change: Callback) {\r\n  const $scope = $$scope();\r\n\r\n  if ($scope.getIsTransitionZone()) {\r\n    callback();\r\n  } else {\r\n    const batch = fiber.batch || { timer: null, changes: [] };\r\n\r\n    fiber.batch = batch;\r\n    batch.changes.push(change);\r\n    batch.timer && clearTimeout(batch.timer);\r\n    batch.timer = setTimeout(() => {\r\n      batch.changes.splice(-1);\r\n      batch.changes.forEach(x => x());\r\n      fiber.batch = null;\r\n      callback();\r\n    });\r\n  }\r\n}\r\n\r\nexport { batch, addBatch };\r\n","import type { NestedArray } from '../shared';\r\nimport { INDEX_KEY } from '../constants';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\n\r\nconst detectIsUndefined = (o: any): o is undefined => typeof o === 'undefined';\r\n\r\nconst detectIsNumber = (o: any): o is number => typeof o === 'number';\r\n\r\nconst detectIsString = (o: any): o is string => typeof o === 'string';\r\n\r\nconst detectIsTextBased = (o: any): o is string | number => typeof o === 'string' || typeof o === 'number';\r\n\r\nconst detectIsObject = (o: any): o is object => typeof o === 'object';\r\n\r\nconst detectIsBoolean = (o: any): o is boolean => typeof o === 'boolean';\r\n\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\n\r\nconst detectIsNull = (o: any): o is null => o === null;\r\n\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nconst detectIsFalsy = (o: any) => detectIsEmpty(o) || o === false;\r\n\r\nconst getTime = () => Date.now();\r\n\r\nconst dummyFn = () => {};\r\n\r\nconst trueFn = () => true;\r\n\r\nconst falseFn = () => false;\r\n\r\nconst sameFn = <T = any>(x: T) => x;\r\n\r\nconst error = (...args: Array<any>) => !detectIsUndefined(console) && console.error(...args);\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>, transform: (x: T) => any = sameFn): Array<T> {\r\n  if (detectIsArray(source)) {\r\n    if (source.length === 0) return [];\r\n  } else {\r\n    return [transform(source)];\r\n  }\r\n  const list: Array<T> = [];\r\n  const stack = [source[0]];\r\n  let idx = 0;\r\n\r\n  while (stack.length > 0) {\r\n    const x = stack.pop();\r\n\r\n    if (detectIsArray(x)) {\r\n      for (let i = x.length - 1; i >= 0; i--) {\r\n        stack.push(x[i]);\r\n      }\r\n    } else {\r\n      list.push(transform(x));\r\n\r\n      if (stack.length === 0 && idx < source.length - 1) {\r\n        idx++;\r\n        stack.push(source[idx]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction detectAreDepsDifferent(prevDeps: Array<unknown>, nextDeps: Array<unknown>): boolean {\r\n  if (prevDeps === nextDeps) return false;\r\n  const max = Math.max(prevDeps.length, nextDeps.length);\r\n\r\n  for (let i = 0; i < max; i++) {\r\n    if (!Object.is(prevDeps[i], nextDeps[i])) return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nconst nextTick = (callback: () => void) => {\r\n  Promise.resolve().then(callback);\r\n};\r\n\r\nconst createIndexKey = (idx: number) => `${INDEX_KEY}:${idx}`;\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsTextBased,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  getTime,\r\n  dummyFn,\r\n  trueFn,\r\n  falseFn,\r\n  error,\r\n  flatten,\r\n  keyBy,\r\n  detectAreDepsDifferent,\r\n  nextTick,\r\n  createIndexKey,\r\n};\r\n","import { SlotProps, RefProps, KeyProps, FlagProps } from '../shared';\r\n\r\nexport type ViewOptions = {\r\n  as: string;\r\n  _void?: boolean;\r\n  [prop: string]: any;\r\n} & Partial<SlotProps> &\r\n  RefProps &\r\n  KeyProps &\r\n  FlagProps;\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import { REPLACER, KEY_ATTR } from '../constants';\r\nimport { detectIsArray, detectIsFunction } from '../utils';\r\nimport { type ElementKey, type DarkElement, type Instance } from '../shared';\r\nimport { type Component, detectIsComponent, getComponentKey, hasComponentFlag } from '../component';\r\nimport { $$scope } from '../scope';\r\nimport { NodeType, type ViewOptions } from './types';\r\n\r\nconst $$vNode = Symbol('vNode');\r\nconst ATTR_TYPE = 'type';\r\n\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(type: NodeType) {\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public name: string;\r\n  public attrs: Record<string, any>;\r\n  public children: Array<TextVirtualNode | CommentVirtualNode | TagVirtualNode | VirtualNodeFactory | Component>;\r\n\r\n  constructor(name: string, attrs: TagVirtualNode['attrs'], children: TagVirtualNode['children']) {\r\n    super(NodeType.TAG);\r\n    this.name = name;\r\n    this.attrs = attrs;\r\n    this.children = children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public value: string;\r\n\r\n  constructor(source: TextSource) {\r\n    super(NodeType.TEXT);\r\n    this.value = String(source);\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.COMMENT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nfunction View(options: ViewOptions) {\r\n  const factory: TagVirtualNodeFactory = () => {\r\n    const { as: name, slot, _void = false, ...attrs } = options;\r\n    const children = (_void ? [] : detectIsArray(slot) ? slot : slot ? [slot] : []) as TagVirtualNode['children'];\r\n\r\n    return new TagVirtualNode(name, attrs, children);\r\n  };\r\n\r\n  factory[$$vNode] = true;\r\n  factory[ATTR_TYPE] = options.as;\r\n  factory[KEY_ATTR] = options.key;\r\n\r\n  return factory;\r\n}\r\n\r\nconst Text = (source: TextSource) => new TextVirtualNode(source);\r\n\r\nText.from = (source: DarkElement) => (detectIsTextVirtualNode(source) ? source.value : source + '');\r\n\r\nconst Comment = (text: string) => new CommentVirtualNode(text);\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\n\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\n\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\n\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$vNode] === true;\r\n\r\nconst getTagVirtualNodeKey = (vNode: TagVirtualNode): ElementKey | null =>\r\n  vNode.attrs ? vNode.attrs[KEY_ATTR] ?? null : null;\r\n\r\nconst hasTagVirtualNodeFlag = (vNode: TagVirtualNode, flag: string) => Boolean(vNode.attrs && vNode.attrs[flag]);\r\n\r\nconst getVirtualNodeFactoryKey = (factory: VirtualNodeFactory): ElementKey | null => factory[KEY_ATTR] ?? null;\r\n\r\nconst hasVirtualNodeFactoryFlag = (factory: VirtualNodeFactory, flag: string) => Boolean(factory[flag]);\r\n\r\nconst detectIsPlainVirtualNode = (vNode: unknown): vNode is PlainVirtualNode =>\r\n  detectIsTextVirtualNode(vNode) || detectIsCommentVirtualNode(vNode);\r\n\r\nconst createReplacer = () => new CommentVirtualNode(REPLACER);\r\n\r\nconst detectIsReplacer = (vNode: unknown) => detectIsCommentVirtualNode(vNode) && vNode.value === REPLACER;\r\n\r\nfunction getElementKey(inst: Instance): ElementKey | null {\r\n  return detectIsComponent(inst)\r\n    ? getComponentKey(inst)\r\n    : detectIsVirtualNodeFactory(inst)\r\n    ? getVirtualNodeFactoryKey(inst)\r\n    : detectIsTagVirtualNode(inst)\r\n    ? getTagVirtualNodeKey(inst)\r\n    : null;\r\n}\r\n\r\nfunction hasElementFlag(inst: Instance, flag: string) {\r\n  return detectIsComponent(inst)\r\n    ? hasComponentFlag(inst, flag)\r\n    : detectIsVirtualNodeFactory(inst)\r\n    ? hasVirtualNodeFactoryFlag(inst, flag)\r\n    : detectIsTagVirtualNode(inst)\r\n    ? hasTagVirtualNodeFlag(inst, flag)\r\n    : false;\r\n}\r\n\r\nfunction getElementType(inst: Instance): string | Function {\r\n  return detectIsComponent(inst)\r\n    ? inst.type\r\n    : detectIsVirtualNodeFactory(inst)\r\n    ? inst[ATTR_TYPE]\r\n    : detectIsTagVirtualNode(inst)\r\n    ? inst.name\r\n    : detectIsVirtualNode(inst)\r\n    ? inst.type\r\n    : null;\r\n}\r\n\r\nfunction hasChildrenProp(inst: Instance): inst is TagVirtualNode | Component {\r\n  return detectIsTagVirtualNode(inst) || detectIsComponent(inst);\r\n}\r\n\r\nfunction detectAreSameInstanceTypes(prevInst: Instance, nextInst: Instance, isComponentFactories = false) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (process.env.NODE_ENV === 'development' && $$scope().getIsHot()) {\r\n      if (detectIsComponent(prevInst) && detectIsComponent(nextInst)) {\r\n        return prevInst.displayName === nextInst.displayName;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isComponentFactories) {\r\n    const pc = prevInst as Component;\r\n    const nc = nextInst as Component;\r\n\r\n    return pc.type === nc.type;\r\n  }\r\n\r\n  return getElementType(prevInst) === getElementType(nextInst);\r\n}\r\n\r\nfunction detectAreSameComponentTypesWithSameKeys(prevInst: Instance | null, nextInst: Instance | null) {\r\n  if (\r\n    prevInst &&\r\n    nextInst &&\r\n    detectIsComponent(prevInst) &&\r\n    detectIsComponent(nextInst) &&\r\n    detectAreSameInstanceTypes(prevInst, nextInst, true)\r\n  ) {\r\n    return getElementKey(prevInst) === getElementKey(nextInst);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\ntype TextSource = string | number;\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type PlainVirtualNode = TextVirtualNode | CommentVirtualNode;\r\n\r\nexport {\r\n  View,\r\n  Text,\r\n  Comment,\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  createReplacer,\r\n  detectIsReplacer,\r\n  getElementKey,\r\n  hasElementFlag,\r\n  getElementType,\r\n  hasChildrenProp,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsPlainVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  detectAreSameInstanceTypes,\r\n  detectAreSameComponentTypesWithSameKeys,\r\n};\r\n","import {\r\n  DELETE_EFFECT_TAG,\r\n  UPDATE_EFFECT_TAG,\r\n  SKIP_EFFECT_TAG,\r\n  INSERTION_EFFECT_HOST_MASK,\r\n  LAYOUT_EFFECT_HOST_MASK,\r\n  ASYNC_EFFECT_HOST_MASK,\r\n  ATOM_HOST_MASK,\r\n  PORTAL_HOST_MASK,\r\n  MOVE_MASK,\r\n  HOOK_DELIMETER,\r\n} from '../constants';\r\nimport { Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { type TagVirtualNode, getElementKey, hasChildrenProp } from '../view';\r\nimport { type Scope } from '../scope';\r\nimport { type Component } from '../component';\r\nimport { detectIsMemo } from '../memo/utils';\r\nimport { type Instance, type ElementKey } from '../shared';\r\nimport { createIndexKey } from '../utils';\r\n\r\nfunction walk<T = unknown>(fiber: Fiber<T>, onWalk: (fiber: Fiber<T>, skip: () => void, stop: () => void) => void) {\r\n  let shouldDeep = true;\r\n  let shouldStop = false;\r\n  const skip = () => (shouldDeep = false);\r\n  const stop = () => (shouldStop = true);\r\n  const stack: Array<Fiber<T>> = [fiber];\r\n\r\n  while (stack.length !== 0) {\r\n    const unit = stack.pop();\r\n\r\n    onWalk(unit, skip, stop);\r\n    if (shouldStop) break;\r\n    unit !== fiber && unit.next && stack.push(unit.next);\r\n    shouldDeep && unit.child && stack.push(unit.child);\r\n    shouldDeep = true;\r\n  }\r\n}\r\n\r\nfunction collectElements<T, P = T>(fiber: Fiber<T>, transform: (fiber: Fiber<T>) => P): Array<P> {\r\n  const elements: Array<P> = [];\r\n\r\n  walk<T>(fiber, (fiber, skip) => {\r\n    if (fiber.element) {\r\n      !platform.detectIsPortal(fiber.inst) && elements.push(transform(fiber));\r\n      return skip();\r\n    }\r\n  });\r\n\r\n  return elements;\r\n}\r\n\r\nfunction getFiberWithElement<T1, T2 = T1>(fiber: Fiber<T1>): Fiber<T2> {\r\n  let $fiber = fiber as unknown as Fiber<T2>;\r\n\r\n  while ($fiber) {\r\n    if ($fiber.element) return $fiber;\r\n    $fiber = $fiber.parent;\r\n  }\r\n\r\n  return $fiber;\r\n}\r\n\r\nfunction detectIsFiberAlive(fiber: Fiber) {\r\n  let $fiber = fiber;\r\n\r\n  while ($fiber) {\r\n    if ($fiber.tag === DELETE_EFFECT_TAG) return false;\r\n    $fiber = $fiber.parent;\r\n  }\r\n\r\n  return Boolean(fiber);\r\n}\r\n\r\nfunction createHookLocation(rootId: number, idx: number, fiber: Fiber) {\r\n  let $fiber = fiber;\r\n  let loc = `${fiber.idx}${HOOK_DELIMETER}${idx}`;\r\n\r\n  while ($fiber) {\r\n    $fiber = $fiber.parent;\r\n    $fiber && (loc = `${$fiber.idx}.${loc}`);\r\n  }\r\n\r\n  loc = `[${rootId}]${loc}`;\r\n\r\n  return loc;\r\n}\r\n\r\nfunction detectIsStableMemoTree(fiber: Fiber, $scope: Scope) {\r\n  if (!hasChildrenProp(fiber.inst)) return;\r\n  const actions = $scope.getActionsById(fiber.id);\r\n  const children = fiber.inst.children;\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const inst = children[i];\r\n    const key = getElementKey(inst);\r\n    if (key === null) return false;\r\n    const alt = actions.map[key];\r\n    if (!alt) return false;\r\n    const pc = alt.inst as Component;\r\n    const nc = inst as Component;\r\n    const isStable =\r\n      detectIsMemo(nc) && detectIsMemo(pc) && nc.type === pc.type && !nc.shouldUpdate(pc.props, nc.props);\r\n\r\n    if (!isStable) return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction tryOptStaticSlot(fiber: Fiber, alt: Fiber, $scope: Scope) {\r\n  const actions = $scope.getActionsById(fiber.id);\r\n  const inst = fiber.inst as Component | TagVirtualNode;\r\n\r\n  alt.element && (fiber.element = alt.element); //!\r\n\r\n  for (let i = 0; i < inst.children.length; i++) {\r\n    buildChildNode(inst.children, fiber, actions.map, i, fiber.eidx);\r\n  }\r\n\r\n  fiber.cc = inst.children.length;\r\n  $scope.setMountDeep(false);\r\n}\r\n\r\nfunction tryOptMemoSlot(fiber: Fiber, alt: Fiber, $scope: Scope) {\r\n  const actions = $scope.getActionsById(fiber.id);\r\n  const hasMove = Boolean(actions.move);\r\n  const hasRemove = Boolean(actions.remove);\r\n  const hasInsert = Boolean(actions.insert);\r\n  const hasReplace = Boolean(actions.insert);\r\n  const canOptimize = ((hasMove && !hasRemove) || (hasRemove && !hasMove)) && !hasInsert && !hasReplace;\r\n\r\n  if (!canOptimize || !detectIsStableMemoTree(fiber, $scope)) return;\r\n\r\n  hasMove && tryOptMov(fiber, alt, $scope);\r\n  hasRemove && tryOptRem(fiber, alt, $scope);\r\n}\r\n\r\nfunction tryOptMov(fiber: Fiber, alt: Fiber, $scope: Scope) {\r\n  const actions = $scope.getActionsById(fiber.id);\r\n\r\n  buildChildNodes(fiber, alt, $scope, (fiber, key) => {\r\n    if (!actions.move[key]) return;\r\n    fiber.alt = new Fiber().mutate(fiber);\r\n    fiber.tag = UPDATE_EFFECT_TAG;\r\n    fiber.mask |= MOVE_MASK;\r\n    $scope.addCandidate(fiber);\r\n  });\r\n}\r\n\r\nfunction tryOptRem(fiber: Fiber, alt: Fiber, $scope: Scope) {\r\n  buildChildNodes(fiber, alt, $scope);\r\n}\r\n\r\nfunction buildChildNodes(fiber: Fiber, alt: Fiber, $scope: Scope, onNode?: (fiber: Fiber, key: ElementKey) => void) {\r\n  const actions = $scope.getActionsById(fiber.id);\r\n  const inst = fiber.inst as Component | TagVirtualNode;\r\n  const children = inst.children;\r\n\r\n  alt.element && (fiber.element = alt.element); //!\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const key = getKey(children[i], i);\r\n    const $fiber = actions.map[key];\r\n\r\n    buildChildNode(children, fiber, actions.map, i, fiber.eidx);\r\n    onNode && onNode($fiber, key);\r\n  }\r\n\r\n  fiber.cc = children.length;\r\n  $scope.setMountDeep(false);\r\n}\r\n\r\nfunction buildChildNode(\r\n  children: Array<Instance>,\r\n  parent: Fiber,\r\n  altMap: Record<string, Fiber>,\r\n  idx: number,\r\n  startEidx: number,\r\n) {\r\n  const prevIdx = idx - 1;\r\n  const nextIdx = idx + 1;\r\n  const key = getKey(children[idx], idx);\r\n  const prevKey = getKey(children[prevIdx], prevIdx);\r\n  const nextKey = getKey(children[nextIdx], nextIdx);\r\n  const fiber = altMap[key];\r\n  const left = altMap[prevKey];\r\n  const right = altMap[nextKey];\r\n  const isFirst = idx === 0;\r\n  const isLast = idx === children.length - 1;\r\n\r\n  isFirst && (parent.child = fiber);\r\n  fiber.alt = null;\r\n  fiber.parent = parent;\r\n  fiber.tag = SKIP_EFFECT_TAG;\r\n  fiber.idx = idx;\r\n  left ? (fiber.eidx = left.eidx + (left.element ? 1 : left.cec)) : (fiber.eidx = startEidx);\r\n  right && (fiber.next = right);\r\n  isLast && (fiber.next = null);\r\n  notifyParents(fiber);\r\n}\r\n\r\nfunction getKey(inst: Instance, idx: number) {\r\n  const key = getElementKey(inst);\r\n  return key !== null ? key : createIndexKey(idx);\r\n}\r\n\r\nfunction notifyParents(fiber: Fiber, alt: Fiber = fiber) {\r\n  fiber.increment(alt.element ? 1 : alt.cec);\r\n  alt.mask & INSERTION_EFFECT_HOST_MASK && fiber.markHost(INSERTION_EFFECT_HOST_MASK);\r\n  alt.mask & LAYOUT_EFFECT_HOST_MASK && fiber.markHost(LAYOUT_EFFECT_HOST_MASK);\r\n  alt.mask & ASYNC_EFFECT_HOST_MASK && fiber.markHost(ASYNC_EFFECT_HOST_MASK);\r\n  alt.mask & ATOM_HOST_MASK && fiber.markHost(ATOM_HOST_MASK);\r\n  alt.mask & PORTAL_HOST_MASK && fiber.markHost(PORTAL_HOST_MASK);\r\n}\r\n\r\nexport {\r\n  walk,\r\n  collectElements,\r\n  getFiberWithElement,\r\n  detectIsFiberAlive,\r\n  createHookLocation,\r\n  tryOptStaticSlot,\r\n  tryOptMemoSlot,\r\n  notifyParents,\r\n};\r\n","import { platform, detectIsServer } from '../platform';\r\nimport {\r\n  CREATE_EFFECT_TAG,\r\n  UPDATE_EFFECT_TAG,\r\n  DELETE_EFFECT_TAG,\r\n  SKIP_EFFECT_TAG,\r\n  INSERTION_EFFECT_HOST_MASK,\r\n  LAYOUT_EFFECT_HOST_MASK,\r\n  ASYNC_EFFECT_HOST_MASK,\r\n  ATOM_HOST_MASK,\r\n  PORTAL_HOST_MASK,\r\n  MOVE_MASK,\r\n  FLUSH_MASK,\r\n  SHADOW_MASK,\r\n  RESTART_TIMEOUT,\r\n  Flag,\r\n} from '../constants';\r\nimport {\r\n  flatten,\r\n  error,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  detectIsArray,\r\n  detectIsFunction,\r\n  detectIsTextBased,\r\n  createIndexKey,\r\n  trueFn,\r\n} from '../utils';\r\nimport { type Scope, setRootId, $$scope, replaceScope } from '../scope';\r\nimport { Fiber, getHook, Hook } from '../fiber';\r\nimport { type ElementKey, type Instance } from '../shared';\r\nimport { type Component, detectIsComponent } from '../component';\r\nimport {\r\n  Text,\r\n  detectIsVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  getElementKey,\r\n  hasElementFlag,\r\n  hasChildrenProp,\r\n  detectIsReplacer,\r\n  createReplacer,\r\n  detectAreSameInstanceTypes,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo/utils';\r\nimport { detectIsLazy, detectIsLoaded } from '../lazy/utils';\r\nimport {\r\n  walk,\r\n  getFiberWithElement,\r\n  detectIsFiberAlive,\r\n  notifyParents,\r\n  tryOptStaticSlot,\r\n  tryOptMemoSlot,\r\n} from '../walk';\r\nimport { unmountFiber } from '../unmount';\r\nimport { Fragment, detectIsFragment } from '../fragment';\r\nimport { type RestoreOptions, scheduler } from '../scheduler';\r\n\r\nlet hasRenderError = false;\r\n\r\nexport type WorkLoop = (isAsync: boolean) => boolean;\r\n\r\nfunction workLoop(isAsync: boolean) {\r\n  if (hasRenderError) return false;\r\n  const $scope = $$scope();\r\n  const wipFiber = $scope.getWorkInProgress();\r\n  let unit = $scope.getNextUnitOfWork();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(unit);\r\n\r\n  try {\r\n    while (unit && !shouldYield) {\r\n      unit = performUnitOfWork(unit, $scope);\r\n      $scope.setNextUnitOfWork(unit);\r\n      hasMoreWork = Boolean(unit);\r\n      shouldYield = isAsync && scheduler.shouldYield();\r\n      if (shouldYield && scheduler.hasPrimaryTask()) return fork($scope);\r\n    }\r\n\r\n    if (!unit && wipFiber) {\r\n      commit($scope);\r\n    }\r\n  } catch (err) {\r\n    if (err instanceof StopWork) {\r\n      !isAsync && setTimeout(() => workLoop(false), RESTART_TIMEOUT);\r\n    } else {\r\n      hasRenderError = true;\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber, $scope: Scope): Fiber | null {\r\n  const wipFiber = $scope.getWorkInProgress();\r\n  const isDeepWalking = $scope.getMountDeep();\r\n  const isStream = $scope.getIsStreamZone();\r\n  const hasChildren = isDeepWalking && hasChildrenProp(fiber.inst) && fiber.inst.children.length > 0;\r\n\r\n  fiber.hook && (fiber.hook.idx = 0);\r\n\r\n  if (hasChildren) {\r\n    const child = mountChild(fiber, $scope);\r\n\r\n    isStream && platform.chunk(child);\r\n\r\n    return child;\r\n  } else {\r\n    while (fiber.parent && fiber !== wipFiber) {\r\n      const next = mountSibling(fiber, $scope);\r\n\r\n      isStream && platform.chunk(fiber);\r\n\r\n      if (next) {\r\n        isStream && platform.chunk(next);\r\n        return next;\r\n      }\r\n\r\n      fiber = fiber.parent;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction mountChild(parent: Fiber, $scope: Scope) {\r\n  $scope.navToChild();\r\n  const $inst = parent.inst;\r\n  const idx = 0;\r\n  const inst = hasChildrenProp($inst) ? $inst.children[idx] : null;\r\n  const alt = getAlternate(parent, inst, true, $scope);\r\n  const fiber = createFiber(alt, inst, idx);\r\n\r\n  fiber.parent = parent;\r\n  parent.child = fiber;\r\n  fiber.eidx = parent.element ? 0 : parent.eidx;\r\n\r\n  share(fiber, inst, $scope);\r\n\r\n  return fiber;\r\n}\r\n\r\nfunction mountSibling(left: Fiber, $scope: Scope) {\r\n  $scope.navToSibling();\r\n  const $inst = left.parent.inst;\r\n  const idx = $scope.getMountIndex();\r\n  const inst = hasChildrenProp($inst) && $inst.children ? $inst.children[idx] : null;\r\n  const hasSibling = Boolean(inst);\r\n\r\n  if (!hasSibling) {\r\n    $scope.navToParent();\r\n    $scope.setMountDeep(false);\r\n\r\n    return null;\r\n  }\r\n\r\n  $scope.setMountDeep(true);\r\n  const alt = getAlternate(left, inst, false, $scope);\r\n  const fiber = createFiber(alt, inst, idx);\r\n\r\n  fiber.parent = left.parent;\r\n  left.next = fiber;\r\n  fiber.eidx = left.eidx + (left.element ? 1 : left.cec);\r\n\r\n  share(fiber, inst, $scope);\r\n\r\n  return fiber;\r\n}\r\n\r\nfunction share(fiber: Fiber, inst: Instance, $scope: Scope) {\r\n  const { alt } = fiber;\r\n  const shouldMount = alt && detectIsMemo(inst) ? shouldUpdate(fiber, inst, $scope) : true;\r\n\r\n  $scope.setCursorFiber(fiber);\r\n  fiber.inst = inst;\r\n\r\n  if (alt && alt.mask & MOVE_MASK) {\r\n    fiber.mask |= MOVE_MASK;\r\n    alt.mask &= ~MOVE_MASK;\r\n  }\r\n\r\n  fiber.hook && (fiber.hook.owner = fiber); // !\r\n\r\n  if (shouldMount) {\r\n    fiber.inst = mount(fiber, $scope);\r\n    alt && reconcile(fiber, alt, $scope);\r\n    setup(fiber, alt);\r\n  } else if (fiber.mask & MOVE_MASK) {\r\n    fiber.tag = UPDATE_EFFECT_TAG;\r\n  }\r\n\r\n  $scope.addCandidate(fiber); // !\r\n}\r\n\r\nfunction createFiber(alt: Fiber, inst: Instance, idx: number) {\r\n  const fiber = new Fiber(getHook(alt, alt ? alt.inst : null, inst), alt ? alt.provider : null, idx);\r\n\r\n  fiber.alt = alt || null;\r\n\r\n  return fiber;\r\n}\r\n\r\nfunction getAlternate(fiber: Fiber, inst: Instance, fromChild: boolean, $scope: Scope) {\r\n  const key = getElementKey(inst);\r\n\r\n  if (key !== null) {\r\n    const parentId = fromChild ? fiber.id : fiber.parent.id;\r\n    const actions = $scope.getActionsById(parentId);\r\n\r\n    if (actions) {\r\n      const isMove = actions.move && Boolean(actions.move[key]);\r\n      const isStable = actions.stable && Boolean(actions.stable[key]);\r\n\r\n      if (isMove || isStable) {\r\n        const alt = actions.map[key];\r\n\r\n        isMove && (alt.mask |= MOVE_MASK);\r\n\r\n        return alt;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  const alt = fiber.alt ? (fromChild ? fiber.alt.child || null : fiber.alt.next || null) : null;\r\n\r\n  return alt;\r\n}\r\n\r\nfunction reconcile(fiber: Fiber, alt: Fiber, $scope: Scope) {\r\n  const { id, inst } = fiber;\r\n  const areSameTypes = detectAreSameInstanceTypes(alt.inst, inst);\r\n\r\n  if (!areSameTypes) {\r\n    $scope.addDeletion(alt);\r\n  } else if (hasChildrenProp(alt.inst) && hasChildrenProp(inst) && alt.cc !== 0) {\r\n    const hasSameCount = alt.cc === inst.children.length;\r\n    const check = hasElementFlag(inst, Flag.SKIP_SCAN_OPT) ? !hasSameCount : true;\r\n\r\n    if (check) {\r\n      const { prevKeys, nextKeys, prevKeysMap, nextKeysMap, keyedFibersMap } = extractKeys(alt.child, inst.children);\r\n      const flush = nextKeys.length === 0;\r\n      let size = Math.max(prevKeys.length, nextKeys.length);\r\n      let p = 0;\r\n      let n = 0;\r\n\r\n      $scope.addActionMap(id, keyedFibersMap);\r\n\r\n      for (let i = 0; i < size; i++) {\r\n        const nextKey = nextKeys[i - n] ?? null;\r\n        const prevKey = prevKeys[i - p] ?? null;\r\n        const prevKeyFiber = keyedFibersMap[prevKey] || null;\r\n\r\n        if (nextKey !== prevKey) {\r\n          if (nextKey !== null && !prevKeysMap[nextKey]) {\r\n            if (prevKey !== null && !nextKeysMap[prevKey]) {\r\n              $scope.addReplaceAction(id, nextKey);\r\n              $scope.addDeletion(prevKeyFiber);\r\n            } else {\r\n              $scope.addInsertAction(id, nextKey);\r\n              p++;\r\n              size++;\r\n            }\r\n          } else if (!nextKeysMap[prevKey]) {\r\n            $scope.addRemoveAction(id, prevKey);\r\n            $scope.addDeletion(prevKeyFiber);\r\n            flush && (prevKeyFiber.mask |= FLUSH_MASK);\r\n            n++;\r\n            size++;\r\n          } else if (nextKeysMap[prevKey] && nextKeysMap[nextKey]) {\r\n            $scope.addMoveAction(id, nextKey);\r\n          }\r\n        } else if (nextKey !== null) {\r\n          $scope.addStableAction(id, nextKey);\r\n        }\r\n      }\r\n\r\n      hasElementFlag(inst, Flag.STATIC_SLOT_OPT) && tryOptStaticSlot(fiber, alt, $scope);\r\n      hasElementFlag(inst, Flag.MEMO_SLOT_OPT) && tryOptMemoSlot(fiber, alt, $scope);\r\n    }\r\n  }\r\n}\r\n\r\nfunction setup(fiber: Fiber, alt: Fiber) {\r\n  const inst = fiber.inst;\r\n  let isUpdate = false;\r\n\r\n  fiber.parent.tag === CREATE_EFFECT_TAG && (fiber.tag = fiber.parent.tag);\r\n  fiber.parent.mask & SHADOW_MASK && !fiber.parent.element && !detectIsReplacer(inst) && (fiber.mask |= SHADOW_MASK);\r\n  isUpdate =\r\n    alt &&\r\n    fiber.tag !== CREATE_EFFECT_TAG &&\r\n    detectAreSameInstanceTypes(alt.inst, inst) &&\r\n    getElementKey(alt.inst) === getElementKey(inst);\r\n  isUpdate && !fiber.element && alt.element && (fiber.element = alt.element);\r\n  fiber.tag = isUpdate ? UPDATE_EFFECT_TAG : CREATE_EFFECT_TAG;\r\n  hasChildrenProp(fiber.inst) && (fiber.cc = fiber.inst.children.length);\r\n  !fiber.element && detectIsVirtualNode(fiber.inst) && (fiber.element = platform.createElement(fiber.inst));\r\n  fiber.element && fiber.increment();\r\n}\r\n\r\nfunction shouldUpdate(fiber: Fiber, inst: Instance, $scope: Scope) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if ($scope.getIsHot()) return true;\r\n  }\r\n\r\n  const alt = fiber.alt;\r\n  const pc = alt.inst as Component;\r\n  const nc = inst as Component;\r\n\r\n  if (nc.type !== pc.type || nc.shouldUpdate(pc.props, nc.props)) return true;\r\n\r\n  $scope.setMountDeep(false);\r\n  fiber.tag = SKIP_EFFECT_TAG;\r\n  fiber.child = alt.child;\r\n  fiber.child.parent = fiber;\r\n  fiber.hook = alt.hook;\r\n  fiber.cc = alt.cc;\r\n  fiber.cec = alt.cec;\r\n  alt.element && (fiber.element = alt.element);\r\n  alt.provider && (fiber.provider = alt.provider);\r\n  alt.catch && (fiber.catch = alt.catch);\r\n  alt.atoms && (fiber.atoms = alt.atoms);\r\n\r\n  const diff = fiber.eidx - alt.eidx;\r\n  const deep = diff !== 0;\r\n\r\n  if (deep) {\r\n    walk(fiber.child, ($fiber, skip) => {\r\n      $fiber.eidx += diff;\r\n      if ($fiber.element) return skip();\r\n    });\r\n  }\r\n\r\n  notifyParents(fiber, alt);\r\n\r\n  return false;\r\n}\r\n\r\nfunction mount(fiber: Fiber, $scope: Scope) {\r\n  let inst = fiber.inst;\r\n  const isComponent = detectIsComponent(inst);\r\n  const component = inst as Component;\r\n\r\n  if (isComponent) {\r\n    try {\r\n      let result = component.type(component.props, component.ref);\r\n\r\n      if (detectIsLazy(component) && !detectIsLoaded(component) && ($scope.getIsHydrateZone() || detectIsServer())) {\r\n        $scope.navToParent();\r\n        $scope.setNextUnitOfWork(fiber.parent);\r\n        Fiber.setNextId(fiber.parent.id);\r\n        throw new StopWork();\r\n      }\r\n\r\n      if (detectIsArray(result)) {\r\n        !detectIsFragment(component) && (result = Fragment({ slot: result }));\r\n      } else if (detectIsTextBased(result)) {\r\n        result = Text(result);\r\n      }\r\n\r\n      component.children = result as Array<Instance>;\r\n      platform.detectIsPortal(inst) && fiber.markHost(PORTAL_HOST_MASK);\r\n    } catch (err) {\r\n      if (err instanceof StopWork) {\r\n        throw err;\r\n      }\r\n\r\n      component.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(inst)) {\r\n    inst = inst();\r\n  }\r\n\r\n  if (hasChildrenProp(inst)) {\r\n    inst.children = flatten(inst.children, x => (detectIsTextBased(x) ? Text(x) : x || supportConditional(x)));\r\n    isComponent && component.children.length === 0 && component.children.push(createReplacer());\r\n  }\r\n\r\n  return inst;\r\n}\r\n\r\nfunction extractKeys(alt: Fiber, children: Array<Instance>) {\r\n  let nextFiber = alt;\r\n  let idx = 0;\r\n  const prevKeys: Array<ElementKey> = [];\r\n  const nextKeys: Array<ElementKey> = [];\r\n  const prevKeysMap: Record<ElementKey, boolean> = {};\r\n  const nextKeysMap: Record<ElementKey, boolean> = {};\r\n  const keyedFibersMap: Record<ElementKey, Fiber> = {};\r\n  const usedKeysMap: Record<ElementKey, boolean> = {};\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    if (nextFiber) {\r\n      const key = getElementKey(nextFiber.inst);\r\n      const prevKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      if (!prevKeysMap[prevKey]) {\r\n        prevKeysMap[prevKey] = true; // !\r\n        prevKeys.push(prevKey);\r\n      }\r\n\r\n      keyedFibersMap[prevKey] = nextFiber;\r\n    }\r\n\r\n    if (children[idx]) {\r\n      const inst = children[idx];\r\n      const key = getElementKey(inst);\r\n      const nextKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (usedKeysMap[nextKey]) {\r\n          error(`[Dark]: The key of node [${nextKey}] already has been used!`, [inst]);\r\n        }\r\n      }\r\n\r\n      if (!nextKeysMap[nextKey]) {\r\n        nextKeysMap[nextKey] = true; // !\r\n        nextKeys.push(nextKey);\r\n      }\r\n\r\n      usedKeysMap[nextKey] = true;\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.next : null;\r\n    idx++;\r\n  }\r\n\r\n  return {\r\n    prevKeys,\r\n    nextKeys,\r\n    prevKeysMap,\r\n    nextKeysMap,\r\n    keyedFibersMap,\r\n  };\r\n}\r\n\r\nfunction supportConditional(inst: Instance) {\r\n  return detectIsFalsy(inst) ? createReplacer() : inst;\r\n}\r\n\r\nfunction commit($scope: Scope) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    process.env.NODE_ENV === 'development' && $scope.setIsHot(false);\r\n  }\r\n\r\n  const wipFiber = $scope.getWorkInProgress();\r\n  const deletions = $scope.getDeletions();\r\n  const candidates = $scope.getCandidates();\r\n  const isUpdateZone = $scope.getIsUpdateZone();\r\n  const unmounts: Array<Fiber> = [];\r\n  const combinedMask = INSERTION_EFFECT_HOST_MASK | LAYOUT_EFFECT_HOST_MASK | ASYNC_EFFECT_HOST_MASK | PORTAL_HOST_MASK;\r\n\r\n  // !\r\n  for (const fiber of deletions) {\r\n    const withNextTick = fiber.mask & ATOM_HOST_MASK && !(fiber.mask & combinedMask);\r\n\r\n    withNextTick ? unmounts.push(fiber) : unmountFiber(fiber);\r\n    fiber.tag = DELETE_EFFECT_TAG;\r\n    platform.commit(fiber);\r\n  }\r\n\r\n  isUpdateZone && sync(wipFiber);\r\n  $scope.runInsertionEffects();\r\n\r\n  for (const fiber of candidates) {\r\n    fiber.tag !== SKIP_EFFECT_TAG && platform.commit(fiber);\r\n    fiber.alt = null;\r\n    hasChildrenProp(fiber.inst) && (fiber.inst.children = null);\r\n  }\r\n\r\n  wipFiber.alt = null;\r\n  platform.finishCommit(); // !\r\n  $scope.runLayoutEffects();\r\n  $scope.runAsyncEffects();\r\n  unmounts.length > 0 && setTimeout(() => unmounts.forEach(x => unmountFiber(x)));\r\n  flush($scope);\r\n}\r\n\r\nfunction flush($scope: Scope, cancel = false) {\r\n  $scope.flush();\r\n  !cancel && $scope.getEmitter().emit('finish');\r\n}\r\n\r\nfunction sync(fiber: Fiber) {\r\n  const diff = fiber.cec - fiber.alt.cec;\r\n  if (diff === 0) return;\r\n  const parentFiber = getFiberWithElement(fiber.parent);\r\n  let isRight = false;\r\n\r\n  fiber.increment(diff, true);\r\n\r\n  walk(parentFiber.child, ($fiber, skip) => {\r\n    if ($fiber === fiber) {\r\n      isRight = true;\r\n      return skip();\r\n    }\r\n\r\n    $fiber.element && skip();\r\n    isRight && ($fiber.eidx += diff);\r\n  });\r\n}\r\n\r\nfunction fork($scope: Scope): false {\r\n  const $$scope$ = $scope.copy();\r\n  const wipFiber = $scope.getWorkInProgress();\r\n  const child = wipFiber.child;\r\n  child && (child.parent = null);\r\n  const restore = (options: RestoreOptions) => {\r\n    const { fiber: wipFiber, setValue, resetValue } = options;\r\n    const $scope = $$scope();\r\n\r\n    detectIsFunction(setValue) && setValue();\r\n    detectIsFunction(resetValue) && $$scope$.addCancel(resetValue);\r\n\r\n    wipFiber.alt = new Fiber().mutate(wipFiber);\r\n    wipFiber.tag = UPDATE_EFFECT_TAG;\r\n    wipFiber.child = child;\r\n    child && (child.parent = wipFiber);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      wipFiber.marker = '';\r\n    }\r\n\r\n    $$scope$.setRoot($scope.getRoot());\r\n    $$scope$.setWorkInProgress(wipFiber);\r\n    replaceScope($$scope$);\r\n  };\r\n\r\n  wipFiber.child = wipFiber.alt.child;\r\n  wipFiber.alt = null;\r\n  $scope.applyCancels();\r\n  flush($scope, true);\r\n  scheduler.cancelTask(restore);\r\n\r\n  return false;\r\n}\r\n\r\nexport type CreateUpdateOptions = {\r\n  rootId: number;\r\n  isTransition?: boolean;\r\n  hook: Hook;\r\n  createChanger?: () => UpdateChanger;\r\n};\r\n\r\nexport type UpdateChanger = {\r\n  shouldUpdate: () => boolean;\r\n} & Pick<RestoreOptions, 'setValue' | 'resetValue'>;\r\n\r\nfunction createUpdate(options: CreateUpdateOptions) {\r\n  const { rootId, hook, isTransition, createChanger = $createChanger } = options;\r\n  const callback = (restore?: (options: RestoreOptions) => void) => {\r\n    setRootId(rootId); // !\r\n    const fromRestore = detectIsFunction(restore);\r\n    const { shouldUpdate, setValue, resetValue } = createChanger();\r\n    const $scope = $$scope();\r\n    const owner = hook.owner;\r\n    const fiber = owner.alt || owner;\r\n\r\n    if (!shouldUpdate() || !detectIsFiberAlive(fiber) || fromRestore) {\r\n      fromRestore && restore({ fiber, setValue, resetValue });\r\n      return;\r\n    }\r\n\r\n    detectIsFunction(setValue) && setValue();\r\n    detectIsFunction(resetValue) && isTransition && $scope.addCancel(resetValue);\r\n\r\n    fiber.alt = new Fiber().mutate(fiber);\r\n    fiber.tag = UPDATE_EFFECT_TAG;\r\n    fiber.cc = 0;\r\n    fiber.cec = 0;\r\n    fiber.child = null;\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      fiber.marker = '';\r\n    }\r\n\r\n    $scope.setIsUpdateZone(true);\r\n    $scope.resetMount();\r\n    $scope.setWorkInProgress(fiber);\r\n    $scope.setCursorFiber(fiber);\r\n    fiber.inst = mount(fiber, $scope);\r\n    $scope.setNextUnitOfWork(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nconst $createChanger = (): UpdateChanger => ({\r\n  shouldUpdate: trueFn,\r\n  setValue: null,\r\n  resetValue: null,\r\n});\r\n\r\nconst detectIsBusy = () => Boolean($$scope()?.getWorkInProgress());\r\n\r\nclass StopWork extends Error {}\r\n\r\nexport { Fiber, workLoop, createUpdate, detectIsBusy };\r\n","export const VERSION = '0.25.1';\r\nexport const SLASH_MARK = '/';\r\nexport const PARAMETER_MARK = ':';\r\nexport const WILDCARD_MARK = '**';\r\nexport const PROTOCOL_MARK = '://';\r\nexport const SEARCH_MARK = '?';\r\nexport const HASH_MARK = '#';\r\nexport const ROOT_MARK = '_ROOT_';\r\n","import { createContext, useContext } from '@dark-engine/core';\r\n\r\nimport { type RouterLocation } from '../location';\r\nimport { type RouterHistory } from '../history';\r\nimport { type Route } from '../create-routes';\r\n\r\nexport type ActiveRouteContextValue = {\r\n  location: RouterLocation;\r\n  params: Map<string, string>;\r\n  activeRoute: Route;\r\n};\r\n\r\nconst ActiveRouteContext = createContext<ActiveRouteContextValue>(null, { displayName: 'ActiveRoute' });\r\n\r\nfunction useActiveRouteContext() {\r\n  const value = useContext(ActiveRouteContext);\r\n\r\n  return value;\r\n}\r\n\r\nexport type RouterHistoryContextValue = {\r\n  history: RouterHistory;\r\n};\r\n\r\nconst RouterHistoryContext = createContext<RouterHistoryContextValue>(null, { displayName: 'RouterHistory' });\r\n\r\nfunction useRouterHistoryContext() {\r\n  const value = useContext(RouterHistoryContext);\r\n\r\n  return value;\r\n}\r\n\r\nconst CurrentPathContext = createContext<string>(null, { displayName: 'CurrentPath' });\r\n\r\nfunction useCurrentPathContext() {\r\n  const value = useContext(CurrentPathContext);\r\n\r\n  return value;\r\n}\r\n\r\nfunction checkContextValue(value: ActiveRouteContextValue | RouterHistoryContextValue) {\r\n  if (!value) {\r\n    throw new Error('[web-router]:  Illegal invoke hook outside router!');\r\n  }\r\n}\r\n\r\nexport {\r\n  ActiveRouteContext,\r\n  useActiveRouteContext,\r\n  RouterHistoryContext,\r\n  useRouterHistoryContext,\r\n  CurrentPathContext,\r\n  useCurrentPathContext,\r\n  checkContextValue,\r\n};\r\n","import { type DarkElement, type ComponentFactory, type SlotProps, keyBy, detectIsString } from '@dark-engine/core';\r\n\r\nimport { SLASH_MARK, WILDCARD_MARK, ROOT_MARK } from '../constants';\r\nimport { pipe, splitPath, normalaizePathname, detectIsParam, getParamName, sort } from '../utils';\r\nimport { CurrentPathContext } from '../context';\r\nimport type { Routes, RouteDescriptor, PathMatchStrategy, Params } from './types';\r\n\r\ntype RouteConstructorOptions = {\r\n  prefix: string;\r\n  parent: Route;\r\n} & RouteDescriptor;\r\n\r\nclass Route {\r\n  public path = '';\r\n  public pathMatch?: PathMatchStrategy;\r\n  public parent: Route = null;\r\n  public children: Array<Route> = [];\r\n  public level: number = null;\r\n  public marker = '';\r\n  public redirectTo: {\r\n    path: string;\r\n    route: Route;\r\n  };\r\n  public component: RouteConstructorOptions['component'] | null;\r\n\r\n  constructor(options: RouteConstructorOptions) {\r\n    const { prefix, path, redirectTo, pathMatch = 'prefix', children = [], parent, component } = options;\r\n    const rootPath = createRootPath(path);\r\n    const $path = createPath(pathMatch, prefix, rootPath);\r\n\r\n    this.path = $path;\r\n    this.pathMatch = pathMatch;\r\n    this.parent = parent;\r\n    this.children = createRoutes(children, $path, this);\r\n    this.level = parent ? parent.level + 1 : 0;\r\n    this.marker = rootPath;\r\n    this.redirectTo = detectIsString(redirectTo)\r\n      ? {\r\n          path: createPath(pathMatch, prefix, createRootPath(redirectTo)),\r\n          route: null,\r\n        }\r\n      : null;\r\n    this.component = component || null;\r\n  }\r\n\r\n  private getRoute(): Route {\r\n    return this;\r\n  }\r\n\r\n  public getPath() {\r\n    return this.path.replaceAll(ROOT_MARK + SLASH_MARK, '');\r\n  }\r\n\r\n  public render(): DarkElement {\r\n    let slot = null;\r\n    let nextRoute = this.getRoute();\r\n\r\n    while (nextRoute) {\r\n      const value = nextRoute.getPath();\r\n      const component = nextRoute.component as ComponentFactory<SlotProps>;\r\n\r\n      slot = CurrentPathContext.Provider({ value, slot: [component({ slot })] });\r\n      nextRoute = nextRoute.parent;\r\n    }\r\n\r\n    return slot;\r\n  }\r\n}\r\n\r\nfunction createRoutes(routes: Routes, prefix = SLASH_MARK, parent: Route = null): Array<Route> {\r\n  const $routes: Array<Route> = [];\r\n\r\n  for (const route of routes) {\r\n    const $route = new Route({ ...route, prefix, parent });\r\n\r\n    $routes.push($route, ...$route.children);\r\n  }\r\n\r\n  if (!parent) {\r\n    const map = keyBy($routes, x => x.path, true) as Record<string, Route>;\r\n\r\n    for (const $route of $routes) {\r\n      if ($route.redirectTo) {\r\n        $route.redirectTo.route = map[$route.redirectTo.path] || null;\r\n      }\r\n    }\r\n  }\r\n\r\n  return $routes;\r\n}\r\n\r\nfunction resolve(pathname: string, routes: Array<Route>): Route {\r\n  const route = pipe<Route>(\r\n    match(pathname, routes),\r\n    redirect(),\r\n    wildcard(pathname, routes),\r\n    redirect(),\r\n    root(),\r\n    redirect(),\r\n    canRender(),\r\n  )();\r\n\r\n  return route;\r\n}\r\n\r\nfunction match(pathname: string, routes: Array<Route>) {\r\n  return (): Route => {\r\n    const [route] = pipe<Array<Route>>(\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchByFirstStrategy(pathname, x.path)),\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchBySecondStrategy(pathname, x.path)),\r\n    )(routes);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction redirect() {\r\n  return (route: Route): Route => {\r\n    if (route?.redirectTo) return redirect()(route.redirectTo.route);\r\n    if (route?.parent?.redirectTo) return redirect()(route.parent.redirectTo.route);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction wildcard(pathname: string, routes: Array<Route>) {\r\n  return ($route: Route): Route => {\r\n    if ($route) return $route;\r\n    const [route] = pipe<Array<Route>>(\r\n      (routes: Array<Route>) => routes.filter(x => x.marker === WILDCARD_MARK),\r\n      (routes: Array<Route>) => routes.filter(x => detectIsMatchAsWildcard(pathname, x.path)) || null,\r\n      (routes: Array<Route>) => sort('desc', routes, x => x.level),\r\n    )(routes);\r\n\r\n    return pick(route);\r\n  };\r\n}\r\n\r\nfunction root() {\r\n  return (route: Route): Route => {\r\n    const root = route?.children.find(x => x.marker === ROOT_MARK) || route;\r\n\r\n    return pick(root);\r\n  };\r\n}\r\n\r\nfunction canRender() {\r\n  return (route: Route): Route => {\r\n    if (route?.component) return route;\r\n\r\n    if (process.env.NODE_ENV !== 'test') {\r\n      throw new Error('[web-router]: Route not found or it has no component!');\r\n    }\r\n\r\n    return null;\r\n  };\r\n}\r\n\r\nconst pick = (route: Route): Route | null => route || null;\r\n\r\nfunction detectIsMatchByFirstStrategy(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: (_, b) => b,\r\n    skip: ({ isRoot, isParam }) => isRoot || isParam,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\nfunction detectIsMatchBySecondStrategy(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: a => a,\r\n    skip: ({ isParam }) => isParam,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\nfunction detectIsMatchAsWildcard(urlPath: string, routePath: string): boolean {\r\n  const matcher = createMatcher({\r\n    space: (_, b) => b,\r\n    skip: ({ isRoot, isParam, isWildcard }) => isRoot || isParam || isWildcard,\r\n  });\r\n\r\n  return matcher(urlPath, routePath);\r\n}\r\n\r\ntype CreateMatcherOptions = {\r\n  space: (a: Array<string>, b: Array<string>) => Array<string>;\r\n  skip: (options: SkipOptions) => boolean;\r\n};\r\n\r\ntype SkipOptions = {\r\n  isRoot: boolean;\r\n  isWildcard: boolean;\r\n  isParam: boolean;\r\n};\r\n\r\nfunction createMatcher(options: CreateMatcherOptions) {\r\n  const { space, skip } = options;\r\n  return (urlPath: string, routePath: string) => {\r\n    const sUrlPath = splitPath(urlPath);\r\n    const sRoutePath = splitPath(routePath);\r\n\r\n    for (let i = 0; i < space(sUrlPath, sRoutePath).length; i++) {\r\n      const segment = sRoutePath[i];\r\n      const isRoot = segment === ROOT_MARK;\r\n      const isWildcard = segment === WILDCARD_MARK;\r\n      const isParam = detectIsParam(segment);\r\n\r\n      if (segment !== sUrlPath[i] && !skip({ isRoot, isWildcard, isParam })) return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n}\r\n\r\nfunction createPathname(urlPath: string, routePath: string): string {\r\n  const sUrlPath = splitPath(urlPath);\r\n  const sRoutePath = splitPath(routePath);\r\n  const parts: Array<string> = [];\r\n\r\n  for (let i = 0; i < sRoutePath.length; i++) {\r\n    const isParam = detectIsParam(sRoutePath[i]);\r\n\r\n    if (isParam) {\r\n      const param = sUrlPath[i] || 'null';\r\n\r\n      parts.push(param);\r\n    } else {\r\n      parts.push(sRoutePath[i]);\r\n    }\r\n  }\r\n\r\n  let newPathname = normalaizePathname(parts.join(SLASH_MARK));\r\n\r\n  if (newPathname[0] !== SLASH_MARK) {\r\n    newPathname = SLASH_MARK + newPathname;\r\n  }\r\n\r\n  return newPathname;\r\n}\r\n\r\nfunction createPath(pathMatch: PathMatchStrategy, prefix: string, path: string): string {\r\n  const $prefix = pathMatch === 'prefix' ? normalaizePathname(prefix) : '';\r\n\r\n  return normalaizePathname($prefix ? `${$prefix}${path}` : path);\r\n}\r\n\r\nfunction createRootPath(path: string): string {\r\n  return path === SLASH_MARK || path === '' ? ROOT_MARK : path;\r\n}\r\n\r\nconst getParamsMap = (pathname: string, route: Route): Params => {\r\n  const sPathname = splitPath(pathname);\r\n  const sPath = splitPath(route.path);\r\n  const map = new Map();\r\n\r\n  for (let i = 0; i < sPath.length; i++) {\r\n    if (detectIsParam(sPath[i])) {\r\n      map.set(getParamName(sPath[i]), sPathname[i]);\r\n    }\r\n  }\r\n\r\n  return map;\r\n};\r\n\r\nfunction resolveRoute(pathname: string, routes: Array<Route>) {\r\n  const activeRoute = resolve(pathname, routes);\r\n  const slot = activeRoute ? activeRoute.render() : null;\r\n  const params = activeRoute ? getParamsMap(pathname, activeRoute) : null;\r\n  const value = { activeRoute, slot, params };\r\n\r\n  return value;\r\n}\r\n\r\nexport { type Route, createRoutes, resolve, resolveRoute, createPathname };\r\n","import { h, component, useMemo, useEvent, detectIsFunction, type DarkElement } from '@dark-engine/core';\r\nimport { type SyntheticEvent } from '@dark-engine/platform-browser';\r\n\r\nimport { useHistory } from '../use-history';\r\nimport { useLocation } from '../use-location';\r\nimport { normalaizePathname, cm, parseURL } from '../utils';\r\n\r\nexport type RoutreLinkProps = {\r\n  to: string;\r\n  activeClassName?: string;\r\n  className?: string;\r\n  title?: string;\r\n  slot: DarkElement;\r\n  onClick?: (e: SyntheticEvent<MouseEvent, HTMLLinkElement>) => void;\r\n};\r\n\r\nconst RouterLink = component<RoutreLinkProps>(\r\n  ({ to, activeClassName = 'router-link-active', className: sourceClassName, slot, onClick, ...rest }) => {\r\n    const history = useHistory();\r\n    const { pathname, hash } = useLocation();\r\n    const isActive = useMemo(() => detectIsActiveLink(pathname, hash, to), [pathname, hash, to]);\r\n    const className = useMemo(\r\n      () => cm(sourceClassName, isActive ? activeClassName : ''),\r\n      [sourceClassName, activeClassName, isActive],\r\n    );\r\n\r\n    const handleClick = useEvent((e: SyntheticEvent<MouseEvent, HTMLLinkElement>) => {\r\n      e.preventDefault();\r\n      history.push(to);\r\n      detectIsFunction(onClick) && onClick(e);\r\n    });\r\n\r\n    return (\r\n      <a {...rest} href={to} class={className} onClick={handleClick}>\r\n        {slot}\r\n      </a>\r\n    );\r\n  },\r\n  {\r\n    displayName: 'RouterLink',\r\n  },\r\n);\r\n\r\nfunction detectIsActiveLink(pathname: string, hash: string, to: string): boolean {\r\n  const { pathname: $to, hash: $hash } = parseURL(to);\r\n\r\n  return normalaizePathname(pathname).indexOf($to) !== -1 && hash === $hash;\r\n}\r\n\r\nexport { RouterLink };\r\n","import { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\n\r\nfunction useEvent<T extends (...args: Array<any>) => any>(fn: T) {\r\n  const scope = useMemo(() => ({ fn }), []);\r\n\r\n  scope.fn = fn;\r\n\r\n  const callback = useCallback((...args: Array<any>) => {\r\n    return scope.fn(...args);\r\n  }, []);\r\n\r\n  return callback as unknown as T;\r\n}\r\n\r\nexport { useEvent };\r\n","import { useRouterHistoryContext, checkContextValue } from '../context';\r\n\r\nfunction useHistory() {\r\n  const value = useRouterHistoryContext();\r\n\r\n  checkContextValue(value);\r\n\r\n  return value.history;\r\n}\r\n\r\nexport { useHistory };\r\n","import { useActiveRouteContext, checkContextValue } from '../context';\r\n\r\nfunction useLocation() {\r\n  const activeRoute = useActiveRouteContext();\r\n\r\n  checkContextValue(activeRoute);\r\n\r\n  return activeRoute.location;\r\n}\r\n\r\nexport { useLocation };\r\n","import { SLASH_MARK, PARAMETER_MARK, PROTOCOL_MARK, HASH_MARK, SEARCH_MARK } from '../constants';\r\n\r\nfunction pipe<T>(...fns: Array<Function>): (...args: Array<any>) => T {\r\n  const [fn, ...rest] = fns;\r\n\r\n  return (...args: Array<any>) => {\r\n    return rest.reduce(\r\n      (fn1, fn2) => () => fn2(fn1()),\r\n      () => fn(...args),\r\n    )();\r\n  };\r\n}\r\n\r\nfunction parseURL(url: string) {\r\n  let body = url;\r\n  let protocol = '';\r\n  let host = '';\r\n  let pathname = '';\r\n  let hash = '';\r\n  let search = '';\r\n\r\n  if (body.indexOf(PROTOCOL_MARK) !== -1) {\r\n    [protocol, body] = body.split(PROTOCOL_MARK).filter(Boolean);\r\n  }\r\n\r\n  const splitted = body.split('');\r\n  const idx = splitted.findIndex(x => x === SLASH_MARK);\r\n\r\n  if (idx !== -1) {\r\n    host = splitted.filter((_, idx1) => idx1 < idx).join('');\r\n    pathname = splitted.filter((_, idx1) => idx1 >= idx).join('');\r\n  } else {\r\n    host = body;\r\n    pathname = pathname || SLASH_MARK;\r\n  }\r\n\r\n  if (pathname.indexOf(SEARCH_MARK) !== -1) {\r\n    [pathname, search] = split(pathname, SEARCH_MARK);\r\n  }\r\n\r\n  if (body.indexOf(HASH_MARK) !== -1) {\r\n    if (search) {\r\n      [search, hash] = split(search, HASH_MARK);\r\n    } else {\r\n      [pathname, hash] = split(pathname, HASH_MARK);\r\n    }\r\n  }\r\n\r\n  return {\r\n    protocol,\r\n    host,\r\n    pathname: addSlashToEnd(pathname),\r\n    search: createSearch(search),\r\n    hash: createHash(hash),\r\n  };\r\n}\r\n\r\nconst createSearch = (value: string) => (value ? `${SEARCH_MARK}${value}` : '');\r\n\r\nconst createHash = (value: string) => (value ? `${HASH_MARK}${value}` : '');\r\n\r\nconst detectIsParam = (value: string) => value && value.startsWith(PARAMETER_MARK);\r\n\r\nconst getParamName = (value: string) => (detectIsParam(value) ? value.slice(1, value.length) : null);\r\n\r\nconst split = (value: string, token: string) => value.split(token).filter(Boolean);\r\n\r\nconst splitPath = (path: string) => split(path, SLASH_MARK);\r\n\r\nconst addSlashToStart = (path: string) => (path.startsWith(SLASH_MARK) ? path : SLASH_MARK + path);\r\n\r\nconst addSlashToEnd = (path: string) => (path.endsWith(SLASH_MARK) ? path : path + SLASH_MARK);\r\n\r\nfunction normalaizePathname(spath: string) {\r\n  const { pathname, search, hash } = parseURL(addSlashToStart(spath));\r\n  const newSpath = pathname + search + hash;\r\n\r\n  return newSpath;\r\n}\r\n\r\nfunction sort<T>(type: 'asc' | 'desc', list: Array<T>, selector: (x: T) => number) {\r\n  const asc = (a: T, b: T) => selector(a) - selector(b);\r\n  const desc = (a: T, b: T) => selector(b) - selector(a);\r\n  const compare = type === 'asc' ? asc : desc;\r\n\r\n  return list.sort(compare);\r\n}\r\n\r\nconst cm = (...args: Array<string>) => [...args].filter(Boolean).join(' ').trim() || undefined;\r\n\r\nexport { pipe, parseURL, detectIsParam, getParamName, splitPath, normalaizePathname, sort, cm };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".build.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","import { type Fiber, detectIsComponent } from '@dark-engine/core';\r\n\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nconst $$portal = Symbol('portal');\r\n\r\nconst detectIsPortal = (instance: unknown) => detectIsComponent(instance) && instance.token === $$portal;\r\n\r\nconst getPortalContainer = (fiber: Fiber<TagNativeElement>): TagNativeElement | null =>\r\n  detectIsPortal(fiber.inst) ? fiber.element : null;\r\n\r\nfunction unmountPortal(fiber: Fiber<TagNativeElement>) {\r\n  const element = getPortalContainer(fiber);\r\n\r\n  element && (element.textContent = '');\r\n}\r\n\r\nexport { $$portal, detectIsPortal, unmountPortal };\r\n","import { detectIsFunction, $$scope, detectIsArray } from '@dark-engine/core';\r\n\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\ntype BrowserEventConstructor = (type: string, event: Event) => void;\r\n\r\nclass SyntheticEvent<E extends Event, T = TagNativeElement> {\r\n  public type = '';\r\n  public sourceEvent: E = null;\r\n  public target: T = null;\r\n  private propagation = true;\r\n\r\n  constructor(options: Pick<SyntheticEvent<E, T>, 'sourceEvent' | 'target'>) {\r\n    this.type = options.sourceEvent.type;\r\n    this.sourceEvent = options.sourceEvent;\r\n    this.target = options.target;\r\n  }\r\n\r\n  public stopPropagation() {\r\n    this.propagation = false;\r\n    this.sourceEvent.stopPropagation();\r\n  }\r\n\r\n  public preventDefault() {\r\n    this.sourceEvent.preventDefault();\r\n  }\r\n\r\n  public getPropagation() {\r\n    return this.propagation;\r\n  }\r\n}\r\n\r\nfunction delegateEvent(\r\n  target: Element,\r\n  eventName: string,\r\n  handler: (e: Event) => void | [fn: () => void, ...args: Array<any>],\r\n) {\r\n  const $scope = $$scope();\r\n  const eventsMap = $scope.getEvents();\r\n  const handlersMap = eventsMap.get(eventName);\r\n  const $handler = detectIsArray(handler) ? (e: Event) => handler[0](...handler.slice(1), e) : handler;\r\n\r\n  if (!handlersMap) {\r\n    const rootHandler = (event: Event) => {\r\n      const handler = eventsMap.get(eventName).get(event.target);\r\n      const target = event.target as TagNativeElement;\r\n      let $event: SyntheticEvent<Event> = null;\r\n\r\n      if (detectIsFunction(handler)) {\r\n        $event = new SyntheticEvent({ sourceEvent: event, target });\r\n\r\n        $scope.setIsEventZone(true);\r\n        handler($event);\r\n        $scope.setIsEventZone(false);\r\n      }\r\n\r\n      if (target.parentElement) {\r\n        const shouldPropagate = $event ? $event.getPropagation() : true;\r\n\r\n        if (shouldPropagate) {\r\n          const constructor = event.constructor as BrowserEventConstructor;\r\n\r\n          target.parentElement.dispatchEvent(new constructor(event.type, event));\r\n        }\r\n      }\r\n    };\r\n\r\n    eventsMap.set(eventName, new WeakMap([[target, $handler]]));\r\n    document.addEventListener(eventName, rootHandler, true);\r\n    $scope.addEventUnsubscriber(() => document.removeEventListener(eventName, rootHandler, true));\r\n  } else {\r\n    handlersMap.set(target, $handler);\r\n  }\r\n}\r\n\r\nconst detectIsEvent = (attrName: string) => attrName.startsWith('on');\r\n\r\nconst getEventName = (attrName: string) => attrName.slice(2, attrName.length).toLowerCase();\r\n\r\nexport { SyntheticEvent, delegateEvent, detectIsEvent, getEventName };\r\n","export const VERSION = '0.25.1';\r\nexport const STYLE_ATTR = 'style';\r\nexport const CLASS_ATTR = 'class';\r\nexport const CLASS_NAME_ATTR = 'className';\r\nexport const EXCLUDE_ATTR_MARK = '$';\r\n","import {\r\n  type Fiber,\r\n  type VirtualNode,\r\n  type TagVirtualNode,\r\n  type TextVirtualNode,\r\n  type CommentVirtualNode,\r\n  type PlainVirtualNode,\r\n  type Callback,\r\n  REF_ATTR,\r\n  ATTR_BLACK_LIST,\r\n  CREATE_EFFECT_TAG,\r\n  UPDATE_EFFECT_TAG,\r\n  DELETE_EFFECT_TAG,\r\n  SKIP_EFFECT_TAG,\r\n  MOVE_MASK,\r\n  FLUSH_MASK,\r\n  SHADOW_MASK,\r\n  detectIsUndefined,\r\n  detectIsBoolean,\r\n  detectIsObject,\r\n  NodeType,\r\n  detectIsTagVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsPlainVirtualNode,\r\n  getFiberWithElement,\r\n  collectElements,\r\n  walk,\r\n  dummyFn,\r\n  $$scope,\r\n  applyRef,\r\n} from '@dark-engine/core';\r\n\r\nimport { detectIsPortal } from '../portal';\r\nimport { delegateEvent, detectIsEvent, getEventName } from '../events';\r\nimport { STYLE_ATTR, CLASS_ATTR, CLASS_NAME_ATTR, EXCLUDE_ATTR_MARK } from '../constants';\r\nimport type {\r\n  NativeElement,\r\n  TagNativeElement,\r\n  TextNativeElement,\r\n  CommentNativeElement,\r\n  NativeNode,\r\n  AttributeValue,\r\n} from '../native-element';\r\n\r\nlet moves: Array<Callback> = [];\r\nlet patches: Array<Callback> = [];\r\nlet trackUpdate: (nativeElement: NativeElement) => void = null;\r\nconst svgTagNames = new Set([\r\n  'svg',\r\n  'animate',\r\n  'animateMotion',\r\n  'animateTransform',\r\n  'circle',\r\n  'clipPath',\r\n  'defs',\r\n  'desc',\r\n  'ellipse',\r\n  'feBlend',\r\n  'feColorMatrix',\r\n  'feComponentTransfer',\r\n  'feComposite',\r\n  'feConvolveMatrix',\r\n  'feDiffuseLighting',\r\n  'feDisplacementMap',\r\n  'feDistantLight',\r\n  'feDropShadow',\r\n  'feFlood',\r\n  'feFuncA',\r\n  'feFuncB',\r\n  'feFuncG',\r\n  'feFuncR',\r\n  'feGaussianBlur',\r\n  'feImage',\r\n  'feMerge',\r\n  'feMergeNode',\r\n  'feMorphology',\r\n  'feOffset',\r\n  'fePointLight',\r\n  'feSpecularLighting',\r\n  'feSpotLight',\r\n  'feTile',\r\n  'feTurbulence',\r\n  'filter',\r\n  'foreignObject',\r\n  'g',\r\n  'image',\r\n  'line',\r\n  'linearGradient',\r\n  'marker',\r\n  'mask',\r\n  'metadata',\r\n  'mpath',\r\n  'path',\r\n  'pattern',\r\n  'polygon',\r\n  'polyline',\r\n  'radialGradient',\r\n  'rect',\r\n  'stop',\r\n  'switch',\r\n  'symbol',\r\n  'text',\r\n  'textPath',\r\n  'tspan',\r\n  'use',\r\n  'view',\r\n]);\r\nconst voidTagNames = new Set([\r\n  'area',\r\n  'base',\r\n  'br',\r\n  'col',\r\n  'embed',\r\n  'hr',\r\n  'img',\r\n  'input',\r\n  'link',\r\n  'meta',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr',\r\n]);\r\n\r\nconst createNativeElementMap = {\r\n  [NodeType.TAG]: (vNode: VirtualNode): TagNativeElement => {\r\n    const tagNode = vNode as TagVirtualNode;\r\n    const name = tagNode.name;\r\n\r\n    return detectIsSvgElement(name)\r\n      ? document.createElementNS('http://www.w3.org/2000/svg', name)\r\n      : document.createElement(name);\r\n  },\r\n  [NodeType.TEXT]: (vNode: VirtualNode): TextNativeElement => {\r\n    return document.createTextNode((vNode as TextVirtualNode).value);\r\n  },\r\n  [NodeType.COMMENT]: (vNode: VirtualNode): CommentNativeElement => {\r\n    return document.createComment((vNode as CommentVirtualNode).value);\r\n  },\r\n};\r\n\r\nfunction createNativeElement(node: VirtualNode): NativeElement {\r\n  return createNativeElementMap[node.type](node);\r\n}\r\n\r\nfunction detectIsSvgElement(name: string) {\r\n  return svgTagNames.has(name);\r\n}\r\n\r\nfunction detectIsVoidElement(name: string) {\r\n  return voidTagNames.has(name);\r\n}\r\n\r\nfunction setObjectStyle(element: TagNativeElement, style: object) {\r\n  const keys = Object.keys(style);\r\n\r\n  for (const key of keys) {\r\n    element.style.setProperty(key, String(style[key]));\r\n  }\r\n}\r\n\r\nfunction addAttributes(element: NativeElement, node: TagVirtualNode, isHydrateZone: boolean) {\r\n  const attrNames = Object.keys(node.attrs);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const attrValue = node.attrs[attrName];\r\n\r\n    if (attrName[0] === EXCLUDE_ATTR_MARK) continue;\r\n\r\n    if (attrName === REF_ATTR) {\r\n      applyRef(attrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (attrName === CLASS_ATTR || attrName === CLASS_NAME_ATTR) {\r\n      toggleAttribute(tagElement, CLASS_ATTR, attrValue);\r\n      continue;\r\n    }\r\n\r\n    if (attrName === STYLE_ATTR && attrValue && detectIsObject(attrValue)) {\r\n      setObjectStyle(tagElement, attrValue);\r\n      continue;\r\n    }\r\n\r\n    if (detectIsEvent(attrName)) {\r\n      delegateEvent(tagElement, getEventName(attrName), attrValue);\r\n    } else if (!isHydrateZone && !detectIsUndefined(attrValue) && !ATTR_BLACK_LIST[attrName]) {\r\n      const stop = patchProperties({\r\n        tagName: node.name,\r\n        element: tagElement,\r\n        attrValue,\r\n        attrName,\r\n      });\r\n\r\n      !stop && tagElement.setAttribute(attrName, attrValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateAttributes(element: NativeElement, prevNode: TagVirtualNode, nextNode: TagVirtualNode) {\r\n  const attrNames = getAttributeNames(prevNode, nextNode);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const prevAttrValue = prevNode.attrs[attrName];\r\n    const nextAttrValue = nextNode.attrs[attrName];\r\n\r\n    if (attrName[0] === EXCLUDE_ATTR_MARK) continue;\r\n\r\n    if (attrName === REF_ATTR) {\r\n      applyRef(prevAttrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if ((attrName === CLASS_ATTR || attrName === CLASS_NAME_ATTR) && prevAttrValue !== nextAttrValue) {\r\n      toggleAttribute(tagElement, CLASS_ATTR, nextAttrValue);\r\n      continue;\r\n    }\r\n\r\n    if (attrName === STYLE_ATTR && nextAttrValue && prevAttrValue !== nextAttrValue && detectIsObject(nextAttrValue)) {\r\n      setObjectStyle(tagElement, nextAttrValue);\r\n      continue;\r\n    }\r\n\r\n    if (!detectIsUndefined(nextAttrValue)) {\r\n      if (detectIsEvent(attrName)) {\r\n        prevAttrValue !== nextAttrValue && delegateEvent(tagElement, getEventName(attrName), nextAttrValue);\r\n      } else if (!ATTR_BLACK_LIST[attrName] && prevAttrValue !== nextAttrValue) {\r\n        const stop = patchProperties({\r\n          tagName: nextNode.name,\r\n          element: tagElement,\r\n          attrValue: nextAttrValue,\r\n          attrName,\r\n        });\r\n\r\n        !stop && tagElement.setAttribute(attrName, nextAttrValue);\r\n      }\r\n    } else {\r\n      tagElement.removeAttribute(attrName);\r\n    }\r\n  }\r\n}\r\n\r\nfunction toggleAttribute(element: TagNativeElement, name: string, value: string) {\r\n  value ? element.setAttribute(name, value) : element.removeAttribute(name);\r\n}\r\n\r\nfunction getAttributeNames(prevNode: TagVirtualNode, nextNode: TagVirtualNode) {\r\n  const attrNames = new Set<string>();\r\n  const prevAttrs = Object.keys(prevNode.attrs);\r\n  const nextAttrs = Object.keys(nextNode.attrs);\r\n  const size = Math.max(prevAttrs.length, nextAttrs.length);\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    attrNames.add(prevAttrs[i] || nextAttrs[i]);\r\n  }\r\n\r\n  return attrNames;\r\n}\r\n\r\ntype PatchPropertiesOptions = {\r\n  tagName: string;\r\n  element: TagNativeElement;\r\n  attrName: string;\r\n  attrValue: AttributeValue;\r\n};\r\n\r\nfunction patchProperties(options: PatchPropertiesOptions): boolean {\r\n  const { tagName, element, attrName, attrValue } = options;\r\n  const fn = patchPropertiesSpecialCasesMap[tagName];\r\n  let stop = fn ? fn(element, attrName, attrValue) : false;\r\n\r\n  if (canSetProperty(element, attrName)) {\r\n    element[attrName] = attrValue;\r\n  }\r\n\r\n  if (!stop && detectIsBoolean(attrValue)) {\r\n    stop = !attrName.includes('-');\r\n  }\r\n\r\n  return stop;\r\n}\r\n\r\nfunction canSetProperty(element: TagNativeElement, key: string) {\r\n  const prototype = Object.getPrototypeOf(element);\r\n  const descriptor = Object.getOwnPropertyDescriptor(prototype, key);\r\n\r\n  return Boolean(descriptor?.set);\r\n}\r\n\r\nconst patchPropertiesSpecialCasesMap: Record<\r\n  string,\r\n  (element: NativeElement, attrName: string, attrValue: AttributeValue) => boolean\r\n> = {\r\n  input: (element: HTMLInputElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value') {\r\n      patches.push(() => {\r\n        detectIsBoolean(attrValue) ? (element.checked = attrValue) : (element.value = String(attrValue));\r\n      });\r\n    } else if (attrName === 'autoFocus') {\r\n      patches.push(() => {\r\n        element.autofocus = Boolean(attrValue);\r\n        element.autofocus && element.focus();\r\n      });\r\n    }\r\n\r\n    return false;\r\n  },\r\n  textarea: (element: HTMLTextAreaElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value') {\r\n      element.innerText = String(attrValue);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  },\r\n};\r\n\r\nfunction commitCreation(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getFiberWithElement<NativeElement, TagNativeElement>(fiber.parent);\r\n  const parentElement = parentFiber.element;\r\n  const childNodes = parentElement.childNodes;\r\n  const isHydrateZone = $$scope().getIsHydrateZone();\r\n\r\n  if (isHydrateZone) {\r\n    const nativeElement = childNodes[fiber.eidx] as NativeElement;\r\n\r\n    if (\r\n      detectIsTextVirtualNode(fiber.inst) &&\r\n      nativeElement instanceof Text &&\r\n      fiber.inst.value.length !== nativeElement.length\r\n    ) {\r\n      nativeElement.splitText(fiber.inst.value.length);\r\n    }\r\n\r\n    fiber.element = nativeElement;\r\n  } else {\r\n    if (!(fiber.mask & SHADOW_MASK)) {\r\n      if (childNodes.length === 0 || fiber.eidx > childNodes.length - 1) {\r\n        !detectIsVoidElement((parentFiber.inst as TagVirtualNode).name) &&\r\n          appendNativeElement(fiber.element, parentElement);\r\n      } else {\r\n        insertNativeElement(fiber.element, parentElement.childNodes[fiber.eidx], parentElement);\r\n      }\r\n    }\r\n  }\r\n\r\n  detectIsTagVirtualNode(fiber.inst) && addAttributes(fiber.element, fiber.inst, isHydrateZone);\r\n}\r\n\r\nfunction commitUpdate(fiber: Fiber<NativeElement>) {\r\n  const element = fiber.element;\r\n  const prevInstance = fiber.alt.inst as VirtualNode;\r\n  const nextInstance = fiber.inst as VirtualNode;\r\n\r\n  detectIsPlainVirtualNode(nextInstance)\r\n    ? (prevInstance as PlainVirtualNode).value !== nextInstance.value && (element.textContent = nextInstance.value)\r\n    : updateAttributes(element, prevInstance as TagVirtualNode, nextInstance as TagVirtualNode);\r\n}\r\n\r\nfunction commitDeletion(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getFiberWithElement<NativeElement, TagNativeElement>(fiber.parent);\r\n\r\n  if (fiber.mask & FLUSH_MASK) {\r\n    parentFiber.element.innerHTML && (parentFiber.element.innerHTML = '');\r\n    return;\r\n  }\r\n\r\n  walk<NativeElement>(fiber, (fiber, skip) => {\r\n    if (fiber.element) {\r\n      !(fiber.mask & SHADOW_MASK) &&\r\n        !detectIsPortal(fiber.inst) &&\r\n        removeNativeElement(fiber.element, parentFiber.element);\r\n      return skip();\r\n    }\r\n  });\r\n}\r\n\r\nfunction move(fiber: Fiber<NativeElement>) {\r\n  const sourceNodes = collectElements(fiber, x => x.element);\r\n  const sourceNode = sourceNodes[0];\r\n  const parentElement = sourceNode.parentElement;\r\n  const sourceFragment = new DocumentFragment();\r\n  const elementIdx = fiber.eidx;\r\n  let idx = 0;\r\n  const move = () => {\r\n    for (let i = 1; i < sourceNodes.length; i++) {\r\n      removeNativeElement(parentElement.childNodes[elementIdx + 1], parentElement);\r\n    }\r\n\r\n    replaceNativeElement(sourceFragment, parentElement.childNodes[elementIdx], parentElement);\r\n  };\r\n\r\n  for (const node of sourceNodes) {\r\n    insertNativeElement(document.createComment(`${elementIdx}:${idx}`), node, parentElement);\r\n    appendNativeElement(node, sourceFragment);\r\n    idx++;\r\n  }\r\n\r\n  moves.push(move);\r\n}\r\n\r\nconst commitMap: Record<string, (fiber: Fiber<NativeElement>) => void> = {\r\n  [CREATE_EFFECT_TAG]: (fiber: Fiber<NativeElement>) => {\r\n    if (!fiber.element || detectIsPortal(fiber.inst)) return;\r\n    trackUpdate && trackUpdate(fiber.element);\r\n    commitCreation(fiber);\r\n  },\r\n  [UPDATE_EFFECT_TAG]: (fiber: Fiber<NativeElement>) => {\r\n    fiber.mask & MOVE_MASK && (move(fiber), (fiber.mask &= ~MOVE_MASK));\r\n    if (!fiber.element || detectIsPortal(fiber.inst)) return;\r\n    trackUpdate && trackUpdate(fiber.element);\r\n    commitUpdate(fiber);\r\n  },\r\n  [DELETE_EFFECT_TAG]: commitDeletion,\r\n  [SKIP_EFFECT_TAG]: dummyFn,\r\n};\r\n\r\nfunction commit(fiber: Fiber<NativeElement>) {\r\n  commitMap[fiber.tag](fiber);\r\n}\r\n\r\nfunction finishCommit() {\r\n  moves.forEach(x => x());\r\n  patches.forEach(x => x());\r\n  moves = [];\r\n  patches = [];\r\n}\r\n\r\nfunction setTrackUpdate(fn: typeof trackUpdate) {\r\n  trackUpdate = fn;\r\n}\r\n\r\nconst appendNativeElement = (element: NativeNode, parent: NativeNode) => parent.appendChild(element);\r\n\r\nconst insertNativeElement = (element: NativeNode, sibling: NativeNode, parent: TagNativeElement) => {\r\n  parent.insertBefore(element, sibling);\r\n};\r\n\r\nconst insertNativeElementByIndex = (element: NativeNode, idx: number, parent: TagNativeElement) => {\r\n  parent.insertBefore(element, parent.childNodes[idx]);\r\n};\r\n\r\nconst replaceNativeElement = (element: NativeNode, candidate: NativeNode, parent: TagNativeElement) => {\r\n  parent.replaceChild(element, candidate);\r\n};\r\n\r\nconst removeNativeElement = (element: NativeNode, parent: TagNativeElement) => parent.removeChild(element);\r\n\r\nexport { createNativeElement, commit, finishCommit, setTrackUpdate, insertNativeElementByIndex };\r\n","import {\r\n  type DarkElement,\r\n  ROOT,\r\n  Fiber,\r\n  CREATE_EFFECT_TAG,\r\n  UPDATE_EFFECT_TAG,\r\n  platform,\r\n  flatten,\r\n  detectIsUndefined,\r\n  trueFn,\r\n  TagVirtualNode,\r\n  TaskPriority,\r\n  createReplacer,\r\n  setRootId,\r\n  $$scope,\r\n  dummyFn,\r\n  scheduler,\r\n} from '@dark-engine/core';\r\n\r\nimport type { TagNativeElement } from '../native-element';\r\nimport { createNativeElement, insertNativeElementByIndex, commit, finishCommit } from '../dom';\r\nimport { detectIsPortal, unmountPortal } from '../portal/utils';\r\n\r\nconst roots = new Map<Element, number>();\r\nconst raf = requestAnimationFrame.bind(window);\r\nconst caf = cancelAnimationFrame.bind(window);\r\nconst spawn = raf;\r\nlet isInjected = false;\r\n\r\nfunction inject() {\r\n  platform.createElement = createNativeElement as typeof platform.createElement;\r\n  platform.insertElement = insertNativeElementByIndex as typeof platform.insertElement;\r\n  platform.raf = raf;\r\n  platform.caf = caf;\r\n  platform.spawn = spawn;\r\n  platform.commit = commit;\r\n  platform.finishCommit = finishCommit;\r\n  platform.detectIsDynamic = trueFn;\r\n  platform.detectIsPortal = detectIsPortal;\r\n  platform.unmountPortal = unmountPortal;\r\n  platform.chunk = dummyFn;\r\n  isInjected = true;\r\n}\r\n\r\nfunction render(element: DarkElement, container: TagNativeElement, hydrate = false) {\r\n  !isInjected && inject();\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (!(container instanceof Element)) {\r\n      throw new Error(`[Dark]: render receives only Element as container!`);\r\n    }\r\n  }\r\n\r\n  const isMounted = !detectIsUndefined(roots.get(container));\r\n  let rootId: number = null;\r\n\r\n  if (!isMounted) {\r\n    rootId = roots.size;\r\n    roots.set(container, rootId);\r\n    !hydrate && (container.innerHTML = '');\r\n  } else {\r\n    rootId = roots.get(container);\r\n  }\r\n\r\n  const $scope = $$scope(rootId);\r\n\r\n  // insertion effect can't schedule renders\r\n  if ($scope?.getIsInsertionEffectsZone()) return;\r\n\r\n  const callback = () => {\r\n    setRootId(rootId); // !\r\n    const $scope = $$scope();\r\n    const rootFiber = $scope.getRoot();\r\n    const isUpdate = Boolean(rootFiber);\r\n    const fiber = new Fiber().mutate({\r\n      element: container,\r\n      inst: new TagVirtualNode(ROOT, {}, flatten([element || createReplacer()]) as TagVirtualNode['children']),\r\n      alt: rootFiber,\r\n      tag: isUpdate ? UPDATE_EFFECT_TAG : CREATE_EFFECT_TAG,\r\n    });\r\n\r\n    $scope.resetMount();\r\n    $scope.setWorkInProgress(fiber);\r\n    $scope.setIsHydrateZone(hydrate);\r\n    $scope.setNextUnitOfWork(fiber);\r\n  };\r\n\r\n  scheduler.schedule(callback, { priority: TaskPriority.NORMAL });\r\n}\r\n\r\nexport { render, roots, inject };\r\n","import { detectIsComponent } from '../component';\r\n\r\nconst $$shadow = Symbol('shadow');\r\n\r\nconst detectIsShadow = (instance: unknown) => detectIsComponent(instance) && instance.token === $$shadow;\r\n\r\nexport { $$shadow, detectIsShadow };\r\n","import type { DarkElement } from '../shared';\r\nimport { component } from '../component';\r\nimport { SHADOW_MASK } from '../constants';\r\nimport { useLayoutEffect } from '../use-layout-effect';\r\nimport { $$scope } from '../scope';\r\nimport { collectElements, getFiberWithElement } from '../walk';\r\nimport { platform, detectIsServer } from '../platform';\r\nimport { $$shadow } from './utils';\r\n\r\ntype ShadowProps = {\r\n  isVisible: boolean;\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Shadow = component<ShadowProps>(\r\n  ({ isVisible, slot }) => {\r\n    const isEnabled = !detectIsServer() && !$$scope().getIsHydrateZone();\r\n    const fiber = $$scope().getCursorFiber();\r\n\r\n    if (isEnabled) {\r\n      if (isVisible) {\r\n        fiber.mask &= ~SHADOW_MASK;\r\n      } else {\r\n        fiber.mask |= SHADOW_MASK;\r\n      }\r\n    }\r\n\r\n    useLayoutEffect(() => {\r\n      if (!isEnabled || !isVisible) return;\r\n      const $fiber = getFiberWithElement(fiber);\r\n      const fibers = collectElements(fiber, x => x);\r\n\r\n      for (const fiber of fibers) {\r\n        platform.insertElement(fiber.element, fiber.eidx, $fiber.element);\r\n      }\r\n    }, [isVisible]);\r\n\r\n    return slot || null;\r\n  },\r\n  { token: $$shadow },\r\n);\r\n\r\nexport { Shadow };\r\n","import type { DarkElement, SlotProps } from '../shared';\r\nimport { component } from '../component';\r\nimport { createContext, useContext } from '../context';\r\nimport { useMemo } from '../use-memo';\r\nimport { useState } from '../use-state';\r\nimport { useUpdate } from '../use-update';\r\nimport { useLayoutEffect } from '../use-layout-effect';\r\nimport { Fragment } from '../fragment';\r\nimport { $$scope } from '../scope';\r\nimport { detectIsServer } from '../platform';\r\nimport { Shadow } from '../shadow';\r\nimport { detectIsFiberAlive } from '../walk';\r\n\r\ntype SuspenseProps = {\r\n  fallback: DarkElement;\r\n} & Required<SlotProps>;\r\n\r\ntype SuspenseContextValue = {\r\n  isLoaded: boolean;\r\n  fallback: DarkElement;\r\n  update: () => void;\r\n  reg: () => void;\r\n  unreg: () => void;\r\n};\r\n\r\nconst SuspenseContext = createContext<SuspenseContextValue>({\r\n  isLoaded: false,\r\n  fallback: null,\r\n  update: () => {},\r\n  reg: () => {},\r\n  unreg: () => {},\r\n});\r\n\r\nconst Suspense = component<SuspenseProps>(({ fallback, slot }) => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (!fallback) {\r\n      throw new Error(`[Dark]: Suspense fallback not found!`);\r\n    }\r\n  }\r\n  const $scope = $$scope();\r\n  const emitter = $scope.getEmitter();\r\n  const { update: $$update } = useContext(SuspenseContext);\r\n  const [isLoaded, setIsLoaded] = useState(() => detectIsServer() || $scope.getIsHydrateZone());\r\n  const $update = useUpdate();\r\n  const scope = useMemo(() => ({ size: 0 }), []);\r\n  const fiber = $scope.getCursorFiber();\r\n  const update = () => (detectIsFiberAlive(fiber) ? $update() : $$update());\r\n  const value = useMemo<SuspenseContextValue>(\r\n    () => ({ isLoaded, fallback, update, reg: () => scope.size++, unreg: () => scope.size-- }),\r\n    [],\r\n  );\r\n\r\n  value.update = update;\r\n  value.isLoaded = isLoaded;\r\n  value.fallback = fallback;\r\n\r\n  useLayoutEffect(() => {\r\n    const off = emitter.on('finish', () => !isLoaded && scope.size === 0 && setIsLoaded(true));\r\n\r\n    return off;\r\n  }, []);\r\n\r\n  const content = isLoaded\r\n    ? [Shadow({ key: CONTENT, isVisible: true, slot })]\r\n    : [Shadow({ key: CONTENT, isVisible: false, slot }), Fragment({ key: FALLBACK, slot: fallback })];\r\n\r\n  return SuspenseContext.Provider({ value, slot: content });\r\n});\r\n\r\nconst CONTENT = 1;\r\nconst FALLBACK = 2;\r\n\r\nexport { SuspenseContext, Suspense };\r\n","import { type ComponentFactory, component } from '../component';\r\nimport { detectIsFunction, detectIsUndefined } from '../utils';\r\nimport { useContext } from '../context';\r\nimport { forwardRef } from '../ref';\r\nimport { SuspenseContext } from '../suspense';\r\nimport { useUpdate } from '../use-update';\r\nimport { $$scope } from '../scope';\r\nimport { $$lazy, $$loaded } from './utils';\r\nimport { detectIsFiberAlive } from '../walk';\r\n\r\nconst factoriesMap: Map<Function, ComponentFactory> = new Map();\r\n\r\nfunction lazy<P extends object, R = unknown>(module: () => Promise<LazyModule<P>>, done?: () => void) {\r\n  return forwardRef(\r\n    component<P, R>(\r\n      function type(props, ref) {\r\n        const { isLoaded, fallback, update: $$update, reg, unreg } = useContext(SuspenseContext);\r\n        const $update = useUpdate();\r\n        const factory = factoriesMap.get(module);\r\n        const fiber = $$scope().getCursorFiber();\r\n        const update = () => (detectIsFiberAlive(fiber) ? $update() : $$update());\r\n\r\n        if (detectIsUndefined(factory)) {\r\n          reg();\r\n          factoriesMap.set(module, null);\r\n          fetchModule(module).then(component => {\r\n            unreg();\r\n            type[$$loaded] = true;\r\n            factoriesMap.set(module, component);\r\n            !$$scope().getIsHydrateZone() && update();\r\n            detectIsFunction(done) && done();\r\n          });\r\n        }\r\n\r\n        return factory ? factory(props, ref) : isLoaded ? fallback : null;\r\n      },\r\n      { token: $$lazy },\r\n    ),\r\n  );\r\n}\r\n\r\nfunction fetchModule(module: () => Promise<LazyModule>) {\r\n  return new Promise<ComponentFactory>(resolve => {\r\n    module().then(module => {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (!module.default) {\r\n          throw new Error('[Dark]: Lazy loaded component should be exported as default!');\r\n        }\r\n      }\r\n\r\n      resolve(module.default);\r\n    });\r\n  });\r\n}\r\n\r\nexport type LazyModule<P extends object = {}> = {\r\n  default: ComponentFactory<P>;\r\n};\r\n\r\nexport { lazy, fetchModule };\r\n","import { detectIsFalsy, type SubscriberWithValue } from '@dark-engine/core';\r\n\r\nimport { normalaizePathname, parseURL } from '../utils';\r\n\r\nconst browserHistory = globalThis.history;\r\nclass RouterHistory {\r\n  private stack: Array<string> = [];\r\n  private cursor = -1;\r\n  private subscribers: Set<SubscriberWithValue<string>> = new Set();\r\n  private fromHistory = false;\r\n  public dispose: () => void = null;\r\n\r\n  constructor(url: string) {\r\n    if (detectIsFalsy(url)) {\r\n      throw new Error('[web-router]: RouterHistory must have initial url!');\r\n    }\r\n\r\n    const { pathname, search } = parseURL(url);\r\n    const spathname = pathname + search;\r\n\r\n    this.stack.push(spathname);\r\n    this.cursor = this.stack.length - 1;\r\n\r\n    if (browserHistory) {\r\n      const state = this.getState();\r\n\r\n      if (!state) {\r\n        browserHistory.replaceState(this.createStateBox(), '');\r\n      } else {\r\n        this.stack = state.stack;\r\n        this.cursor = state.cursor;\r\n      }\r\n\r\n      const handleEvent = () => {\r\n        const state = this.getState();\r\n\r\n        if (state) {\r\n          this.stack = state.stack;\r\n          this.cursor = state.cursor;\r\n        }\r\n\r\n        if (!this.fromHistory) {\r\n          this.mapSubscribers();\r\n        }\r\n\r\n        this.fromHistory = false;\r\n      };\r\n\r\n      window.addEventListener('popstate', handleEvent);\r\n\r\n      this.dispose = () => {\r\n        window.removeEventListener('popstate', handleEvent);\r\n        this.subscribers.clear();\r\n        this.stack = [];\r\n        this.cursor = -1;\r\n      };\r\n    }\r\n  }\r\n\r\n  private mapSubscribers() {\r\n    for (const subscriber of this.subscribers) {\r\n      subscriber(this.getValue());\r\n    }\r\n  }\r\n\r\n  private getValue = () => {\r\n    return normalaizePathname(this.stack[this.cursor]);\r\n  };\r\n\r\n  private getState(): State {\r\n    return (browserHistory.state && browserHistory.state[STATE_KEY]) || null;\r\n  }\r\n\r\n  private createStateBox(): StateBox {\r\n    const state = browserHistory.state || {};\r\n\r\n    return { ...state, [STATE_KEY]: { cursor: this.cursor, stack: this.stack } };\r\n  }\r\n\r\n  private syncHistory(action: HistoryAction, spathname: string) {\r\n    if (!browserHistory) return;\r\n    const stateBox = this.createStateBox();\r\n    const $spathname = normalaizePathname(spathname);\r\n\r\n    switch (action) {\r\n      case HistoryAction.PUSH:\r\n        return browserHistory.pushState(stateBox, '', $spathname);\r\n      case HistoryAction.REPLACE:\r\n        return browserHistory.replaceState(stateBox, '', $spathname);\r\n    }\r\n  }\r\n\r\n  public subscribe = (subscriber: SubscriberWithValue<string>) => {\r\n    this.subscribers.add(subscriber);\r\n\r\n    return () => this.subscribers.delete(subscriber);\r\n  };\r\n\r\n  public push(spathname: string) {\r\n    this.stack.splice(this.cursor + 1, this.stack.length, spathname);\r\n    this.cursor = this.stack.length - 1;\r\n    this.syncHistory(HistoryAction.PUSH, spathname);\r\n    this.mapSubscribers();\r\n  }\r\n\r\n  public replace(spathname: string) {\r\n    this.stack[this.stack.length - 1] = spathname;\r\n    this.syncHistory(HistoryAction.REPLACE, spathname);\r\n    this.mapSubscribers();\r\n  }\r\n\r\n  public forward() {\r\n    this.go(1);\r\n  }\r\n\r\n  public back() {\r\n    this.go(-1);\r\n  }\r\n\r\n  public go(delta: number) {\r\n    this.fromHistory = true;\r\n    this.cursor += delta;\r\n\r\n    if (this.cursor > this.stack.length - 1) {\r\n      this.cursor = this.stack.length - 1;\r\n    } else if (this.cursor < 0) {\r\n      this.cursor = 0;\r\n    }\r\n\r\n    browserHistory?.go(delta);\r\n    this.mapSubscribers();\r\n  }\r\n}\r\n\r\nenum HistoryAction {\r\n  PUSH = 'PUSH',\r\n  REPLACE = 'REPLACE',\r\n}\r\n\r\ntype StateBox = {\r\n  [STATE_KEY]: State;\r\n};\r\n\r\ntype State = {\r\n  cursor: number;\r\n  stack: Array<string>;\r\n};\r\n\r\nconst STATE_KEY = 'web-router';\r\n\r\nconst createRouterHistory = (url: string) => new RouterHistory(url);\r\n\r\nexport { RouterHistory, createRouterHistory };\r\n","import { detectIsFalsy } from '@dark-engine/core';\r\n\r\nimport { parseURL } from '../utils';\r\n\r\nclass RouterLocation {\r\n  public url: string;\r\n  public protocol: string;\r\n  public host: string;\r\n  public pathname: string;\r\n  public hash: string;\r\n  public search: string;\r\n  public key: string;\r\n\r\n  constructor(url: string) {\r\n    if (detectIsFalsy(url)) {\r\n      throw new Error('[web-router]: RouterLocation must have initial url!');\r\n    }\r\n\r\n    const { protocol, host, pathname, hash, search } = parseURL(url);\r\n\r\n    this.url = url;\r\n    this.protocol = protocol;\r\n    this.host = host;\r\n    this.pathname = pathname;\r\n    this.hash = hash;\r\n    this.search = search;\r\n    this.key = createKey(pathname);\r\n    Object.freeze(this);\r\n  }\r\n}\r\n\r\nfunction createKey(pathname: string): string {\r\n  return pathname\r\n    .split('')\r\n    .map(x => x.charCodeAt(0))\r\n    .reduce((acc, x) => ((acc += x), acc), 200000)\r\n    .toString(32);\r\n}\r\n\r\nconst createRouterLocation = (url: string) => new RouterLocation(url);\r\n\r\nexport { RouterLocation, createRouterLocation };\r\n","import {\r\n  type DarkElement,\r\n  type MutableRef,\r\n  h,\r\n  component,\r\n  useMemo,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useState,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n  nextTick,\r\n} from '@dark-engine/core';\r\n\r\nimport { SLASH_MARK, PROTOCOL_MARK } from '../constants';\r\nimport { normalaizePathname } from '../utils';\r\nimport { createRouterHistory } from '../history';\r\nimport { type RouterLocation, createRouterLocation } from '../location';\r\nimport { type Routes, createRoutes, resolveRoute, createPathname } from '../create-routes';\r\nimport {\r\n  type RouterHistoryContextValue,\r\n  type ActiveRouteContextValue,\r\n  RouterHistoryContext,\r\n  ActiveRouteContext,\r\n  useActiveRouteContext,\r\n} from '../context';\r\n\r\nexport type RouterProps = {\r\n  url?: string; // for server-side rendering\r\n  baseURL?: string;\r\n  routes: Routes;\r\n  slot: (slot: DarkElement) => DarkElement;\r\n};\r\n\r\nexport type RouterRef = {\r\n  navigateTo: (pathname: string) => void;\r\n  location: RouterLocation;\r\n};\r\n\r\nconst Router = forwardRef<RouterProps, RouterRef>(\r\n  component(\r\n    ({ url, baseURL = SLASH_MARK, routes: sourceRoutes, slot }, ref) => {\r\n      if (useActiveRouteContext()) {\r\n        throw new Error('[web-router]: Parent active route context detected!');\r\n      }\r\n      const sourceURL = url || window.location.href;\r\n      const [location, setLocation] = useState(() => createRouterLocation(sourceURL));\r\n      const history = useMemo(() => createRouterHistory(sourceURL), []);\r\n      const routes = useMemo(() => createRoutes(sourceRoutes, normalaizePathname(baseURL)), []);\r\n      const { protocol, host, pathname, search, hash } = location;\r\n      const { activeRoute, slot: $slot, params } = resolveRoute(pathname, routes);\r\n      const scope = useMemo(() => ({ location }), []);\r\n      const historyContext = useMemo<RouterHistoryContextValue>(() => ({ history }), []);\r\n      const routerContext = useMemo<ActiveRouteContextValue>(\r\n        () => ({ location, activeRoute, params }),\r\n        [pathname, search, hash],\r\n      );\r\n\r\n      scope.location = location;\r\n\r\n      useLayoutEffect(() => {\r\n        if (sourceURL !== scope.location.url) {\r\n          setLocation(createRouterLocation(sourceURL));\r\n        }\r\n      }, [sourceURL]);\r\n\r\n      useLayoutEffect(() => {\r\n        const unsubscribe = history.subscribe(spathname => {\r\n          const url = `${protocol}${PROTOCOL_MARK}${host}${spathname}`;\r\n\r\n          setLocation(createRouterLocation(url));\r\n        });\r\n\r\n        return () => {\r\n          unsubscribe();\r\n          history.dispose();\r\n        };\r\n      }, []);\r\n\r\n      useEffect(() => {\r\n        if (!activeRoute) return;\r\n        const spathname = pathname + search + hash;\r\n        const newSpathname = createPathname(pathname, activeRoute.getPath()) + search + hash;\r\n\r\n        if (spathname !== newSpathname) {\r\n          history.replace(newSpathname);\r\n        }\r\n      }, [pathname, search, hash]);\r\n\r\n      useImperativeHandle(ref as MutableRef<RouterRef>, () => ({\r\n        navigateTo: (pathname: string) => nextTick(() => history.push(pathname)),\r\n        location,\r\n      }));\r\n\r\n      return (\r\n        <RouterHistoryContext.Provider value={historyContext}>\r\n          <ActiveRouteContext.Provider value={routerContext}>{slot($slot)}</ActiveRouteContext.Provider>\r\n        </RouterHistoryContext.Provider>\r\n      );\r\n    },\r\n    { displayName: 'Router' },\r\n  ),\r\n);\r\n\r\nexport { Router };\r\n","import { useMemo } from '../use-memo';\r\nimport { type Ref, applyRef } from '../ref';\r\n\r\nfunction useImperativeHandle<T>(ref: Ref<T>, createHandle: () => T, deps?: Array<any>) {\r\n  const current = useMemo(() => createHandle(), deps || [{}]);\r\n\r\n  ref && applyRef(ref, current);\r\n}\r\n\r\nexport { useImperativeHandle };\r\n","import { h, component } from '@dark-engine/core';\r\n\r\nconst Spinner = component(() => (\r\n  <div class='sp-layout'>\r\n    <div class='sp sp-hydrogen'></div>\r\n  </div>\r\n));\r\n\r\nexport { Spinner };\r\n","import { type DarkElement, h, component, Suspense, lazy } from '@dark-engine/core';\r\nimport { type Routes, Router, RouterLink } from '@dark-engine/web-router';\r\n\r\nimport { Spinner } from './spinner';\r\n\r\nconst Home = lazy(() => import('./home'));\r\nconst HomeChildA = lazy(() => import('./child-a'));\r\nconst HomeChildB = lazy(() => import('./child-b'));\r\nconst HomeChildC = lazy(() => import('./child-c'));\r\nconst About = lazy(() => import('./about'));\r\nconst Contacts = lazy(() => import('./contacts'));\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: 'home/:id',\r\n    component: Home,\r\n    children: [\r\n      {\r\n        path: 'a',\r\n        component: HomeChildA,\r\n      },\r\n      {\r\n        path: 'b',\r\n        component: HomeChildB,\r\n      },\r\n      {\r\n        path: 'c',\r\n        component: HomeChildC,\r\n      },\r\n      {\r\n        path: '',\r\n        redirectTo: 'a',\r\n      },\r\n      {\r\n        path: '**',\r\n        redirectTo: 'a',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    path: 'about',\r\n    component: About,\r\n  },\r\n  {\r\n    path: 'contacts',\r\n    component: Contacts,\r\n  },\r\n  {\r\n    path: '**',\r\n    redirectTo: 'home/:id',\r\n  },\r\n];\r\n\r\ntype ShellProps = {\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Shell = component<ShellProps>(({ slot }) => {\r\n  return (\r\n    <Suspense fallback={<Spinner />}>\r\n      <header>\r\n        <RouterLink to='/home'>home</RouterLink>\r\n        <RouterLink to='/about'>about</RouterLink>\r\n        <RouterLink to='/contacts'>contacts</RouterLink>\r\n      </header>\r\n      <main>{slot}</main>\r\n    </Suspense>\r\n  );\r\n});\r\n\r\nexport type AppProps = {\r\n  url?: string;\r\n};\r\n\r\nconst App = component<AppProps>(({ url }) => {\r\n  return (\r\n    <Router routes={routes} url={url}>\r\n      {slot => <Shell>{slot}</Shell>}\r\n    </Router>\r\n  );\r\n});\r\n\r\nexport { App };\r\n","import { hydrateRoot, createRoot } from '@dark-engine/platform-browser';\r\n\r\nimport { App, type AppProps } from '../components/app';\r\n\r\nfunction bootstrap(hydrate = false, props: AppProps = {}) {\r\n  hydrate\r\n    ? hydrateRoot(document.getElementById('root'), App(props))\r\n    : createRoot(document.getElementById('root')).render(App(props));\r\n}\r\n\r\nexport { bootstrap };\r\n","import { type DarkElement } from '@dark-engine/core';\r\n\r\nimport { render } from '../render';\r\nimport { unmount } from '../create-root';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction hydrateRoot(container: TagNativeElement, element: DarkElement) {\r\n  render(element, container, true);\r\n\r\n  return {\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nexport { hydrateRoot };\r\n","import { type DarkElement, unmountRoot } from '@dark-engine/core';\r\n\r\nimport { render, roots } from '../render';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction createRoot(container: TagNativeElement) {\r\n  return {\r\n    render: (element: DarkElement) => render(element, container),\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nfunction unmount(container: TagNativeElement) {\r\n  const rootId = roots.get(container);\r\n\r\n  unmountRoot(rootId, () => {\r\n    roots.delete(container);\r\n    container.innerHTML = '';\r\n  });\r\n}\r\n\r\nexport { createRoot, unmount };\r\n","import { bootstrap } from './bootstrap/app.client';\r\n\r\nbootstrap(true);\r\n"],"names":["inProgress","$$inject","Symbol","Component","constructor","type","token","props","ref","shouldUpdate","displayName","children","this","component","options","$token","factory","defaultInject","detectIsComponent","x","getComponentKey","hasComponentFlag","inst","flag","Boolean","ROOT","REPLACER","INDEX_KEY","KEY_ATTR","REF_ATTR","CREATE_EFFECT_TAG","UPDATE_EFFECT_TAG","DELETE_EFFECT_TAG","SKIP_EFFECT_TAG","INSERTION_EFFECT_HOST_MASK","LAYOUT_EFFECT_HOST_MASK","ASYNC_EFFECT_HOST_MASK","ATOM_HOST_MASK","PORTAL_HOST_MASK","SHADOW_MASK","FLUSH_MASK","MOVE_MASK","HOOK_DELIMETER","RESTART_TIMEOUT","YIELD_INTERVAL","TaskPriority","Flag","ATTR_BLACK_LIST","SKIP_SCAN_OPT","MEMO_SLOT_OPT","STATIC_SLOT_OPT","createContext","defaultValue","context","Provider","Consumer","value","slot","fiber","getCursorFiber","provider","providerValue","subscribers","Set","subscribe","subscriber","add","delete","Map","set","get","forEach","fn","createProvider","useContext","createConsumer","nextFiber","parent","getProvider","update","scope","hasProvider","unsubscribe","Object","is","createElement","element","as","length","EventEmitter","on","e","has","emit","data","kill","__getSize","size","Fiber","hook","idx","id","cc","cec","eidx","mask","tag","child","next","alt","atoms","nextId","mutate","keys","key","markHost","increment","count","force","$scope","isUpdateZone","getIsUpdateZone","wipFiber","getWorkInProgress","stop","setError","error","catch","static","Hook","values","owner","getHook","prevInst","nextInst","$$fragment","Fragment","detectIsFragment","instance","$$lazy","$$loaded","detectIsLazy","detectIsLoaded","$$memo","detectIsMemo","defaultRealisation","Error","platform","insertElement","raf","caf","spawn","commit","finishCommit","detectIsDynamic","detectIsPortal","unmountPortal","chunk","detectIsServer","forwardRef","rest","applyRef","current","mutableRef","hasOwnProperty","detectIsMutableRef","MessageChannel","super","port1","port2","MessagePort","channel","offs","event","callback","off","push","postMessage","unref","Task","priority","forceAsync","taskRestorer","pendingSetter","nextTaskId","getPriority","getForceAsync","setIsTransition","isTransition","getIsTransition","run","pending","markAsPending","isPending","canPending","markAsUnnecessary","isUnnecessary","getIsUnnecessary","setTaskRestorer","setLocationCreator","locationCreator","createLocation","setPendingSetter","loc","tasks","some","$loc","split","$$loc","indexOf","createRootLocation","scheduler","queue","deadline","task","scheduledCallback","isMessageLoopRunning","port","performWorkUntilDeadline","bind","reset","shouldYield","schedule","setPendingStatus","put","execute","hasPrimaryTask","high","normal","low","getQueues","hasPrimary","hasLow","detectHasChildUpdate","detectHasSameUpdate","cancelTask","complete","defer","pick","shift","requestCallbackAsync","requestCallback","isBusy","unshift","Scope","root","wip","cursor","unit","mountDeep","mountLevel","mountNav","events","unsubs","actions","candidates","deletions","cancels","asyncEffects","layoutEffects","insertionEffects","isLayoutEffectsZone","isInsertionEffectsZone","isBatchZone","isHydrateZone","isStreamZone","isTransitionZone","isEventZone","isHot","isDynamic","emitter","resetActions","getActionsById","addActionMap","map","replace","insert","remove","move","stable","addReplaceAction","nextKey","addInsertAction","addRemoveAction","prevKey","addMoveAction","addStableAction","copy","getRoot","setRoot","setWorkInProgress","getNextUnitOfWork","setNextUnitOfWork","setCursorFiber","navToChild","navToSibling","navToParent","getMountIndex","getMountDeep","setMountDeep","resetMount","getEvents","addEventUnsubscriber","unsubscribeEvents","getCandidates","addCandidate","resetCandidates","getDeletions","hasDeletion","addDeletion","resetDeletions","addAsyncEffect","resetAsyncEffects","runAsyncEffects","effects","setTimeout","addLayoutEffect","resetLayoutEffects","runLayoutEffects","setIsLayoutEffectsZone","addInsertionEffect","resetInsertionEffects","runInsertionEffects","setIsInsertionEffectsZone","addCancel","applyCancels","i","resetCancels","getIsLayoutEffectsZone","getIsInsertionEffectsZone","setIsUpdateZone","getIsBatchZone","setIsBatchZone","getIsHydrateZone","setIsHydrateZone","getIsStreamZone","setIsStreamZone","getIsTransitionZone","setIsTransitionZone","getIsEventZone","setIsEventZone","getIsHot","setIsHot","getPendingStatusSetter","setPendingStatusSetter","flush","getEmitter","rootId","scopes","getRootId","setRootId","removeScope","replaceScope","assign","$$scope","combinedMask","shouldUnmountFiber","unmountFiber","skip","_","cleanup","unmountRoot","onCompleted","useCallback","deps","EffectType","$$useEffect","useEffect","dropEffects","createEffect","effect","undefined","isInsertionEffect","isLayoutEffect","isAsyncEffect","runEffect","$$useInsertionEffect","useInsertionEffect","dropInsertionEffects","$$useLayoutEffect","useLayoutEffect","dropLayoutEffects","defaultShouldUpdate","nextProps","Memo","memo","getValue","p","n","useMemo","state","$value","detectIsElement","useState","initialValue","setState","sourceValue","isBatch","prevValue","newValue","setValue","resetValue","useUpdate","createChanger","hasChanger","isEvent","callbackOptions","change","batch","timer","changes","clearTimeout","splice","addBatch","detectIsFunction","o","detectIsUndefined","detectIsString","detectIsTextBased","detectIsObject","detectIsBoolean","detectIsArray","Array","isArray","detectIsNull","detectIsEmpty","detectIsFalsy","getTime","Date","now","dummyFn","trueFn","sameFn","args","console","flatten","source","transform","list","stack","pop","keyBy","reduce","acc","detectAreDepsDifferent","prevDeps","nextDeps","max","Math","nextTick","Promise","resolve","then","createIndexKey","NodeType","$$vNode","ATTR_TYPE","VirtualNode","TagVirtualNode","name","attrs","TextVirtualNode","String","CommentVirtualNode","text","View","_void","Text","from","detectIsTextVirtualNode","detectIsVirtualNode","vNode","detectIsTagVirtualNode","detectIsCommentVirtualNode","detectIsVirtualNodeFactory","detectIsPlainVirtualNode","createReplacer","detectIsReplacer","getElementKey","hasElementFlag","hasVirtualNodeFactoryFlag","hasTagVirtualNodeFlag","getElementType","hasChildrenProp","detectAreSameInstanceTypes","isComponentFactories","nc","detectAreSameComponentTypesWithSameKeys","walk","onWalk","shouldDeep","shouldStop","collectElements","elements","getFiberWithElement","$fiber","detectIsFiberAlive","createHookLocation","tryOptStaticSlot","buildChildNode","tryOptMemoSlot","hasMove","hasRemove","hasInsert","hasReplace","pc","detectIsStableMemoTree","buildChildNodes","tryOptMov","tryOptRem","onNode","getKey","altMap","startEidx","prevIdx","nextIdx","left","right","isFirst","isLast","notifyParents","hasRenderError","workLoop","isAsync","hasMoreWork","performUnitOfWork","fork","unmounts","diff","parentFiber","isRight","sync","err","StopWork","isDeepWalking","isStream","hasChildren","$inst","createFiber","getAlternate","share","mountChild","mountSibling","shouldMount","mount","hasSameCount","prevKeys","nextKeys","prevKeysMap","nextKeysMap","keyedFibersMap","usedKeysMap","extractKeys","prevKeyFiber","reconcile","isUpdate","setup","fromChild","parentId","isMove","isStable","isComponent","result","supportConditional","cancel","$$scope$","createUpdate","$createChanger","restore","fromRestore","detectIsBusy","SLASH_MARK","PARAMETER_MARK","WILDCARD_MARK","PROTOCOL_MARK","SEARCH_MARK","HASH_MARK","ROOT_MARK","ActiveRouteContext","useActiveRouteContext","RouterHistoryContext","useRouterHistoryContext","CurrentPathContext","useCurrentPathContext","checkContextValue","Route","path","level","marker","prefix","redirectTo","pathMatch","rootPath","createRootPath","$path","createPath","createRoutes","route","getRoute","getPath","replaceAll","render","nextRoute","routes","$routes","$route","redirect","createMatcher","space","urlPath","routePath","sUrlPath","sRoutePath","segment","isRoot","isWildcard","isParam","createPathname","parts","param","newPathname","join","$prefix","resolveRoute","pathname","activeRoute","filter","detectIsMatchByFirstStrategy","b","matcher","detectIsMatchBySecondStrategy","a","match","detectIsMatchAsWildcard","wildcard","find","params","sPathname","sPath","getParamsMap","RouterLink","to","activeClassName","className","sourceClassName","onClick","history","hash","isActive","$to","$hash","detectIsActiveLink","cm","handleClick","useEvent","preventDefault","href","class","useHistory","useLocation","location","pipe","fns","fn1","fn2","parseURL","url","body","protocol","host","search","splitted","findIndex","idx1","addSlashToEnd","createSearch","createHash","detectIsParam","startsWith","getParamName","slice","splitPath","endsWith","normalaizePathname","spath","sort","selector","compare","trim","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","d","definition","defineProperty","enumerable","f","chunkId","all","promises","u","g","globalThis","Function","window","obj","prop","prototype","call","l","done","script","needAttach","scripts","document","getElementsByTagName","s","getAttribute","charset","timeout","setAttribute","src","onScriptComplete","prev","onerror","onload","doneFns","parentNode","removeChild","target","head","appendChild","r","toStringTag","scriptUrl","importScripts","currentScript","installedChunks","j","installedChunkData","promise","reject","errorType","realSrc","message","request","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","chunkLoadingGlobal","self","$$portal","getPortalContainer","textContent","SyntheticEvent","sourceEvent","propagation","stopPropagation","getPropagation","delegateEvent","eventName","handler","eventsMap","handlersMap","$handler","rootHandler","$event","parentElement","dispatchEvent","WeakMap","addEventListener","removeEventListener","detectIsEvent","attrName","getEventName","toLowerCase","STYLE_ATTR","CLASS_ATTR","CLASS_NAME_ATTR","moves","patches","svgTagNames","voidTagNames","createNativeElementMap","detectIsSvgElement","createElementNS","createTextNode","createComment","createNativeElement","node","setObjectStyle","style","setProperty","toggleAttribute","removeAttribute","patchProperties","tagName","attrValue","patchPropertiesSpecialCasesMap","getPrototypeOf","descriptor","getOwnPropertyDescriptor","canSetProperty","includes","input","checked","autofocus","focus","textarea","innerText","commitMap","childNodes","nativeElement","splitText","appendNativeElement","insertNativeElement","attrNames","tagElement","addAttributes","commitCreation","sourceNodes","sourceFragment","DocumentFragment","elementIdx","removeNativeElement","replaceNativeElement","prevInstance","nextInstance","prevNode","nextNode","prevAttrs","nextAttrs","getAttributeNames","prevAttrValue","nextAttrValue","updateAttributes","commitUpdate","innerHTML","sibling","insertBefore","insertNativeElementByIndex","candidate","replaceChild","roots","requestAnimationFrame","cancelAnimationFrame","isInjected","container","hydrate","isMounted","rootFiber","$$shadow","Shadow","isVisible","isEnabled","fibers","SuspenseContext","isLoaded","fallback","reg","unreg","Suspense","$$update","setIsLoaded","$update","content","CONTENT","FALLBACK","factoriesMap","lazy","default","fetchModule","browserHistory","RouterHistory","fromHistory","dispose","spathname","getState","replaceState","createStateBox","handleEvent","mapSubscribers","clear","STATE_KEY","syncHistory","action","stateBox","$spathname","HistoryAction","PUSH","pushState","REPLACE","forward","go","back","delta","RouterLocation","charCodeAt","toString","createKey","freeze","createRouterLocation","Router","baseURL","sourceRoutes","sourceURL","setLocation","createRouterHistory","$slot","historyContext","routerContext","newSpathname","createHandle","navigateTo","useImperativeHandle","Spinner","Shell","App","getElementById","unmount","createRoot","bootstrap"],"sourceRoot":""}