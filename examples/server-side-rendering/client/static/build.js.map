{"version":3,"file":"build.js","mappings":"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","sources":["webpack://dark-ssr-client/../../../packages/core/src/helpers/index.ts","webpack://dark-ssr-client/../../../packages/core/src/constants.ts","webpack://dark-ssr-client/../../../packages/core/src/view/types.ts","webpack://dark-ssr-client/../../../packages/core/src/view/view.ts","webpack://dark-ssr-client/../../../packages/core/src/element/element.ts","webpack://dark-ssr-client/../../../packages/core/src/platform/platform.ts","webpack://dark-ssr-client/../../../packages/core/src/scope/scope.ts","webpack://dark-ssr-client/../../../packages/core/src/component/component.ts","webpack://dark-ssr-client/../../../packages/core/src/memo/memo.ts","webpack://dark-ssr-client/../../../packages/core/src/fiber/types.ts","webpack://dark-ssr-client/../../../packages/core/src/use-effect/use-effect.ts","webpack://dark-ssr-client/../../../packages/core/src/use-layout-effect/use-layout-effect.ts","webpack://dark-ssr-client/../../../packages/core/src/use-insertion-effect/use-insertion-effect.ts","webpack://dark-ssr-client/../../../packages/core/src/walk/walk.ts","webpack://dark-ssr-client/../../../packages/core/src/unmount/unmount.ts","webpack://dark-ssr-client/../../../packages/core/src/fragment/fragment.ts","webpack://dark-ssr-client/../../../packages/core/src/fiber/fiber.ts","webpack://dark-ssr-client/../../../packages/core/src/ref/ref.ts","webpack://dark-ssr-client/../../../packages/core/src/use-memo/use-memo.ts","webpack://dark-ssr-client/../../../packages/platform-browser/src/portal/portal.tsx","webpack://dark-ssr-client/../../../packages/platform-browser/src/events/events.ts","webpack://dark-ssr-client/../../../packages/platform-browser/src/dom/dom.ts","webpack://dark-ssr-client/../../../packages/platform-browser/src/constants.ts","webpack://dark-ssr-client/../../../packages/platform-browser/src/scheduler/scheduler.ts","webpack://dark-ssr-client/../../../packages/platform-browser/src/render/render.ts","webpack://dark-ssr-client/../../../packages/core/src/use-update/use-update.ts","webpack://dark-ssr-client/../../../packages/core/src/batch/batch.ts","webpack://dark-ssr-client/./app.tsx","webpack://dark-ssr-client/../../../packages/core/src/use-state/use-state.ts","webpack://dark-ssr-client/../../../packages/core/src/use-callback/use-callback.ts","webpack://dark-ssr-client/../../../packages/platform-browser/src/hydrate-root/hydrate-root.tsx","webpack://dark-ssr-client/./index.tsx"],"sourcesContent":["import type { NestedArray } from '../shared';\r\n\r\nconst detectIsFunction = (o: any): o is Function => typeof o === 'function';\r\n\r\nconst detectIsUndefined = (o: any): o is undefined => typeof o === 'undefined';\r\n\r\nconst detectIsNumber = (o: any): o is number => typeof o === 'number';\r\n\r\nconst detectIsString = (o: any): o is string => typeof o === 'string';\r\n\r\nconst detectIsObject = (o: any): o is object => typeof o === 'object';\r\n\r\nconst detectIsBoolean = (o: any): o is boolean => typeof o === 'boolean';\r\n\r\nconst detectIsArray = (o: any): o is Array<any> => Array.isArray(o);\r\n\r\nconst detectIsNull = (o: any): o is null => o === null;\r\n\r\nconst detectIsEmpty = (o: any) => detectIsNull(o) || detectIsUndefined(o);\r\n\r\nconst detectIsFalsy = (o: any) => detectIsNull(o) || detectIsUndefined(o) || o === false;\r\n\r\nconst getTime = () => Date.now();\r\n\r\nconst dummyFn = () => {};\r\n\r\nfunction error(...args: Array<any>) {\r\n  !detectIsUndefined(console) && console.error(...args);\r\n}\r\n\r\nfunction flatten<T = any>(source: Array<NestedArray<T>>): Array<T> {\r\n  const list = [];\r\n  const levelMap = { 0: { idx: 0, source } };\r\n  let level = 0;\r\n\r\n  do {\r\n    const { source, idx } = levelMap[level];\r\n    const item = source[idx];\r\n\r\n    if (idx >= source.length) {\r\n      level--;\r\n      levelMap[level].idx++;\r\n      continue;\r\n    }\r\n\r\n    if (detectIsArray(item)) {\r\n      level++;\r\n      levelMap[level] = {\r\n        idx: 0,\r\n        source: item,\r\n      };\r\n    } else {\r\n      list.push(item);\r\n      levelMap[level].idx++;\r\n    }\r\n  } while (level > 0 || levelMap[level].idx < levelMap[level].source.length);\r\n\r\n  return list;\r\n}\r\n\r\nfunction keyBy<T = any>(\r\n  list: Array<T>,\r\n  fn: (o: T) => string | number,\r\n  value = false,\r\n): Record<string | number, T | boolean> {\r\n  return list.reduce((acc, x) => ((acc[fn(x)] = value ? x : true), acc), {});\r\n}\r\n\r\nfunction detectIsDepsDifferent(deps: Array<unknown>, prevDeps: Array<unknown>): boolean {\r\n  if (!detectIsUndefined(deps) && !detectIsUndefined(prevDeps) && deps.length > 0 && prevDeps.length > 0) {\r\n    for (let i = 0; i < prevDeps.length; i++) {\r\n      if (prevDeps[i] !== deps[i]) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport {\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsNumber,\r\n  detectIsString,\r\n  detectIsObject,\r\n  detectIsBoolean,\r\n  detectIsArray,\r\n  detectIsNull,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  getTime,\r\n  dummyFn,\r\n  error,\r\n  flatten,\r\n  keyBy,\r\n  detectIsDepsDifferent,\r\n};\r\n","export const ROOT = 'root';\r\nexport const REPLACER = 'dark:matter';\r\nexport const INDEX_KEY = 'dark:idx';\r\nexport const TYPE = 'type';\r\nexport const ATTR_KEY = 'key';\r\nexport const ATTR_REF = 'ref';\r\nexport const ATTR_FLAG = 'flag';\r\n\r\nexport enum TaskPriority {\r\n  ANIMATION = 3,\r\n  HIGH = 2,\r\n  NORMAL = 1,\r\n  LOW = 0,\r\n}\r\n\r\nexport enum Flag {\r\n  HAS_NO_MOVES = 'HAS_NO_MOVES',\r\n}\r\n","import { SlotProps, RefProps, KeyProps, FlagProps } from '../shared';\r\n\r\nexport type ViewDef = {\r\n  as: string;\r\n  _void?: boolean;\r\n  [prop: string]: any;\r\n} & Partial<SlotProps> &\r\n  RefProps &\r\n  KeyProps &\r\n  FlagProps;\r\n\r\nexport enum NodeType {\r\n  TAG = 'TAG',\r\n  TEXT = 'TEXT',\r\n  COMMENT = 'COMMENT',\r\n}\r\n","import { REPLACER, ATTR_KEY, ATTR_FLAG, TYPE, Flag } from '../constants';\r\nimport { detectIsArray, detectIsEmpty, detectIsFunction } from '../helpers';\r\nimport type { DarkElementKey, DarkElement } from '../shared';\r\nimport type { ComponentFactory } from '../component';\r\nimport { NodeType, type ViewDef } from './types';\r\n\r\nexport type VirtualNodeFactory = () => VirtualNode;\r\nexport type TagVirtualNodeFactory = () => TagVirtualNode;\r\nexport type TextVirtualNodeFactory = () => TextVirtualNode;\r\nexport type CommentVirtualNodeFactory = () => CommentVirtualNode;\r\n\r\nconst $$virtualNode = Symbol('virtual-node');\r\n\r\nclass VirtualNode {\r\n  public type: NodeType = null;\r\n\r\n  constructor(type: NodeType) {\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nclass TagVirtualNode extends VirtualNode {\r\n  public name: string = null;\r\n  public attrs: Record<string, any> = {};\r\n  public children: Array<VirtualNodeFactory | ComponentFactory> = [];\r\n\r\n  constructor(name: string, attrs: TagVirtualNode['attrs'], children: TagVirtualNode['children']) {\r\n    super(NodeType.TAG);\r\n    this.name = name || this.name;\r\n    this.attrs = attrs || this.attrs;\r\n    this.children = children || this.children;\r\n  }\r\n}\r\n\r\nclass TextVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.TEXT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nclass CommentVirtualNode extends VirtualNode {\r\n  public value = '';\r\n\r\n  constructor(text: string) {\r\n    super(NodeType.COMMENT);\r\n    this.value = text;\r\n  }\r\n}\r\n\r\nconst detectIsVirtualNode = (vNode: unknown): vNode is VirtualNode => vNode instanceof VirtualNode;\r\n\r\nconst detectIsTagVirtualNode = (vNode: unknown): vNode is TagVirtualNode => vNode instanceof TagVirtualNode;\r\n\r\nconst detectIsCommentVirtualNode = (vNode: unknown): vNode is CommentVirtualNode => vNode instanceof CommentVirtualNode;\r\n\r\nconst detectIsTextVirtualNode = (vNode: unknown): vNode is TextVirtualNode => vNode instanceof TextVirtualNode;\r\n\r\nconst detectIsVirtualNodeFactory = (factory: unknown): factory is VirtualNodeFactory =>\r\n  detectIsFunction(factory) && factory[$$virtualNode] === true;\r\n\r\nconst getTagVirtualNodeKey = (vNode: TagVirtualNode): DarkElementKey | null =>\r\n  !detectIsEmpty(vNode.attrs[ATTR_KEY]) ? vNode.attrs[ATTR_KEY] : null;\r\n\r\nconst getTagVirtualNodeFlag = (vNode: TagVirtualNode): Record<Flag, boolean> | null => vNode.attrs[ATTR_FLAG] || null;\r\n\r\nconst getVirtualNodeFactoryKey = (factory: VirtualNodeFactory): DarkElementKey | null =>\r\n  !detectIsEmpty(factory[ATTR_KEY]) ? factory[ATTR_KEY] : null;\r\n\r\nconst getVirtualNodeFactoryFlag = (factory: VirtualNodeFactory): Record<Flag, boolean> | null =>\r\n  factory[ATTR_FLAG] || null;\r\n\r\nconst createReplacer = () => new CommentVirtualNode(REPLACER);\r\n\r\nfunction View(def: ViewDef): TagVirtualNodeFactory {\r\n  const factory = () => {\r\n    const { as: name, slot, _void = false, ...attrs } = def;\r\n    const children = (_void ? [] : detectIsArray(slot) ? slot : slot ? [slot] : []) as TagVirtualNode['children'];\r\n\r\n    return new TagVirtualNode(name, attrs, children);\r\n  };\r\n\r\n  factory[$$virtualNode] = true;\r\n  factory[ATTR_KEY] = def.key;\r\n  factory[ATTR_FLAG] = def.flag;\r\n  factory[TYPE] = def.as;\r\n\r\n  return factory;\r\n}\r\n\r\nfunction Text(source: string | number): TextVirtualNode {\r\n  return new TextVirtualNode(source + '');\r\n}\r\n\r\nText.from = (source: DarkElement) => (detectIsTextVirtualNode(source) ? source.value : source + '');\r\n\r\nfunction Comment(text: string): CommentVirtualNodeFactory {\r\n  const factory = () => new CommentVirtualNode(text);\r\n\r\n  factory[$$virtualNode] = true;\r\n\r\n  return factory;\r\n}\r\n\r\nexport {\r\n  VirtualNode,\r\n  TagVirtualNode,\r\n  TextVirtualNode,\r\n  CommentVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  getTagVirtualNodeKey,\r\n  getTagVirtualNodeFlag,\r\n  getVirtualNodeFactoryKey,\r\n  getVirtualNodeFactoryFlag,\r\n  createReplacer,\r\n  detectIsVirtualNodeFactory,\r\n  View,\r\n  Text,\r\n  Comment,\r\n};\r\n","import { detectIsNumber, detectIsString, detectIsFunction } from '../helpers';\r\nimport { View, Text, type TagVirtualNodeFactory } from '../view';\r\nimport { type ComponentFactory } from '../component';\r\n\r\nfunction getChildren(children: Array<any>) {\r\n  children = children.map(x => (detectIsString(x) || detectIsNumber(x) ? Text(x.toString()) : x));\r\n\r\n  return children ? (Array.isArray(children) ? [...children] : [children]) : [];\r\n}\r\n\r\nfunction createElement(\r\n  tag: string | Function,\r\n  props: any,\r\n  ...children: Array<any>\r\n): ComponentFactory | TagVirtualNodeFactory | null {\r\n  if (detectIsString(tag)) {\r\n    return View({\r\n      ...props,\r\n      as: tag,\r\n      slot: getChildren(children),\r\n    });\r\n  }\r\n\r\n  if (detectIsFunction(tag)) {\r\n    let slot = getChildren(children);\r\n\r\n    slot = slot.length === 1 ? slot[0] : slot;\r\n\r\n    return tag({ ...props, slot });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport { createElement, createElement as h };\r\n","import type { Platform } from './types';\r\n\r\nconst platform: Platform = {\r\n  createNativeElement: () => {\r\n    throw new Error('createNativeElement not installed by renderer');\r\n  },\r\n  requestAnimationFrame: () => {\r\n    throw new Error('requestAnimationFrame not installed by renderer');\r\n  },\r\n  cancelAnimationFrame: () => {\r\n    throw new Error('cancelAnimationFrame not installed by renderer');\r\n  },\r\n  scheduleCallback: () => {\r\n    throw new Error('scheduleCallback not installed by renderer');\r\n  },\r\n  shouldYeildToHost: () => {\r\n    throw new Error('shouldYeildToHost not installed by renderer');\r\n  },\r\n  applyCommit: () => {\r\n    throw new Error('applyCommit not installed by renderer');\r\n  },\r\n  finishCommitWork: () => {\r\n    throw new Error('finishCommitWork not installed by renderer');\r\n  },\r\n  detectIsDynamic: () => {\r\n    throw new Error('detectIsDynamic not installed by renderer');\r\n  },\r\n  detectIsPortal: () => {\r\n    throw new Error('detectIsPortal not installed by renderer');\r\n  },\r\n  unmountPortal: () => {\r\n    throw new Error('unmountPortal not installed by renderer');\r\n  },\r\n};\r\n\r\nconst detectIsServer = () => !platform.detectIsDynamic();\r\n\r\nexport { platform, detectIsServer };\r\n","import type { Fiber } from '../fiber';\r\n\r\nlet rootId: number = null;\r\n\r\nconst stores = new Map<number, Store>();\r\n\r\nclass Store {\r\n  public wipRoot: Fiber = null;\r\n  public currentRoot: Fiber = null;\r\n  public nextUnitOfWork: Fiber = null;\r\n  public events: Map<string, WeakMap<object, Function>> = new Map();\r\n  public unsubscribers: Array<() => void> = [];\r\n  public deletions: Set<Fiber> = new Set();\r\n  public fiberMount: FiberMountStore = {\r\n    level: 0,\r\n    navigation: {},\r\n    isDeepWalking: true,\r\n  };\r\n  public componentFiber: Fiber = null;\r\n  public effects: Array<() => void> = [];\r\n  public layoutEffects: Array<() => void> = [];\r\n  public insertionEffects: Array<() => void> = [];\r\n  public isLayoutEffectsZone = false;\r\n  public isInserionEffectsZone = false;\r\n  public isUpdateHookZone = false;\r\n  public isBatchZone = false;\r\n  public isHydrateZone = false;\r\n}\r\n\r\ntype FiberMountStore = {\r\n  level: number;\r\n  navigation: Record<number, number>;\r\n  isDeepWalking: boolean;\r\n};\r\n\r\nconst rootStore = {\r\n  set: (id: number) => {\r\n    rootId = id;\r\n    !stores.get(rootId) && stores.set(rootId, new Store());\r\n  },\r\n  remove: (id: number) => stores.delete(id),\r\n};\r\n\r\nconst getRootId = () => rootId;\r\n\r\nconst store = {\r\n  get: (id: number = rootId) => stores.get(id),\r\n};\r\n\r\nconst wipRootStore = {\r\n  get: () => store.get()?.wipRoot || null,\r\n  set: (fiber: Fiber) => (store.get().wipRoot = fiber),\r\n};\r\n\r\nconst currentRootStore = {\r\n  get: (id?: number) => store.get(id)?.currentRoot || null,\r\n  set: (fiber: Fiber) => (store.get().currentRoot = fiber),\r\n};\r\n\r\nconst nextUnitOfWorkStore = {\r\n  get: () => store.get()?.nextUnitOfWork || null,\r\n  set: (fiber: Fiber) => (store.get().nextUnitOfWork = fiber),\r\n};\r\n\r\nconst currentFiberStore = {\r\n  get: () => store.get()?.componentFiber,\r\n  set: (fiber: Fiber) => (store.get().componentFiber = fiber),\r\n};\r\n\r\nconst eventsStore = {\r\n  get: () => store.get().events,\r\n  addUnsubscriber: (fn: () => void) => store.get().unsubscribers.push(fn),\r\n  unsubscribe: (id: number) => store.get(id).unsubscribers.forEach(fn => fn()),\r\n};\r\n\r\nconst deletionsStore = {\r\n  get: () => store.get().deletions,\r\n  add: (fiber: Fiber) => store.get().deletions.add(fiber),\r\n  has: (fiber: Fiber) => store.get().deletions.has(fiber),\r\n  set: (deletions: Set<Fiber>) => (store.get().deletions = deletions),\r\n  reset: () => (store.get().deletions = new Set()),\r\n};\r\n\r\nconst fiberMountStore = {\r\n  reset: () => {\r\n    store.get().fiberMount = {\r\n      level: 0,\r\n      navigation: {},\r\n      isDeepWalking: true,\r\n    };\r\n  },\r\n  getIndex: () => store.get().fiberMount.navigation[store.get().fiberMount.level],\r\n  jumpToChild: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level + 1;\r\n\r\n    fiberMount.level = nextLevel;\r\n    fiberMount.navigation[nextLevel] = 0;\r\n  },\r\n  jumpToParent: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const nextLevel = level - 1;\r\n\r\n    fiberMount.navigation[level] = 0;\r\n    fiberMount.level = nextLevel;\r\n  },\r\n  jumpToSibling: () => {\r\n    const { fiberMount } = store.get();\r\n    const level = fiberMount.level;\r\n    const idx = fiberMount.navigation[level] + 1;\r\n\r\n    fiberMount.navigation[level] = idx;\r\n  },\r\n  deepWalking: {\r\n    get: () => store.get().fiberMount.isDeepWalking,\r\n    set: (value: boolean) => (store.get().fiberMount.isDeepWalking = value),\r\n  },\r\n};\r\n\r\nconst effectsStore = {\r\n  get: () => store.get().effects,\r\n  reset: () => (store.get().effects = []),\r\n  add: (effect: () => void) => store.get().effects.push(effect),\r\n};\r\n\r\nconst layoutEffectsStore = {\r\n  get: () => store.get().layoutEffects,\r\n  reset: () => (store.get().layoutEffects = []),\r\n  add: (effect: () => void) => store.get().layoutEffects.push(effect),\r\n};\r\n\r\nconst insertionEffectsStore = {\r\n  get: () => store.get().insertionEffects,\r\n  reset: () => (store.get().insertionEffects = []),\r\n  add: (effect: () => void) => store.get().insertionEffects.push(effect),\r\n};\r\n\r\nconst isLayoutEffectsZone = {\r\n  get: () => store.get()?.isLayoutEffectsZone || false,\r\n  set: (value: boolean) => (store.get().isLayoutEffectsZone = value),\r\n};\r\n\r\nconst isInsertionEffectsZone = {\r\n  get: (id?: number) => store.get(id)?.isInserionEffectsZone || false,\r\n  set: (value: boolean) => (store.get().isInserionEffectsZone = value),\r\n};\r\n\r\nconst isUpdateHookZone = {\r\n  get: () => store.get()?.isUpdateHookZone || false,\r\n  set: (value: boolean) => (store.get().isUpdateHookZone = value),\r\n};\r\n\r\nconst isBatchZone = {\r\n  get: () => store.get()?.isBatchZone || false,\r\n  set: (value: boolean) => (store.get().isBatchZone = value),\r\n};\r\n\r\nconst isHydrateZone = {\r\n  get: () => store.get()?.isHydrateZone || false,\r\n  set: (value: boolean) => (store.get().isHydrateZone = value),\r\n};\r\n\r\nexport {\r\n  getRootId,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  currentFiberStore,\r\n  eventsStore,\r\n  deletionsStore,\r\n  fiberMountStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  insertionEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isInsertionEffectsZone,\r\n  isUpdateHookZone,\r\n  isBatchZone,\r\n  isHydrateZone,\r\n};\r\n","import { ATTR_KEY, ATTR_FLAG, Flag } from '../constants';\r\nimport type { DarkElementKey, DarkElementInstance } from '../shared';\r\nimport { error, detectIsEmpty } from '../helpers';\r\nimport type { Ref } from '../ref';\r\nimport type { CreateElement, ComponentOptions, ShouldUpdate, StandardComponentProps } from './types';\r\n\r\nconst $$component = Symbol('component');\r\nconst defaultOptions: ComponentOptions<any> = {\r\n  displayName: '',\r\n  defaultProps: {},\r\n  token: $$component,\r\n};\r\nclass ComponentFactory<P extends StandardComponentProps = any, R = any> {\r\n  public type: CreateElement<P>;\r\n  public token: Symbol;\r\n  public props: P;\r\n  public ref: Ref<R>;\r\n  public displayName: string;\r\n  public children: Array<DarkElementInstance> = [];\r\n  public shouldUpdate?: ShouldUpdate<P>;\r\n\r\n  constructor(\r\n    type: CreateElement<P>,\r\n    token: Symbol,\r\n    props: P,\r\n    ref: Ref<R>,\r\n    shouldUpdate: ShouldUpdate<P>,\r\n    displayName: string,\r\n  ) {\r\n    this.type = type || null;\r\n    this.token = token || null;\r\n    this.props = props || null;\r\n    this.ref = ref || null;\r\n    this.shouldUpdate = shouldUpdate || null;\r\n    this.displayName = displayName || '';\r\n  }\r\n}\r\n\r\nfunction createComponent<P, R = unknown>(type: CreateElement<P, R>, options: ComponentOptions<P> = {}) {\r\n  const computedOptions = { ...defaultOptions, ...options } as ComponentOptions<P>;\r\n  const { token, defaultProps, displayName, shouldUpdate } = computedOptions;\r\n  const component = (\r\n    props = {} as P & StandardComponentProps,\r\n    ref?: Ref<R>,\r\n  ): ComponentFactory<P & StandardComponentProps> => {\r\n    const mprops = { ...defaultProps, ...props };\r\n\r\n    if (mprops.ref) {\r\n      delete mprops.ref;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        error(`[Dark]: To use ref you need to wrap the createComponent with forwardRef!`);\r\n      }\r\n    }\r\n\r\n    return new ComponentFactory(type, token, mprops, ref, shouldUpdate, displayName);\r\n  };\r\n\r\n  return component;\r\n}\r\n\r\nconst detectIsComponentFactory = (factory: unknown): factory is ComponentFactory => factory instanceof ComponentFactory;\r\n\r\nconst getComponentFactoryKey = (factory: ComponentFactory): DarkElementKey =>\r\n  !detectIsEmpty(factory.props[ATTR_KEY]) ? factory.props[ATTR_KEY] : null;\r\n\r\nconst getComponentFactoryFlag = (factory: ComponentFactory): Record<Flag, boolean> | null =>\r\n  factory.props[ATTR_FLAG] || null;\r\n\r\nexport { ComponentFactory, createComponent, detectIsComponentFactory, getComponentFactoryKey, getComponentFactoryFlag };\r\n","import {\r\n  type Component,\r\n  type ComponentFactory,\r\n  type StandardComponentProps,\r\n  type ShouldUpdate,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n} from '../component';\r\nimport type { RefProps, SlotProps } from '../shared';\r\nimport { type Ref, forwardRef } from '../ref';\r\n\r\nconst $$memo = Symbol('memo');\r\n\r\nconst defaultShouldUpdate = (props: {}, nextProps: {}): boolean => {\r\n  const keys = Object.keys(nextProps);\r\n\r\n  for (const key of keys) {\r\n    if (key !== 'slot' && nextProps[key] !== props[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst detectIsMemo = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$memo;\r\n\r\nfunction memo<T>(\r\n  component: (props?: T, ref?: Ref) => ComponentFactory<T>,\r\n  shouldUpdate: ShouldUpdate<T & SlotProps> = defaultShouldUpdate,\r\n): Component<T & StandardComponentProps> {\r\n  return forwardRef(\r\n    createComponent(\r\n      (props: T & RefProps, ref) => {\r\n        ref && (props.ref = ref);\r\n\r\n        return component(props);\r\n      },\r\n      { token: $$memo, shouldUpdate },\r\n    ),\r\n  );\r\n}\r\n\r\nexport { $$memo, memo, detectIsMemo };\r\n","export enum EffectTag {\r\n  CREATE = 'CREATE',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE',\r\n  SKIP = 'SKIP',\r\n}\r\n\r\nexport type NativeElement = unknown;\r\n\r\nexport type HookValue<T = any> = {\r\n  token?: Symbol;\r\n  deps: Array<any>;\r\n  value: T;\r\n};\r\n\r\nexport type Hook<T = any> = {\r\n  idx: number;\r\n  values: Array<T>;\r\n};\r\n\r\nexport const cloneTagMap = {\r\n  [EffectTag.CREATE]: true,\r\n  [EffectTag.SKIP]: true,\r\n};\r\n","import { detectIsUndefined, detectIsFunction, detectIsDepsDifferent } from '../helpers';\r\nimport { currentFiberStore, effectsStore } from '../scope';\r\nimport type { Fiber, Hook, HookValue } from '../fiber';\r\nimport type { Effect, DropEffect } from './types';\r\n\r\nconst $$useEffect = Symbol('use-effect');\r\n\r\nconst { useEffect, hasEffects, dropEffects } = createEffect($$useEffect, effectsStore);\r\n\r\nfunction createEffect(token: Symbol, store: typeof effectsStore) {\r\n  function useEffect(effect: Effect, deps?: Array<any>) {\r\n    const fiber = currentFiberStore.get();\r\n    const hook = fiber.hook as Hook<HookValue<DropEffect>>;\r\n    const { idx, values } = hook;\r\n    const runEffect = () => {\r\n      values[idx] = {\r\n        deps,\r\n        token,\r\n        value: undefined,\r\n      };\r\n\r\n      store.add(() => {\r\n        values[idx].value = effect();\r\n      });\r\n    };\r\n\r\n    if (detectIsUndefined(values[idx])) {\r\n      runEffect();\r\n    } else {\r\n      const { deps: prevDeps, value: cleanup } = values[idx];\r\n      const isDepsDifferent = deps ? detectIsDepsDifferent(deps, prevDeps) : true;\r\n\r\n      if (isDepsDifferent) {\r\n        detectIsFunction(cleanup) && cleanup();\r\n        runEffect();\r\n      }\r\n    }\r\n\r\n    hook.idx++;\r\n  }\r\n\r\n  function hasEffects(fiber: Fiber) {\r\n    const { values } = fiber.hook as Hook<HookValue>;\r\n    const hasEffect = values.some(x => x?.token === token);\r\n\r\n    return hasEffect;\r\n  }\r\n\r\n  function dropEffects(hook: Hook<HookValue<DropEffect>>) {\r\n    const { values } = hook;\r\n\r\n    for (const value of values) {\r\n      if (value.token === token) {\r\n        const cleanup = value.value;\r\n\r\n        detectIsFunction(cleanup) && cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    useEffect,\r\n    hasEffects,\r\n    dropEffects,\r\n  };\r\n}\r\n\r\nexport { useEffect, hasEffects, dropEffects, createEffect };\r\n","import { layoutEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useLayoutEffect = Symbol('use-layout-effect');\r\n\r\nconst {\r\n  useEffect: useLayoutEffect,\r\n  hasEffects: hasLayoutEffects,\r\n  dropEffects: dropLayoutEffects,\r\n} = createEffect($$useLayoutEffect, layoutEffectsStore);\r\n\r\nexport { useLayoutEffect, hasLayoutEffects, dropLayoutEffects };\r\n","import { insertionEffectsStore } from '../scope';\r\nimport { createEffect } from '../use-effect';\r\n\r\nconst $$useInsertionEffect = Symbol('use-insertion-effect');\r\n\r\nconst {\r\n  useEffect: useInsertionEffect,\r\n  hasEffects: hasInsertionEffects,\r\n  dropEffects: dropInsertionEffects,\r\n} = createEffect($$useInsertionEffect, insertionEffectsStore);\r\n\r\nexport { useInsertionEffect, hasInsertionEffects, dropInsertionEffects };\r\n","import { type Fiber } from '../fiber';\r\n\r\ntype OnLoopOptions<T> = {\r\n  nextFiber: Fiber<T>;\r\n  isReturn: boolean;\r\n  resetIsDeepWalking: () => void;\r\n  stop: () => void;\r\n};\r\n\r\nfunction walkFiber<T = unknown>(fiber: Fiber<T>, onLoop: (options: OnLoopOptions<T>) => void) {\r\n  let nextFiber = fiber;\r\n  let isDeepWalking = true;\r\n  let isReturn = false;\r\n  let isStopped = false;\r\n  const visitedMap: Record<number, boolean> = {};\r\n  const detectCanVisit = (id: number) => !visitedMap[id];\r\n  const resetIsDeepWalking = () => (isDeepWalking = false);\r\n  const stop = () => (isStopped = true);\r\n\r\n  while (nextFiber) {\r\n    onLoop({\r\n      nextFiber: nextFiber as Fiber<T>,\r\n      isReturn,\r\n      resetIsDeepWalking,\r\n      stop,\r\n    });\r\n\r\n    if (isStopped) {\r\n      break;\r\n    }\r\n\r\n    if (nextFiber.child && isDeepWalking && detectCanVisit(nextFiber.child.id)) {\r\n      const newFiber = nextFiber.child;\r\n\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (nextFiber.nextSibling && detectCanVisit(nextFiber.nextSibling.id)) {\r\n      const newFiber = nextFiber.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (\r\n      nextFiber.parent &&\r\n      nextFiber.parent === fiber &&\r\n      nextFiber.parent.nextSibling &&\r\n      detectCanVisit(nextFiber.parent.nextSibling.id)\r\n    ) {\r\n      const newFiber = nextFiber.parent.nextSibling;\r\n\r\n      isDeepWalking = true;\r\n      isReturn = false;\r\n      nextFiber = newFiber;\r\n      visitedMap[newFiber.id] = true;\r\n    } else if (nextFiber.parent && nextFiber.parent !== fiber) {\r\n      isDeepWalking = false;\r\n      isReturn = true;\r\n      nextFiber = nextFiber.parent;\r\n    } else {\r\n      nextFiber = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport { walkFiber };\r\n","import { type Fiber } from '../fiber';\r\nimport { platform } from '../platform';\r\nimport { detectIsComponentFactory } from '../component';\r\nimport { dropEffects } from '../use-effect';\r\nimport { dropLayoutEffects } from '../use-layout-effect';\r\nimport { dropInsertionEffects } from '../use-insertion-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { detectIsUndefined } from '../helpers';\r\nimport { currentRootStore, eventsStore, rootStore } from '../scope';\r\n\r\nfunction unmountFiber(fiber: Fiber) {\r\n  if (!fiber.insertionEffectHost && !fiber.layoutEffectHost && !fiber.effectHost && !fiber.portalHost) return;\r\n\r\n  walkFiber(fiber, ({ nextFiber, isReturn, stop }) => {\r\n    if (nextFiber === fiber.nextSibling) return stop();\r\n    if (!isReturn && detectIsComponentFactory(nextFiber.instance)) {\r\n      // important order\r\n      nextFiber.insertionEffectHost && dropInsertionEffects(nextFiber.hook);\r\n      nextFiber.layoutEffectHost && dropLayoutEffects(nextFiber.hook);\r\n      nextFiber.effectHost && dropEffects(nextFiber.hook);\r\n      nextFiber.portalHost && platform.unmountPortal(nextFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction unmountRoot(rootId: number, onComplete: () => void) {\r\n  if (detectIsUndefined(rootId)) return;\r\n\r\n  unmountFiber(currentRootStore.get(rootId));\r\n  eventsStore.unsubscribe(rootId);\r\n  rootStore.remove(rootId);\r\n  onComplete();\r\n}\r\n\r\nexport { unmountFiber, unmountRoot };\r\n","import { createComponent, detectIsComponentFactory } from '../component';\r\nimport type { KeyProps, SlotProps } from '../shared';\r\n\r\ntype FragmentProps = Required<SlotProps> & KeyProps;\r\n\r\nconst $$fragment = Symbol('fragment');\r\n\r\nconst Fragment = createComponent<FragmentProps>(({ slot }) => slot || null, {\r\n  token: $$fragment,\r\n});\r\n\r\nconst detectIsFragment = (factory: unknown) => detectIsComponentFactory(factory) && factory.token === $$fragment;\r\n\r\nexport { Fragment, detectIsFragment };\r\n","import {\r\n  flatten,\r\n  error,\r\n  detectIsEmpty,\r\n  detectIsFalsy,\r\n  detectIsArray,\r\n  detectIsString,\r\n  detectIsNumber,\r\n  detectIsFunction,\r\n} from '../helpers';\r\nimport { platform } from '../platform';\r\nimport {\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  deletionsStore,\r\n  fiberMountStore,\r\n  currentFiberStore,\r\n  isUpdateHookZone,\r\n  rootStore,\r\n  effectsStore,\r\n  layoutEffectsStore,\r\n  insertionEffectsStore,\r\n  isLayoutEffectsZone,\r\n  isInsertionEffectsZone,\r\n} from '../scope';\r\nimport {\r\n  type ComponentFactory,\r\n  detectIsComponentFactory,\r\n  getComponentFactoryKey,\r\n  getComponentFactoryFlag,\r\n} from '../component';\r\nimport {\r\n  type TagVirtualNode,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsVirtualNodeFactory,\r\n  getTagVirtualNodeKey,\r\n  getVirtualNodeFactoryKey,\r\n  getTagVirtualNodeFlag,\r\n  getVirtualNodeFactoryFlag,\r\n  detectIsTextVirtualNode,\r\n  detectIsCommentVirtualNode,\r\n  createReplacer,\r\n} from '../view';\r\nimport { detectIsMemo } from '../memo';\r\nimport type { Context, ContextProviderValue } from '../context';\r\nimport type { DarkElementKey, DarkElement, DarkElementInstance } from '../shared';\r\nimport { INDEX_KEY, TYPE, Flag } from '../constants';\r\nimport { type NativeElement, type Hook, EffectTag, cloneTagMap } from './types';\r\nimport { hasEffects } from '../use-effect';\r\nimport { hasLayoutEffects } from '../use-layout-effect';\r\nimport { hasInsertionEffects } from '../use-insertion-effect';\r\nimport { walkFiber } from '../walk';\r\nimport { unmountFiber } from '../unmount';\r\nimport { Text } from '../view';\r\nimport { Fragment, detectIsFragment } from '../fragment';\r\n\r\nclass Fiber<N = NativeElement> {\r\n  public id = 0;\r\n  public nativeElement: N = null;\r\n  public parent: Fiber<N> = null;\r\n  public child: Fiber<N> = null;\r\n  public nextSibling: Fiber<N> = null;\r\n  public alternate: Fiber<N> = null;\r\n  public move = false;\r\n  public effectTag: EffectTag = null;\r\n  public instance: DarkElementInstance = null;\r\n  public hook: Hook | null = null;\r\n  public provider: Map<Context, ContextProviderValue> = null;\r\n  public effectHost = false;\r\n  public layoutEffectHost = false;\r\n  public insertionEffectHost = false;\r\n  public portalHost = false;\r\n  public childrenCount = 0;\r\n  public childrenElementsCount = 0;\r\n  public marker = '';\r\n  public isUsed = false;\r\n  public idx = 0;\r\n  public elementIdx = 0;\r\n  public batched: number | null = null;\r\n  public catchException: (error: Error) => void;\r\n  private static nextId = 0;\r\n\r\n  constructor(hook: Hook = null, provider: Fiber['provider'] = null, idx = 0) {\r\n    this.id = ++Fiber.nextId;\r\n    this.hook = hook;\r\n    this.provider = provider;\r\n    this.idx = idx;\r\n  }\r\n\r\n  public mutate(options: Partial<Fiber<N>>) {\r\n    const keys = Object.keys(options);\r\n\r\n    for (const key of keys) {\r\n      this[key] = options[key];\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  public markEffectHost() {\r\n    this.effectHost = true;\r\n    this.parent && !this.parent.effectHost && this.parent.markEffectHost();\r\n  }\r\n\r\n  public markLayoutEffectHost() {\r\n    this.layoutEffectHost = true;\r\n    this.parent && !this.parent.layoutEffectHost && this.parent.markLayoutEffectHost();\r\n  }\r\n\r\n  public markInsertionEffectHost() {\r\n    this.insertionEffectHost = true;\r\n    this.parent && !this.parent.insertionEffectHost && this.parent.markInsertionEffectHost();\r\n  }\r\n\r\n  public markPortalHost() {\r\n    this.portalHost = true;\r\n    this.parent && !this.parent.portalHost && this.parent.markPortalHost();\r\n  }\r\n\r\n  public incrementChildrenElementsCount(count = 1, force = false) {\r\n    incrementChildrenElementsCount(this, count, force);\r\n  }\r\n\r\n  public setError(error: Error) {\r\n    if (detectIsFunction(this.catchException)) {\r\n      this.catchException(error);\r\n    } else if (this.parent) {\r\n      this.parent.setError(error);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop() {\r\n  const wipFiber = wipRootStore.get();\r\n  let nextUnitOfWork = nextUnitOfWorkStore.get();\r\n  let shouldYield = false;\r\n  let hasMoreWork = Boolean(nextUnitOfWork);\r\n\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    nextUnitOfWorkStore.set(nextUnitOfWork);\r\n    hasMoreWork = Boolean(nextUnitOfWork);\r\n    shouldYield = platform.shouldYeildToHost();\r\n  }\r\n\r\n  if (!nextUnitOfWork && wipFiber) {\r\n    commitChanges();\r\n  }\r\n\r\n  return hasMoreWork;\r\n}\r\n\r\nfunction performUnitOfWork(fiber: Fiber) {\r\n  let isDeepWalking = true;\r\n  let nextFiber = fiber;\r\n  let instance = fiber.instance;\r\n\r\n  while (true) {\r\n    isDeepWalking = fiberMountStore.deepWalking.get();\r\n    nextFiber.hook && (nextFiber.hook.idx = 0);\r\n\r\n    if (isDeepWalking) {\r\n      const hasChildren = hasChildrenProp(instance) && instance.children.length > 0;\r\n\r\n      if (hasChildren) {\r\n        const { fiber$, instance$ } = performChild(nextFiber, instance);\r\n\r\n        nextFiber = fiber$;\r\n        instance = instance$;\r\n\r\n        if (fiber$) return fiber$;\r\n      } else {\r\n        const { fiber$$, fiber$, instance$ } = performSibling(nextFiber, instance);\r\n\r\n        nextFiber = fiber$;\r\n        instance = instance$;\r\n\r\n        if (fiber$$) return fiber$$;\r\n      }\r\n    } else {\r\n      const { fiber$$, fiber$, instance$ } = performSibling(nextFiber, instance);\r\n\r\n      nextFiber = fiber$;\r\n      instance = instance$;\r\n\r\n      if (fiber$$) return fiber$$;\r\n    }\r\n\r\n    if (nextFiber.parent === null) return null;\r\n  }\r\n}\r\n\r\nfunction performChild(nextFiber: Fiber, instance: DarkElementInstance) {\r\n  fiberMountStore.jumpToChild();\r\n  const childrenIdx = 0;\r\n  const alternate = nextFiber.alternate ? nextFiber.alternate.child : null;\r\n  const prevInstance: DarkElementInstance = alternate ? alternate.instance : null;\r\n  const nextInstance: DarkElementInstance = hasChildrenProp(instance) ? instance.children[childrenIdx] || null : null;\r\n  const hook = getHook(alternate, prevInstance, nextInstance);\r\n  const provider = alternate ? alternate.provider : null;\r\n  const fiber = new Fiber(hook, provider, childrenIdx);\r\n\r\n  currentFiberStore.set(fiber);\r\n  fiber.parent = nextFiber;\r\n  nextFiber.child = fiber;\r\n  fiber.elementIdx = nextFiber.nativeElement ? 0 : nextFiber.elementIdx;\r\n  instance = pertformInstance(instance, childrenIdx, fiber) || instance;\r\n  alternate && performAlternate(alternate, instance);\r\n  performFiber(fiber, alternate, instance);\r\n  alternate && detectIsMemo(fiber.instance) && performMemo(fiber, alternate, instance);\r\n  cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n  return {\r\n    fiber$: fiber,\r\n    instance$: instance,\r\n  };\r\n}\r\n\r\nfunction performSibling(nextFiber: Fiber, instance: DarkElementInstance) {\r\n  fiberMountStore.jumpToSibling();\r\n  const parentInstance = nextFiber.parent.instance;\r\n  const childrenIdx = fiberMountStore.getIndex();\r\n  const hasSibling = hasChildrenProp(parentInstance) && parentInstance.children[childrenIdx];\r\n\r\n  if (hasSibling) {\r\n    fiberMountStore.deepWalking.set(true);\r\n    const alternate = nextFiber.alternate ? nextFiber.alternate.nextSibling : null;\r\n    const prevInstance: DarkElementInstance = alternate ? alternate.instance : null;\r\n    const nextInstance: DarkElementInstance = hasChildrenProp(parentInstance)\r\n      ? parentInstance.children[childrenIdx] || null\r\n      : null;\r\n    const hook = getHook(alternate, prevInstance, nextInstance);\r\n    const provider = alternate ? alternate.provider : null;\r\n    const fiber = new Fiber(hook, provider, childrenIdx);\r\n\r\n    currentFiberStore.set(fiber);\r\n    fiber.parent = nextFiber.parent;\r\n    nextFiber.nextSibling = fiber;\r\n    fiber.elementIdx = nextFiber.elementIdx + (nextFiber.nativeElement ? 1 : nextFiber.childrenElementsCount);\r\n    instance = pertformInstance(parentInstance, childrenIdx, fiber) || instance;\r\n    alternate && performAlternate(alternate, instance);\r\n    performFiber(fiber, alternate, instance);\r\n    alternate && detectIsMemo(fiber.instance) && performMemo(fiber, alternate, instance);\r\n    cloneTagMap[fiber.parent.effectTag] && (fiber.effectTag = fiber.parent.effectTag);\r\n\r\n    return {\r\n      fiber$$: fiber,\r\n      fiber$: fiber,\r\n      instance$: instance,\r\n    };\r\n  } else {\r\n    fiberMountStore.jumpToParent();\r\n    fiberMountStore.deepWalking.set(false);\r\n    nextFiber = nextFiber.parent;\r\n    instance = nextFiber.instance;\r\n\r\n    if (hasChildrenProp(nextFiber.instance)) {\r\n      nextFiber.instance.children = [];\r\n    }\r\n  }\r\n\r\n  return {\r\n    fiber$$: null,\r\n    fiber$: nextFiber,\r\n    instance$: instance,\r\n  };\r\n}\r\n\r\nfunction incrementChildrenElementsCount(fiber: Fiber, count = 1, force = false) {\r\n  if (!fiber.parent) return;\r\n  const fromUpdate = isUpdateHookZone.get();\r\n  const wipFiber = wipRootStore.get();\r\n  const stop = fromUpdate && wipFiber.parent === fiber.parent;\r\n\r\n  if (\r\n    detectIsTextVirtualNode(fiber.instance) ||\r\n    detectIsCommentVirtualNode(fiber.instance) ||\r\n    (detectIsTagVirtualNode(fiber.instance) && fiber.instance.children.length === 0)\r\n  ) {\r\n    fiber.childrenElementsCount = 1;\r\n  }\r\n\r\n  if (fromUpdate && stop && !force) return;\r\n\r\n  fiber.parent.childrenElementsCount += count;\r\n\r\n  if (!fiber.parent.nativeElement) {\r\n    fiber.parent.incrementChildrenElementsCount(count);\r\n  }\r\n}\r\n\r\nfunction performFiber(fiber: Fiber, alternate: Fiber, instance: DarkElementInstance) {\r\n  const hasAlternate = Boolean(alternate);\r\n  const prevKey = hasAlternate ? getElementKey(alternate.instance) : null;\r\n  const nextKey = hasAlternate ? getElementKey(instance) : null;\r\n  const isSameKeys = prevKey === nextKey;\r\n  const isSameTypes = hasAlternate && getInstanceType(alternate.instance) === getInstanceType(instance);\r\n  const isUpdate = isSameTypes && isSameKeys;\r\n\r\n  fiber.instance = instance;\r\n  fiber.alternate = alternate || null;\r\n  fiber.nativeElement = isUpdate ? alternate.nativeElement : null;\r\n  fiber.effectTag = isUpdate ? EffectTag.UPDATE : EffectTag.CREATE;\r\n\r\n  if (alternate && alternate.move) {\r\n    fiber.move = alternate.move;\r\n    alternate.move = false;\r\n  }\r\n\r\n  if (hasChildrenProp(fiber.instance)) {\r\n    fiber.childrenCount = fiber.instance.children.length;\r\n  }\r\n\r\n  if (!fiber.nativeElement && detectIsVirtualNode(fiber.instance)) {\r\n    fiber.nativeElement = platform.createNativeElement(fiber.instance);\r\n    fiber.effectTag = EffectTag.CREATE;\r\n  }\r\n\r\n  if (fiber.nativeElement) {\r\n    fiber.incrementChildrenElementsCount();\r\n  }\r\n}\r\n\r\nfunction insertToFiber(idx: number, fiber: Fiber, child: Fiber) {\r\n  if (idx === 0 || (fiber.child && fiber.child.effectTag === EffectTag.DELETE)) {\r\n    fiber.child = child;\r\n    child.parent = fiber;\r\n  } else {\r\n    fiber.nextSibling = child;\r\n    child.parent = fiber.parent;\r\n  }\r\n\r\n  return child;\r\n}\r\n\r\nfunction createConditionalFiber(alternate: Fiber, marker?: DarkElementKey) {\r\n  const vNode = createReplacer();\r\n\r\n  return new Fiber().mutate({\r\n    instance: vNode,\r\n    parent: alternate,\r\n    marker: marker + '',\r\n    effectTag: EffectTag.CREATE,\r\n  });\r\n}\r\n\r\nfunction performAlternate(alternate: Fiber, instance: DarkElementInstance) {\r\n  const alternateType = getInstanceType(alternate.instance);\r\n  const elementType = getInstanceType(instance);\r\n  const isSameType = elementType === alternateType;\r\n  const flag = getElementFlag(instance);\r\n  const hasNoMovesFlag = flag && flag[Flag.HAS_NO_MOVES];\r\n\r\n  alternate.isUsed = true;\r\n\r\n  if (!isSameType) {\r\n    alternate.effectTag = EffectTag.DELETE;\r\n\r\n    if (!deletionsStore.has(alternate.parent)) {\r\n      deletionsStore.add(alternate);\r\n    }\r\n  } else if (\r\n    hasChildrenProp(alternate.instance) &&\r\n    hasChildrenProp(instance) &&\r\n    (hasNoMovesFlag ? alternate.childrenCount !== instance.children.length : true)\r\n  ) {\r\n    const { prevKeys, nextKeys, prevKeysMap, nextKeysMap, keyedFibersMap } = extractKeys(\r\n      alternate.child,\r\n      instance.children,\r\n    );\r\n    let result: Array<[DarkElement | [DarkElementKey, DarkElementKey], string]> = [];\r\n    let size = Math.max(prevKeys.length, nextKeys.length);\r\n    let nextFiber = alternate;\r\n    let idx = 0;\r\n    let p = 0;\r\n    let n = 0;\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      const nextKey = nextKeys[i - n] ?? null;\r\n      const prevKey = prevKeys[i - p] ?? null;\r\n      const prevKeyFiber = keyedFibersMap[prevKey] || null;\r\n      const nextKeyFiber = keyedFibersMap[nextKey] || createConditionalFiber(alternate, nextKey);\r\n\r\n      if (nextKey !== prevKey) {\r\n        if (nextKey !== null && !prevKeysMap[nextKey]) {\r\n          if (prevKey !== null && !nextKeysMap[prevKey]) {\r\n            result.push([[nextKey, prevKey], 'replace']);\r\n            nextKeyFiber.effectTag = EffectTag.CREATE;\r\n            prevKeyFiber.effectTag = EffectTag.DELETE;\r\n            deletionsStore.add(prevKeyFiber);\r\n          } else {\r\n            result.push([nextKey, 'insert']);\r\n            nextKeyFiber.effectTag = EffectTag.CREATE;\r\n            p++;\r\n            size++;\r\n          }\r\n          nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n        } else if (!nextKeysMap[prevKey]) {\r\n          result.push([prevKey, 'remove']);\r\n          prevKeyFiber.effectTag = EffectTag.DELETE;\r\n          deletionsStore.add(prevKeyFiber);\r\n          n++;\r\n          idx--;\r\n          size++;\r\n        } else if (nextKeysMap[prevKey] && nextKeysMap[nextKey]) {\r\n          result.push([[nextKey, prevKey], 'move']);\r\n          nextKeyFiber.effectTag = EffectTag.UPDATE;\r\n          prevKeyFiber.effectTag = EffectTag.UPDATE;\r\n          nextKeyFiber.move = true;\r\n          nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n        }\r\n      } else if (nextKey !== null) {\r\n        result.push([nextKey, 'stable']);\r\n        nextKeyFiber.effectTag = EffectTag.UPDATE;\r\n        nextFiber = insertToFiber(i, nextFiber, nextKeyFiber);\r\n      }\r\n\r\n      nextKeyFiber.idx = idx;\r\n      idx++;\r\n    }\r\n\r\n    result = [];\r\n  }\r\n}\r\n\r\nfunction performMemo(fiber: Fiber, alternate: Fiber, instance: DarkElementInstance) {\r\n  const prevFactory = alternate.instance as ComponentFactory;\r\n  const nextFactory = instance as ComponentFactory;\r\n  if (fiber.move || nextFactory.type !== prevFactory.type) return;\r\n  const prevProps = prevFactory.props;\r\n  const nextProps = nextFactory.props;\r\n  const skip = !nextFactory.shouldUpdate(prevProps, nextProps);\r\n\r\n  if (skip) {\r\n    fiberMountStore.deepWalking.set(false);\r\n    const diff = fiber.elementIdx - alternate.elementIdx;\r\n    const deep = diff !== 0;\r\n\r\n    fiber.mutate({\r\n      ...alternate,\r\n      alternate,\r\n      id: fiber.id,\r\n      idx: fiber.idx,\r\n      parent: fiber.parent,\r\n      nextSibling: fiber.nextSibling,\r\n      elementIdx: fiber.elementIdx,\r\n      effectTag: EffectTag.SKIP,\r\n    });\r\n\r\n    walkFiber(fiber.child, ({ nextFiber, stop }) => {\r\n      if (nextFiber === fiber.nextSibling || nextFiber === fiber.parent) {\r\n        return stop();\r\n      }\r\n\r\n      if (nextFiber.parent === alternate) {\r\n        nextFiber.parent = fiber;\r\n      }\r\n\r\n      if (deep) {\r\n        nextFiber.elementIdx += diff;\r\n        if (nextFiber.parent !== fiber && nextFiber.nativeElement) return stop();\r\n      } else if (nextFiber === alternate.child.child) return stop();\r\n    });\r\n\r\n    fiber.incrementChildrenElementsCount(alternate.childrenElementsCount);\r\n\r\n    if (alternate.effectHost) {\r\n      fiber.markEffectHost();\r\n    }\r\n\r\n    if (alternate.layoutEffectHost) {\r\n      fiber.markLayoutEffectHost();\r\n    }\r\n\r\n    if (alternate.insertionEffectHost) {\r\n      fiber.markInsertionEffectHost();\r\n    }\r\n\r\n    if (alternate.portalHost) {\r\n      fiber.markPortalHost();\r\n    }\r\n  }\r\n}\r\n\r\nfunction pertformInstance(instance: DarkElementInstance, idx: number, fiber: Fiber) {\r\n  let performedInstance: DarkElementInstance = null;\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    const elements = detectIsArray(instance.children[idx])\r\n      ? flatten([instance.children[idx]])\r\n      : [instance.children[idx]];\r\n\r\n    instance.children.splice(idx, 1, ...elements);\r\n\r\n    performedInstance = instance.children[idx];\r\n    performedInstance = mountInstance(fiber, performedInstance);\r\n  }\r\n\r\n  if (detectIsComponentFactory(performedInstance)) {\r\n    if (hasEffects(fiber)) {\r\n      fiber.markEffectHost();\r\n    }\r\n\r\n    if (hasLayoutEffects(fiber)) {\r\n      fiber.markLayoutEffectHost();\r\n    }\r\n\r\n    if (hasInsertionEffects(fiber)) {\r\n      fiber.markInsertionEffectHost();\r\n    }\r\n\r\n    if (platform.detectIsPortal(performedInstance)) {\r\n      fiber.markPortalHost();\r\n    }\r\n  }\r\n\r\n  return performedInstance;\r\n}\r\n\r\nfunction mountInstance(fiber: Fiber, instance: DarkElementInstance) {\r\n  const isComponentFactory = detectIsComponentFactory(instance);\r\n  const factory = instance as ComponentFactory;\r\n\r\n  if (isComponentFactory) {\r\n    try {\r\n      let result = factory.type(factory.props, factory.ref);\r\n\r\n      if (detectIsArray(result) && !detectIsFragment(factory)) {\r\n        result = Fragment({ slot: result });\r\n      } else if (detectIsString(result) || detectIsNumber(result)) {\r\n        result = Text(result);\r\n      }\r\n\r\n      factory.children = detectIsArray(result)\r\n        ? (flatten([result]) as Array<DarkElementInstance>)\r\n        : ([result] as Array<DarkElementInstance>);\r\n    } catch (err) {\r\n      factory.children = [];\r\n      fiber.setError(err);\r\n      error(err);\r\n    }\r\n  } else if (detectIsVirtualNodeFactory(instance)) {\r\n    instance = instance();\r\n  }\r\n\r\n  if (hasChildrenProp(instance)) {\r\n    for (let i = 0; i < instance.children.length; i++) {\r\n      if (!instance.children[i]) {\r\n        instance.children[i] = supportConditional(instance.children[i]) as DarkElementInstance;\r\n      }\r\n    }\r\n\r\n    instance.children = isComponentFactory\r\n      ? instance.children\r\n      : detectIsArray(instance.children)\r\n      ? flatten([instance.children])\r\n      : [instance.children];\r\n\r\n    if (isComponentFactory && factory.children.length === 0) {\r\n      factory.children.push(createReplacer());\r\n    }\r\n  }\r\n\r\n  return instance;\r\n}\r\n\r\nfunction extractKeys(alternate: Fiber, children: Array<DarkElementInstance>) {\r\n  let nextFiber = alternate;\r\n  let idx = 0;\r\n  let hasNoPrevKeys = false;\r\n  let hasNoNextKeys = false;\r\n  const prevKeys: Array<DarkElementKey> = [];\r\n  const nextKeys: Array<DarkElementKey> = [];\r\n  const prevKeysMap: Record<DarkElementKey, boolean> = {};\r\n  const nextKeysMap: Record<DarkElementKey, boolean> = {};\r\n  const keyedFibersMap: Record<DarkElementKey, Fiber> = {};\r\n  const usedKeysMap: Record<DarkElementKey, boolean> = {};\r\n\r\n  while (nextFiber || idx < children.length) {\r\n    if (nextFiber) {\r\n      const key = getElementKey(nextFiber.instance);\r\n      const prevKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        if (detectIsEmpty(key)) {\r\n          hasNoPrevKeys = true;\r\n        }\r\n      }\r\n\r\n      prevKeys.push(prevKey);\r\n      prevKeysMap[prevKey] = true;\r\n      keyedFibersMap[prevKey] = nextFiber;\r\n    }\r\n\r\n    if (children[idx]) {\r\n      const key = getElementKey(children[idx]);\r\n      const nextKey = detectIsEmpty(key) ? createIndexKey(idx) : key;\r\n\r\n      if (process.env.NODE_ENV === 'development') {\r\n        if (detectIsEmpty(key)) {\r\n          hasNoNextKeys = true;\r\n        }\r\n\r\n        if (usedKeysMap[nextKey]) {\r\n          error(`[Dark]: The key of node [${nextKey}] already has been used!`, [children[idx]]);\r\n        }\r\n\r\n        usedKeysMap[nextKey] = true;\r\n      }\r\n\r\n      nextKeys.push(nextKey);\r\n      nextKeysMap[nextKey] = true;\r\n    }\r\n\r\n    nextFiber = nextFiber ? nextFiber.nextSibling : null;\r\n    idx++;\r\n  }\r\n\r\n  if (process.env.NODE_ENV === 'development') {\r\n    if (prevKeys.length !== nextKeys.length && hasNoNextKeys && hasNoPrevKeys) {\r\n      error(\r\n        `[Dark]: Operation of inserting, adding, replacing elements into list requires to have a unique key for every node (string or number, but not array index)!`,\r\n        children,\r\n      );\r\n    }\r\n  }\r\n\r\n  return {\r\n    prevKeys,\r\n    nextKeys,\r\n    prevKeysMap,\r\n    nextKeysMap,\r\n    keyedFibersMap,\r\n  };\r\n}\r\n\r\nfunction createIndexKey(idx: number) {\r\n  return `${INDEX_KEY}:${idx}`;\r\n}\r\n\r\nfunction getElementKey(instance: DarkElementInstance): DarkElementKey | null {\r\n  const key = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryKey(instance)\r\n    : detectIsVirtualNodeFactory(instance)\r\n    ? getVirtualNodeFactoryKey(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getTagVirtualNodeKey(instance)\r\n    : null;\r\n\r\n  return key;\r\n}\r\n\r\nfunction getElementFlag(instance: DarkElementInstance): Record<Flag, boolean> | null {\r\n  const flag = detectIsComponentFactory(instance)\r\n    ? getComponentFactoryFlag(instance)\r\n    : detectIsVirtualNodeFactory(instance)\r\n    ? getVirtualNodeFactoryFlag(instance)\r\n    : detectIsTagVirtualNode(instance)\r\n    ? getTagVirtualNodeFlag(instance)\r\n    : null;\r\n\r\n  return flag;\r\n}\r\n\r\nfunction supportConditional(instance: DarkElement) {\r\n  return detectIsFalsy(instance) ? createReplacer() : instance;\r\n}\r\n\r\nfunction getInstanceType(instance: DarkElementInstance): string | Function {\r\n  return detectIsVirtualNodeFactory(instance)\r\n    ? instance[TYPE]\r\n    : detectIsTagVirtualNode(instance)\r\n    ? instance.name\r\n    : detectIsVirtualNode(instance)\r\n    ? instance.type\r\n    : detectIsComponentFactory(instance)\r\n    ? instance.type\r\n    : null;\r\n}\r\n\r\nfunction hasChildrenProp(element: DarkElementInstance): element is TagVirtualNode | ComponentFactory {\r\n  return detectIsTagVirtualNode(element) || detectIsComponentFactory(element);\r\n}\r\n\r\nfunction detectIsSameComponentFactoryTypesWithSameKeys(\r\n  prevInstance: DarkElementInstance | null,\r\n  nextInstance: DarkElementInstance | null,\r\n) {\r\n  if (\r\n    prevInstance &&\r\n    nextInstance &&\r\n    detectIsComponentFactory(prevInstance) &&\r\n    detectIsComponentFactory(nextInstance) &&\r\n    prevInstance.type === nextInstance.type\r\n  ) {\r\n    const prevKey = prevInstance ? getElementKey(prevInstance) : null;\r\n    const nextKey = nextInstance ? getElementKey(nextInstance) : null;\r\n\r\n    return prevKey === nextKey;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getHook(alternate: Fiber, prevInstance: DarkElementInstance, nextInstance: DarkElementInstance): Hook | null {\r\n  if (alternate && detectIsSameComponentFactoryTypesWithSameKeys(prevInstance, nextInstance)) {\r\n    return alternate.hook;\r\n  }\r\n\r\n  if (detectIsComponentFactory(nextInstance)) {\r\n    return createHook();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction createHook(): Hook {\r\n  return {\r\n    idx: 0,\r\n    values: [],\r\n  };\r\n}\r\n\r\nfunction commitChanges() {\r\n  const wipFiber = wipRootStore.get();\r\n  const isDynamic = platform.detectIsDynamic();\r\n  const insertionEffects = insertionEffectsStore.get();\r\n  const deletions = deletionsStore.get();\r\n  const fromUpdate = isUpdateHookZone.get();\r\n\r\n  // important order\r\n  for (const fiber of deletions) {\r\n    unmountFiber(fiber);\r\n    platform.applyCommit(fiber);\r\n  }\r\n\r\n  isInsertionEffectsZone.set(true);\r\n  isDynamic && insertionEffects.forEach(fn => fn());\r\n  isInsertionEffectsZone.set(false);\r\n\r\n  fromUpdate && syncElementIndices(wipFiber);\r\n\r\n  commitWork(wipFiber, () => {\r\n    const layoutEffects = layoutEffectsStore.get();\r\n    const effects = effectsStore.get();\r\n\r\n    isLayoutEffectsZone.set(true);\r\n    isDynamic && layoutEffects.forEach(fn => fn());\r\n    isLayoutEffectsZone.set(false);\r\n\r\n    setTimeout(() => {\r\n      isDynamic && effects.forEach(fn => fn());\r\n    });\r\n\r\n    wipRootStore.set(null); // important order\r\n    deletionsStore.reset();\r\n    insertionEffectsStore.reset();\r\n    layoutEffectsStore.reset();\r\n    effectsStore.reset();\r\n\r\n    if (fromUpdate) {\r\n      isUpdateHookZone.set(false);\r\n    } else {\r\n      currentRootStore.set(wipFiber);\r\n    }\r\n  });\r\n}\r\n\r\nfunction getParentFiberWithNativeElement(fiber: Fiber) {\r\n  let parentFiber = fiber;\r\n\r\n  while (parentFiber) {\r\n    parentFiber = parentFiber.parent;\r\n\r\n    if (parentFiber && parentFiber.nativeElement) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return parentFiber;\r\n}\r\n\r\nfunction syncElementIndices(fiber: Fiber) {\r\n  const diff = fiber.childrenElementsCount - fiber.alternate.childrenElementsCount;\r\n  if (diff === 0) return;\r\n  const parentFiber = getParentFiberWithNativeElement(fiber);\r\n  let isRight = false;\r\n\r\n  fiber.incrementChildrenElementsCount(diff, true);\r\n\r\n  walkFiber(parentFiber.child, ({ nextFiber, resetIsDeepWalking, isReturn, stop }) => {\r\n    if (nextFiber === parentFiber) return stop();\r\n    if (nextFiber === fiber) {\r\n      isRight = true;\r\n      return resetIsDeepWalking();\r\n    }\r\n\r\n    if (nextFiber.nativeElement) {\r\n      resetIsDeepWalking();\r\n    }\r\n\r\n    if (isRight && !isReturn) {\r\n      nextFiber.elementIdx += diff;\r\n    }\r\n  });\r\n}\r\n\r\nfunction commitWork(fiber: Fiber, onComplete: Function) {\r\n  walkFiber(fiber.child, ({ nextFiber, isReturn, resetIsDeepWalking, stop }) => {\r\n    const skip = nextFiber.effectTag === EffectTag.SKIP;\r\n\r\n    if (nextFiber === fiber) return stop();\r\n\r\n    if (skip) {\r\n      resetIsDeepWalking();\r\n    } else if (!isReturn) {\r\n      platform.applyCommit(nextFiber);\r\n    }\r\n\r\n    nextFiber.alternate = null;\r\n  });\r\n\r\n  fiber.alternate = null;\r\n  platform.finishCommitWork();\r\n  onComplete();\r\n}\r\n\r\ntype CreateUpdateCallbackOptions = {\r\n  rootId: number;\r\n  fiber: Fiber;\r\n  forceStart?: boolean;\r\n  onStart: () => void;\r\n};\r\n\r\nfunction createUpdateCallback(options: CreateUpdateCallbackOptions) {\r\n  const { rootId, fiber, forceStart = false, onStart } = options;\r\n  const callback = () => {\r\n    if (fiber.effectTag === EffectTag.DELETE) return;\r\n    forceStart && onStart();\r\n    if (fiber.isUsed) return;\r\n    !forceStart && onStart();\r\n    rootStore.set(rootId); // important order!\r\n    isUpdateHookZone.set(true);\r\n    fiberMountStore.reset();\r\n\r\n    fiber.alternate = new Fiber().mutate({ ...fiber });\r\n    fiber.marker = '';\r\n    fiber.effectTag = EffectTag.UPDATE;\r\n    fiber.childrenElementsCount = 0;\r\n    fiber.child = null;\r\n\r\n    wipRootStore.set(fiber);\r\n    currentFiberStore.set(fiber);\r\n    fiber.instance = mountInstance(fiber, fiber.instance);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  return callback;\r\n}\r\n\r\nexport { Fiber, workLoop, createUpdateCallback };\r\n","import { detectIsObject, detectIsNull } from '../helpers';\r\nimport type { Component, ComponentFactory } from '../component';\r\nimport type { RefProps } from '../shared';\r\nimport type { MutableRef } from './types';\r\n\r\nfunction forwardRef<P, R>(component: Component<P, R>) {\r\n  type Props = P & RefProps<R>;\r\n\r\n  return (props: Props) => {\r\n    const { ref, ...rest } = props || {};\r\n\r\n    return component(rest as P, ref) as ComponentFactory<P, R>;\r\n  };\r\n}\r\n\r\nconst detectIsMutableRef = (ref: unknown): ref is MutableRef => {\r\n  if (!detectIsObject(ref) || detectIsNull(ref)) return false;\r\n  const mutableRef = ref as MutableRef;\r\n\r\n  for (const key in mutableRef) {\r\n    if (key === 'current' && mutableRef.hasOwnProperty(key)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport { forwardRef, detectIsMutableRef };\r\n","import type { DarkElement, SlotProps } from '../shared';\r\nimport { detectIsUndefined, detectIsArray, detectIsDepsDifferent } from '../helpers';\r\nimport { detectIsComponentFactory, createComponent } from '../component';\r\nimport { detectIsVirtualNodeFactory } from '../view';\r\nimport { currentFiberStore } from '../scope';\r\nimport { Fragment } from '../fragment';\r\nimport { $$memo } from '../memo';\r\n\r\ntype MemoProps = Required<SlotProps>;\r\n\r\nconst Memo = createComponent<MemoProps>(({ slot }) => slot, { token: $$memo });\r\n\r\nfunction wrap<T>(value: T, isDepsDifferent: boolean) {\r\n  const check = (value: T) => detectIsVirtualNodeFactory(value) || detectIsComponentFactory(value);\r\n\r\n  if (detectIsArray(value) ? check(value[0]) : check(value)) {\r\n    const slot = value as unknown as DarkElement;\r\n    const factory = Memo({\r\n      slot: Fragment({ slot }),\r\n    });\r\n\r\n    factory.shouldUpdate = () => isDepsDifferent;\r\n\r\n    return factory;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction processValue<T>(getValue: () => T, isDepsDifferent = false) {\r\n  return wrap(getValue(), isDepsDifferent);\r\n}\r\n\r\nfunction useMemo<T>(getValue: () => T, deps: Array<any>): T {\r\n  const fiber = currentFiberStore.get();\r\n  const { hook } = fiber;\r\n  const { idx, values } = hook;\r\n\r\n  if (detectIsUndefined(values[idx])) {\r\n    const value = processValue(getValue);\r\n\r\n    values[idx] = {\r\n      deps,\r\n      value,\r\n    };\r\n\r\n    hook.idx++;\r\n\r\n    return value as T;\r\n  }\r\n\r\n  const hookValue = values[idx];\r\n  const prevDeps = hookValue.deps as Array<any>;\r\n  const isDepsDifferent = detectIsDepsDifferent(deps, prevDeps);\r\n  const computedGetValue = isDepsDifferent ? getValue : () => hookValue.value;\r\n\r\n  hookValue.deps = deps;\r\n  hookValue.value = processValue(computedGetValue, isDepsDifferent);\r\n\r\n  hook.idx++;\r\n\r\n  return hookValue.value;\r\n}\r\n\r\nexport { useMemo };\r\n","import {\r\n  type Fiber,\r\n  type DarkElement,\r\n  type ComponentFactory,\r\n  createComponent,\r\n  detectIsComponentFactory,\r\n  useMemo,\r\n} from '@dark-engine/core';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nconst $$portal = Symbol('portal');\r\n\r\nfunction createPortal(slot: DarkElement, container: TagNativeElement) {\r\n  if (!(container instanceof Element)) {\r\n    throw new Error(`[Dark]: createPortal receives only Element as container!`);\r\n  }\r\n\r\n  return Portal({ [$$portal]: container, slot });\r\n}\r\n\r\ntype PortalProps = {\r\n  [$$portal]: TagNativeElement;\r\n  slot: DarkElement;\r\n};\r\n\r\nconst Portal = createComponent<PortalProps>(\r\n  ({ slot, ...rest }) => {\r\n    useMemo(() => (rest[$$portal].innerHTML = ''), []);\r\n\r\n    return slot;\r\n  },\r\n  { token: $$portal },\r\n);\r\n\r\nconst detectIsPortal = (factory: unknown): factory is ComponentFactory =>\r\n  detectIsComponentFactory(factory) && factory.token === $$portal;\r\n\r\nconst getPortalContainer = (factory: unknown): TagNativeElement | null =>\r\n  detectIsPortal(factory) ? factory.props[$$portal] : null;\r\n\r\nfunction unmountPortal(fiber: Fiber<TagNativeElement>) {\r\n  const container = getPortalContainer(fiber.instance);\r\n\r\n  if (container) {\r\n    container.innerHTML = '';\r\n  }\r\n}\r\n\r\nexport { createPortal, detectIsPortal, getPortalContainer, unmountPortal };\r\n","import { detectIsFunction, eventsStore } from '@dark-engine/core';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\ntype BrowserEventConstructor = (type: string, event: Event) => void;\r\n\r\nclass SyntheticEvent<E extends Event, T = TagNativeElement> {\r\n  public type = '';\r\n  public sourceEvent: E = null;\r\n  public target: T = null;\r\n  private propagation = true;\r\n\r\n  constructor(options: Pick<SyntheticEvent<E, T>, 'sourceEvent' | 'target'>) {\r\n    this.type = options.sourceEvent.type;\r\n    this.sourceEvent = options.sourceEvent;\r\n    this.target = options.target;\r\n  }\r\n\r\n  public stopPropagation() {\r\n    this.propagation = false;\r\n    this.sourceEvent.stopPropagation();\r\n  }\r\n\r\n  public preventDefault() {\r\n    this.sourceEvent.preventDefault();\r\n  }\r\n\r\n  public getPropagation() {\r\n    return this.propagation;\r\n  }\r\n}\r\n\r\ntype DelegateEventOptions = {\r\n  target: Element;\r\n  eventName: string;\r\n  handler: (e: Event) => void;\r\n};\r\n\r\nfunction delegateEvent(options: DelegateEventOptions) {\r\n  const { target, eventName, handler } = options;\r\n  const eventsMap = eventsStore.get();\r\n  const handlerMap = eventsMap.get(eventName);\r\n\r\n  if (!handlerMap) {\r\n    const rootHandler = (event: Event) => {\r\n      const fireEvent = eventsMap.get(eventName).get(event.target);\r\n      const target = event.target as TagNativeElement;\r\n      let syntheticEvent: SyntheticEvent<Event> = null;\r\n\r\n      if (detectIsFunction(fireEvent)) {\r\n        syntheticEvent = new SyntheticEvent({\r\n          sourceEvent: event,\r\n          target,\r\n        });\r\n        fireEvent(syntheticEvent);\r\n      }\r\n\r\n      if (syntheticEvent ? syntheticEvent.getPropagation() : target.parentElement) {\r\n        target.parentElement.dispatchEvent(new (event.constructor as BrowserEventConstructor)(event.type, event));\r\n      }\r\n    };\r\n\r\n    eventsMap.set(eventName, new WeakMap([[target, handler]]));\r\n    document.addEventListener(eventName, rootHandler, true);\r\n    eventsStore.addUnsubscriber(() => document.removeEventListener(eventName, rootHandler, true));\r\n  } else {\r\n    handlerMap.set(target, handler);\r\n  }\r\n}\r\n\r\nconst detectIsEvent = (attrName: string) => attrName.startsWith('on');\r\n\r\nconst getEventName = (attrName: string) => attrName.slice(2, attrName.length).toLowerCase();\r\n\r\nexport { SyntheticEvent, delegateEvent, detectIsEvent, getEventName };\r\n","import {\r\n  type Fiber,\r\n  type VirtualNode,\r\n  type TagVirtualNode,\r\n  type TextVirtualNode,\r\n  type CommentVirtualNode,\r\n  type Ref,\r\n  ATTR_KEY,\r\n  ATTR_REF,\r\n  ATTR_FLAG,\r\n  EffectTag,\r\n  detectIsFunction,\r\n  detectIsUndefined,\r\n  detectIsBoolean,\r\n  keyBy,\r\n  NodeType,\r\n  detectIsVirtualNode,\r\n  detectIsTagVirtualNode,\r\n  detectIsTextVirtualNode,\r\n  detectIsMutableRef,\r\n  walkFiber,\r\n  isHydrateZone,\r\n} from '@dark-engine/core';\r\nimport { detectIsPortal, getPortalContainer } from '../portal';\r\nimport { delegateEvent, detectIsEvent, getEventName } from '../events';\r\nimport { SVG_TAG_NAMES, VOID_TAG_NAMES } from '../constants';\r\nimport type {\r\n  NativeElement,\r\n  TagNativeElement,\r\n  TextNativeElement,\r\n  CommentNativeElement,\r\n  AttributeValue,\r\n} from '../native-element';\r\n\r\ntype DOMFragment = {\r\n  fragment: DocumentFragment;\r\n  callback: () => void;\r\n};\r\n\r\nconst attrBlackListMap = {\r\n  [ATTR_KEY]: true,\r\n  [ATTR_REF]: true,\r\n  [ATTR_FLAG]: true,\r\n};\r\nlet fragmentsMap: Map<NativeElement, DOMFragment> = new Map();\r\nlet moves: Array<() => void> = [];\r\nlet trackUpdate: (nativeElement: NativeElement) => void = null;\r\nconst svgTagNamesMap = keyBy(SVG_TAG_NAMES.split(','), x => x);\r\nconst voidTagNamesMap = keyBy(VOID_TAG_NAMES.split(','), x => x);\r\n\r\nconst createNativeElementMap = {\r\n  [NodeType.TAG]: (vNode: VirtualNode): TagNativeElement => {\r\n    const tagNode = vNode as TagVirtualNode;\r\n    const node = detectIsSvgElement(tagNode.name)\r\n      ? document.createElementNS('http://www.w3.org/2000/svg', tagNode.name)\r\n      : document.createElement(tagNode.name);\r\n\r\n    return node;\r\n  },\r\n  [NodeType.TEXT]: (vNode: VirtualNode): TextNativeElement => {\r\n    const textNode = vNode as TextVirtualNode;\r\n    const node = document.createTextNode(textNode.value);\r\n\r\n    return node;\r\n  },\r\n  [NodeType.COMMENT]: (vNode: VirtualNode): CommentNativeElement => {\r\n    const commentNode = vNode as CommentVirtualNode;\r\n    const node = document.createComment(commentNode.value);\r\n\r\n    return node;\r\n  },\r\n};\r\n\r\nfunction createNativeElement(vNode: VirtualNode): NativeElement {\r\n  return createNativeElementMap[vNode.type](vNode);\r\n}\r\n\r\nfunction detectIsSvgElement(tagName: string) {\r\n  return Boolean(svgTagNamesMap[tagName]);\r\n}\r\n\r\nfunction detectIsVoidElement(tagName: string) {\r\n  return Boolean(voidTagNamesMap[tagName]);\r\n}\r\n\r\nfunction applyRef(ref: Ref<NativeElement>, element: NativeElement) {\r\n  if (detectIsFunction(ref)) {\r\n    ref(element);\r\n  } else if (detectIsMutableRef(ref)) {\r\n    ref.current = element;\r\n  }\r\n}\r\n\r\nfunction addAttributes(element: NativeElement, vNode: VirtualNode) {\r\n  if (!detectIsTagVirtualNode(vNode)) return;\r\n  const attrNames = Object.keys(vNode.attrs);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const attrValue = vNode.attrs[attrName];\r\n\r\n    if (attrName === ATTR_REF) {\r\n      applyRef(attrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (detectIsFunction(attrValue)) {\r\n      if (detectIsEvent(attrName)) {\r\n        delegateEvent({\r\n          target: tagElement,\r\n          handler: attrValue,\r\n          eventName: getEventName(attrName),\r\n        });\r\n      }\r\n    } else if (!detectIsUndefined(attrValue) && !attrBlackListMap[attrName]) {\r\n      const stop = patchProperties({\r\n        tagName: vNode.name,\r\n        element: tagElement,\r\n        attrValue,\r\n        attrName,\r\n      });\r\n\r\n      !stop && tagElement.setAttribute(attrName, attrValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateAttributes(element: NativeElement, vNode: TagVirtualNode, nextVNode: TagVirtualNode) {\r\n  const attrNames = new Set([...Object.keys(vNode.attrs), ...Object.keys(nextVNode.attrs)]);\r\n  const tagElement = element as TagNativeElement;\r\n\r\n  for (const attrName of attrNames) {\r\n    const prevAttrValue = vNode.attrs[attrName];\r\n    const nextAttrValue = nextVNode.attrs[attrName];\r\n\r\n    if (attrName === ATTR_REF) {\r\n      applyRef(prevAttrValue, element);\r\n      continue;\r\n    }\r\n\r\n    if (!detectIsUndefined(nextAttrValue)) {\r\n      if (detectIsFunction(prevAttrValue)) {\r\n        if (detectIsEvent(attrName) && prevAttrValue !== nextAttrValue) {\r\n          delegateEvent({\r\n            target: tagElement,\r\n            handler: nextAttrValue,\r\n            eventName: getEventName(attrName),\r\n          });\r\n        }\r\n      } else if (!attrBlackListMap[attrName] && prevAttrValue !== nextAttrValue) {\r\n        const stop = patchProperties({\r\n          tagName: nextVNode.name,\r\n          element: tagElement,\r\n          attrValue: nextAttrValue,\r\n          attrName,\r\n        });\r\n\r\n        !stop && tagElement.setAttribute(attrName, nextAttrValue);\r\n      }\r\n    } else {\r\n      tagElement.removeAttribute(attrName);\r\n    }\r\n  }\r\n}\r\n\r\ntype PatchPropertiesOptions = {\r\n  tagName: string;\r\n  element: TagNativeElement;\r\n  attrName: string;\r\n  attrValue: AttributeValue;\r\n};\r\n\r\nfunction patchProperties(options: PatchPropertiesOptions): boolean {\r\n  const { tagName, element, attrName, attrValue } = options;\r\n  const fn = patchPropertiesSpecialCasesMap[tagName];\r\n  let stop = fn ? fn(element, attrName, attrValue) : false;\r\n\r\n  if (canSetProperty(Object.getPrototypeOf(element), attrName)) {\r\n    element[attrName] = attrValue;\r\n  }\r\n\r\n  if (!stop && detectIsBoolean(attrValue)) {\r\n    stop = !attrName.includes('-');\r\n  }\r\n\r\n  return stop;\r\n}\r\n\r\nfunction canSetProperty(prototype: TagNativeElement, key: string) {\r\n  return prototype.hasOwnProperty(key) && Boolean(Object.getOwnPropertyDescriptor(prototype, key)?.set);\r\n}\r\n\r\nconst patchPropertiesSpecialCasesMap: Record<\r\n  string,\r\n  (element: NativeElement, attrName: string, attrValue: AttributeValue) => boolean\r\n> = {\r\n  input: (element: HTMLInputElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value' && detectIsBoolean(attrValue)) {\r\n      element.checked = attrValue;\r\n    } else if (attrName === 'autoFocus') {\r\n      element.autofocus = Boolean(attrValue);\r\n    }\r\n\r\n    return false;\r\n  },\r\n  textarea: (element: HTMLTextAreaElement, attrName: string, attrValue: AttributeValue) => {\r\n    if (attrName === 'value') {\r\n      element.innerHTML = String(attrValue);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  },\r\n};\r\n\r\nfunction getParentFiberWithNativeElement(fiber: Fiber<NativeElement>): Fiber<TagNativeElement> {\r\n  let nextFiber = fiber;\r\n\r\n  while (nextFiber) {\r\n    nextFiber = nextFiber.parent;\r\n\r\n    if (detectIsPortal(nextFiber.instance)) {\r\n      nextFiber.nativeElement = getPortalContainer(nextFiber.instance);\r\n    }\r\n\r\n    if (nextFiber.nativeElement) return nextFiber as Fiber<TagNativeElement>;\r\n  }\r\n\r\n  return nextFiber as Fiber<TagNativeElement>;\r\n}\r\n\r\nfunction append(fiber: Fiber<NativeElement>, parentElement: TagNativeElement) {\r\n  const { fragment } =\r\n    fragmentsMap.get(parentElement) ||\r\n    ({\r\n      fragment: document.createDocumentFragment(),\r\n      callback: () => {},\r\n    } as DOMFragment);\r\n\r\n  fragmentsMap.set(parentElement, {\r\n    fragment,\r\n    callback: () => {\r\n      parentElement.appendChild(fragment);\r\n    },\r\n  });\r\n  fragment.appendChild(fiber.nativeElement);\r\n}\r\n\r\nfunction insert(fiber: Fiber<NativeElement>, parentElement: TagNativeElement) {\r\n  parentElement.insertBefore(fiber.nativeElement, parentElement.childNodes[fiber.elementIdx]);\r\n}\r\n\r\nfunction commitCreation(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getParentFiberWithNativeElement(fiber);\r\n  const parentElement = parentFiber.nativeElement;\r\n  const childNodes = parentElement.childNodes;\r\n\r\n  if (isHydrateZone.get()) {\r\n    const nativeElement = childNodes[fiber.elementIdx] as NativeElement;\r\n\r\n    if (\r\n      detectIsTextVirtualNode(fiber.instance) &&\r\n      nativeElement instanceof Text &&\r\n      fiber.instance.value.length !== nativeElement.length\r\n    ) {\r\n      nativeElement.splitText(fiber.instance.value.length);\r\n    }\r\n\r\n    fiber.nativeElement = nativeElement;\r\n  } else {\r\n    if (childNodes.length === 0 || fiber.elementIdx > childNodes.length - 1) {\r\n      const vNode = parentFiber.instance as TagVirtualNode;\r\n\r\n      !detectIsVoidElement(vNode.name) && append(fiber, parentElement);\r\n    } else {\r\n      insert(fiber, parentElement);\r\n    }\r\n  }\r\n\r\n  addAttributes(fiber.nativeElement, fiber.instance as VirtualNode);\r\n}\r\n\r\nfunction commitUpdate(fiber: Fiber<NativeElement>) {\r\n  const element = fiber.nativeElement;\r\n  const prevInstance = fiber.alternate.instance as VirtualNode;\r\n  const nextInstance = fiber.instance as VirtualNode;\r\n\r\n  if (\r\n    detectIsTextVirtualNode(prevInstance) &&\r\n    detectIsTextVirtualNode(nextInstance) &&\r\n    prevInstance.value !== nextInstance.value\r\n  ) {\r\n    return (element.textContent = nextInstance.value);\r\n  }\r\n\r\n  if (detectIsTagVirtualNode(prevInstance) && detectIsTagVirtualNode(nextInstance)) {\r\n    return updateAttributes(element, prevInstance, nextInstance);\r\n  }\r\n}\r\n\r\nfunction commitDeletion(fiber: Fiber<NativeElement>) {\r\n  const parentFiber = getParentFiberWithNativeElement(fiber);\r\n\r\n  walkFiber<NativeElement>(fiber, ({ nextFiber, isReturn, resetIsDeepWalking, stop }) => {\r\n    if (nextFiber === fiber.nextSibling || nextFiber === fiber.parent) {\r\n      return stop();\r\n    }\r\n\r\n    if (!isReturn && nextFiber.nativeElement) {\r\n      !detectIsPortal(nextFiber.instance) && parentFiber.nativeElement.removeChild(nextFiber.nativeElement);\r\n\r\n      return resetIsDeepWalking();\r\n    }\r\n  });\r\n}\r\n\r\nfunction move(fiber: Fiber<NativeElement>) {\r\n  const sourceNodes = collectElements(fiber);\r\n  const sourceNode = sourceNodes[0];\r\n  const parentElement = sourceNode.parentElement;\r\n  const sourceFragment = new DocumentFragment();\r\n  const elementIdx = fiber.elementIdx;\r\n  let idx = 0;\r\n  const move = () => {\r\n    for (let i = 1; i < sourceNodes.length; i++) {\r\n      parentElement.removeChild(parentElement.childNodes[elementIdx + 1]);\r\n    }\r\n\r\n    parentElement.replaceChild(sourceFragment, parentElement.childNodes[elementIdx]);\r\n  };\r\n\r\n  for (const node of sourceNodes) {\r\n    parentElement.insertBefore(document.createComment(`${elementIdx}:${idx}`), node);\r\n    sourceFragment.appendChild(node);\r\n    idx++;\r\n  }\r\n\r\n  moves.push(move);\r\n}\r\n\r\nfunction collectElements(fiber: Fiber<NativeElement>) {\r\n  const store: Array<NativeElement> = [];\r\n\r\n  walkFiber<NativeElement>(fiber, ({ nextFiber, isReturn, resetIsDeepWalking, stop }) => {\r\n    if (nextFiber === fiber.nextSibling || nextFiber === fiber.parent) {\r\n      return stop();\r\n    }\r\n\r\n    if (!isReturn && nextFiber.nativeElement) {\r\n      !detectIsPortal(nextFiber.instance) && store.push(nextFiber.nativeElement);\r\n\r\n      return resetIsDeepWalking();\r\n    }\r\n  });\r\n\r\n  return store;\r\n}\r\n\r\nconst applyCommitMap: Record<EffectTag, (fiber: Fiber<NativeElement>) => void> = {\r\n  [EffectTag.CREATE]: (fiber: Fiber<NativeElement>) => {\r\n    if (fiber.nativeElement === null) return;\r\n    trackUpdate && trackUpdate(fiber.nativeElement);\r\n    commitCreation(fiber);\r\n  },\r\n  [EffectTag.UPDATE]: (fiber: Fiber<NativeElement>) => {\r\n    if (fiber.move) {\r\n      move(fiber);\r\n      fiber.move = false;\r\n    }\r\n\r\n    if (\r\n      fiber.nativeElement === null ||\r\n      !detectIsVirtualNode(fiber.alternate.instance) ||\r\n      !detectIsVirtualNode(fiber.instance)\r\n    ) {\r\n      return;\r\n    }\r\n    trackUpdate && trackUpdate(fiber.nativeElement);\r\n    commitUpdate(fiber);\r\n  },\r\n  [EffectTag.DELETE]: (fiber: Fiber<NativeElement>) => commitDeletion(fiber),\r\n  [EffectTag.SKIP]: () => {},\r\n};\r\n\r\nfunction applyCommit(fiber: Fiber<NativeElement>) {\r\n  applyCommitMap[fiber.effectTag](fiber);\r\n}\r\n\r\nfunction finishCommitWork() {\r\n  for (const { callback } of fragmentsMap.values()) {\r\n    callback();\r\n  }\r\n\r\n  for (const move of moves) {\r\n    move();\r\n  }\r\n\r\n  fragmentsMap = new Map();\r\n  moves = [];\r\n  isHydrateZone.set(false);\r\n}\r\n\r\nfunction setTrackUpdate(fn: typeof trackUpdate) {\r\n  trackUpdate = fn;\r\n}\r\n\r\nexport { createNativeElement, applyCommit, finishCommitWork, setTrackUpdate };\r\n","export const SVG_TAG_NAMES =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,defs,desc,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,image,line,linearGradient,marker,mask,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,stop,switch,symbol,text,textPath,tspan,use,view';\r\nexport const VOID_TAG_NAMES = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n","import { type ScheduleCallbackOptions, getTime, workLoop, wipRootStore, TaskPriority } from '@dark-engine/core';\r\n\r\ntype Callback = () => boolean;\r\n\r\ntype QueueByPriority = {\r\n  animations: Array<Task>;\r\n  hight: Array<Task>;\r\n  normal: Array<Task>;\r\n  low1: Array<Task>;\r\n  low2: Array<Task>;\r\n};\r\n\r\nconst queueByPriority: QueueByPriority = {\r\n  animations: [],\r\n  hight: [],\r\n  normal: [],\r\n  low1: [],\r\n  low2: [],\r\n};\r\nconst YEILD_INTERVAL = 4;\r\nconst MAX_LOW_PRIORITY_TASKS_LIMIT = 100000;\r\nlet scheduledCallback: Callback = null;\r\nlet deadline = 0;\r\nlet isMessageLoopRunning = false;\r\nlet currentTask: Task = null;\r\n\r\nclass Task {\r\n  public static nextTaskId = 0;\r\n  public id: number;\r\n  public time: number;\r\n  public timeoutMs: number;\r\n  public priority: TaskPriority;\r\n  public forceSync: boolean;\r\n  public callback: () => void;\r\n\r\n  constructor(options: Omit<Task, 'id'>) {\r\n    this.id = ++Task.nextTaskId;\r\n    this.time = options.time;\r\n    this.timeoutMs = options.timeoutMs;\r\n    this.priority = options.priority;\r\n    this.forceSync = options.forceSync;\r\n    this.callback = options.callback;\r\n  }\r\n}\r\n\r\nconst shouldYeildToHost = () => getTime() >= deadline;\r\n\r\nfunction scheduleCallback(callback: () => void, options?: ScheduleCallbackOptions) {\r\n  const { priority = TaskPriority.NORMAL, timeoutMs = 0, forceSync = false } = options || {};\r\n  const task = new Task({ time: getTime(), timeoutMs, priority, forceSync, callback });\r\n  const map: Record<TaskPriority, () => void> = {\r\n    [TaskPriority.ANIMATION]: () => queueByPriority.animations.push(task),\r\n    [TaskPriority.HIGH]: () => queueByPriority.hight.push(task),\r\n    [TaskPriority.NORMAL]: () => queueByPriority.normal.push(task),\r\n    [TaskPriority.LOW]: () => (task.timeoutMs > 0 ? queueByPriority.low2.push(task) : queueByPriority.low1.push(task)),\r\n  };\r\n\r\n  map[task.priority]();\r\n  executeTasks();\r\n}\r\n\r\nfunction pick(queue: Array<Task>) {\r\n  if (!queue.length) return false;\r\n  currentTask = queue.shift();\r\n  const isAnimation = currentTask.priority === TaskPriority.ANIMATION;\r\n\r\n  currentTask.callback();\r\n\r\n  if (currentTask.forceSync || isAnimation) {\r\n    requestCallbackSync(workLoop);\r\n  } else {\r\n    requestCallback(workLoop);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction executeTasks() {\r\n  const isBusy = Boolean(wipRootStore.get());\r\n\r\n  if (!isBusy) {\r\n    checkOverdueTasks() ||\r\n      gc() ||\r\n      pick(queueByPriority.animations) ||\r\n      pick(queueByPriority.hight) ||\r\n      pick(queueByPriority.normal) ||\r\n      requestIdleCallback(() => pick(queueByPriority.low1) || pick(queueByPriority.low2));\r\n  }\r\n}\r\n\r\nfunction gc() {\r\n  if (queueByPriority.low1.length > MAX_LOW_PRIORITY_TASKS_LIMIT) {\r\n    queueByPriority.low1 = [];\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkOverdueTasks() {\r\n  const [task] = queueByPriority.low2;\r\n\r\n  if (task && getTime() - task.time > task.timeoutMs) {\r\n    pick(queueByPriority.low2);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction performWorkUntilDeadline() {\r\n  if (scheduledCallback) {\r\n    deadline = getTime() + YEILD_INTERVAL;\r\n\r\n    try {\r\n      const hasMoreWork = scheduledCallback();\r\n\r\n      if (!hasMoreWork) {\r\n        currentTask = null;\r\n        isMessageLoopRunning = false;\r\n        scheduledCallback = null;\r\n        executeTasks();\r\n      } else {\r\n        port.postMessage(null);\r\n      }\r\n    } catch (error) {\r\n      port.postMessage(null);\r\n      throw error;\r\n    }\r\n  } else {\r\n    isMessageLoopRunning = false;\r\n  }\r\n}\r\n\r\nfunction requestCallback(callback: Callback) {\r\n  if (process.env.NODE_ENV === 'test') {\r\n    return requestCallbackSync(callback);\r\n  }\r\n\r\n  scheduledCallback = callback;\r\n\r\n  if (!isMessageLoopRunning) {\r\n    isMessageLoopRunning = true;\r\n    port.postMessage(null);\r\n  }\r\n}\r\n\r\nfunction requestCallbackSync(callback: Callback) {\r\n  while (callback()) {\r\n    //\r\n  }\r\n  executeTasks();\r\n  currentTask = null;\r\n}\r\n\r\nlet channel: MessageChannel = null;\r\nlet port: MessagePort = null;\r\n\r\nfunction setup() {\r\n  if (process.env.NODE_ENV === 'test') {\r\n    return;\r\n  }\r\n\r\n  channel = new MessageChannel();\r\n  port = channel.port2;\r\n\r\n  channel.port1.onmessage = performWorkUntilDeadline;\r\n}\r\n\r\nsetup();\r\n\r\nexport { shouldYeildToHost, scheduleCallback };\r\n","import {\r\n  type DarkElement,\r\n  ROOT,\r\n  Fiber,\r\n  EffectTag,\r\n  platform,\r\n  flatten,\r\n  detectIsUndefined,\r\n  TagVirtualNode,\r\n  rootStore,\r\n  wipRootStore,\r\n  currentRootStore,\r\n  nextUnitOfWorkStore,\r\n  fiberMountStore,\r\n  TaskPriority,\r\n  createReplacer,\r\n  isInsertionEffectsZone,\r\n  isLayoutEffectsZone,\r\n  isHydrateZone,\r\n} from '@dark-engine/core';\r\nimport type { TagNativeElement } from '../native-element';\r\nimport { createNativeElement, applyCommit, finishCommitWork } from '../dom';\r\nimport { detectIsPortal, unmountPortal } from '../portal';\r\nimport { scheduleCallback, shouldYeildToHost } from '../scheduler';\r\n\r\nlet isInjected = false;\r\nconst roots = new Map<Element, number>();\r\n\r\nfunction inject() {\r\n  platform.createNativeElement = createNativeElement as typeof platform.createNativeElement;\r\n  platform.requestAnimationFrame = requestAnimationFrame.bind(this);\r\n  platform.cancelAnimationFrame = cancelAnimationFrame.bind(this);\r\n  platform.scheduleCallback = scheduleCallback;\r\n  platform.shouldYeildToHost = shouldYeildToHost;\r\n  platform.applyCommit = applyCommit;\r\n  platform.finishCommitWork = finishCommitWork;\r\n  platform.detectIsDynamic = () => true;\r\n  platform.detectIsPortal = detectIsPortal;\r\n  platform.unmountPortal = unmountPortal;\r\n  isInjected = true;\r\n}\r\n\r\nfunction render(element: DarkElement, container: TagNativeElement, hydrate = false) {\r\n  !isInjected && inject();\r\n\r\n  if (!(container instanceof Element)) {\r\n    throw new Error(`[Dark]: render receives only Element as container!`);\r\n  }\r\n\r\n  const isMounted = !detectIsUndefined(roots.get(container));\r\n  let rootId: number = null;\r\n\r\n  if (!isMounted) {\r\n    rootId = roots.size;\r\n\r\n    roots.set(container, rootId);\r\n\r\n    if (!hydrate) {\r\n      container.innerHTML = '';\r\n    }\r\n  } else {\r\n    rootId = roots.get(container);\r\n  }\r\n\r\n  // insertion effect can't schedule renders\r\n  if (isInsertionEffectsZone.get(rootId)) return;\r\n\r\n  const callback = () => {\r\n    rootStore.set(rootId); // important order!\r\n    const currentRoot = currentRootStore.get();\r\n    const fiber = new Fiber().mutate({\r\n      nativeElement: container,\r\n      instance: new TagVirtualNode(ROOT, {}, flatten([element || createReplacer()]) as TagVirtualNode['children']),\r\n      alternate: currentRoot,\r\n      effectTag: isMounted ? EffectTag.UPDATE : EffectTag.CREATE,\r\n    });\r\n\r\n    fiberMountStore.reset();\r\n    wipRootStore.set(fiber);\r\n    isHydrateZone.set(hydrate);\r\n    nextUnitOfWorkStore.set(fiber);\r\n  };\r\n\r\n  platform.scheduleCallback(callback, {\r\n    priority: TaskPriority.NORMAL,\r\n    forceSync: isLayoutEffectsZone.get(),\r\n  });\r\n}\r\n\r\nexport { render, roots };\r\n","import { platform, type ScheduleCallbackOptions } from '../platform';\r\nimport { getRootId, currentFiberStore, isInsertionEffectsZone, isLayoutEffectsZone, isBatchZone } from '../scope';\r\nimport { createUpdateCallback } from '../fiber';\r\nimport { useMemo } from '../use-memo';\r\nimport { dummyFn } from '../helpers';\r\nimport { runBatch as batch } from '../batch';\r\n\r\nfunction useUpdate(options?: ScheduleCallbackOptions) {\r\n  const rootId = getRootId();\r\n  const scope = useMemo(() => ({ fiber: null }), []);\r\n\r\n  scope.fiber = currentFiberStore.get();\r\n\r\n  const update = (onStart?: () => void) => {\r\n    if (isInsertionEffectsZone.get()) return;\r\n    const callback = createUpdateCallback({\r\n      rootId,\r\n      fiber: scope.fiber,\r\n      forceStart: Boolean(options?.timeoutMs),\r\n      onStart: onStart || dummyFn,\r\n    });\r\n\r\n    if (isLayoutEffectsZone.get()) {\r\n      options = {\r\n        ...(options || {}),\r\n        forceSync: true,\r\n      };\r\n    }\r\n\r\n    if (isBatchZone.get()) {\r\n      batch(scope.fiber, () => platform.scheduleCallback(callback, options));\r\n    } else {\r\n      platform.scheduleCallback(callback, options);\r\n    }\r\n  };\r\n\r\n  return update;\r\n}\r\n\r\nexport { useUpdate };\r\n","import { type Fiber } from '../fiber';\r\nimport { isBatchZone } from '../scope';\r\n\r\nfunction batch(callback: () => void) {\r\n  isBatchZone.set(true);\r\n  callback();\r\n}\r\n\r\nfunction runBatch(fiber: Fiber, callback: () => void) {\r\n  fiber.batched && window.clearTimeout(fiber.batched);\r\n  fiber.batched = window.setTimeout(() => {\r\n    isBatchZone.set(false);\r\n    fiber.batched = null;\r\n    callback();\r\n  });\r\n}\r\n\r\nexport { batch, runBatch };\r\n","import { h, Fragment, createComponent, useState, useEffect } from '@dark-engine/core';\r\n\r\nconst App = createComponent(() => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    console.log('effect...');\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <div class='app'>\r\n        <div>Hello World</div>\r\n        <div>count: {count}</div>\r\n        <button class='button' onClick={() => setCount(count + 1)}>\r\n          increment\r\n        </button>\r\n      </div>\r\n    </>\r\n  );\r\n});\r\n\r\nexport { App };\r\n","import { type ScheduleCallbackOptions } from '../platform';\r\nimport { detectIsFunction } from '../helpers';\r\nimport { useUpdate } from '../use-update';\r\nimport { useMemo } from '../use-memo';\r\nimport { useCallback } from '../use-callback';\r\nimport { TaskPriority } from '../constants';\r\n\r\ntype Value<T> = T | ((prevValue: T) => T);\r\n\r\nfunction useState<T = unknown>(\r\n  initialValue: T | (() => T),\r\n  options?: ScheduleCallbackOptions,\r\n): [T, (value: Value<T>) => void] {\r\n  const update = useUpdate(options);\r\n  const store = useMemo(\r\n    () => ({\r\n      value: detectIsFunction(initialValue) ? initialValue() : initialValue,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const setState = useCallback((sourceValue: Value<T>) => {\r\n    const prevValue = store.value;\r\n    const newValue = detectIsFunction(sourceValue) ? sourceValue(prevValue) : sourceValue;\r\n\r\n    if (!Object.is(prevValue, newValue)) {\r\n      const setValue = () => (store.value = newValue);\r\n\r\n      if (options?.priority === TaskPriority.LOW) {\r\n        update(() => setValue());\r\n      } else {\r\n        setValue();\r\n        update();\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  return [store.value, setState];\r\n}\r\n\r\nexport { useState };\r\n","import { useMemo } from '../use-memo';\r\n\r\nfunction useCallback<T = Function>(callback: T, deps: Array<any>): T {\r\n  const value = useMemo(() => callback, deps);\r\n\r\n  return value;\r\n}\r\n\r\nexport { useCallback };\r\n","import { type DarkElement } from '@dark-engine/core';\r\nimport { render } from '../render';\r\nimport { unmount } from '../create-root';\r\nimport type { TagNativeElement } from '../native-element';\r\n\r\nfunction hydrateRoot(container: TagNativeElement, element: DarkElement) {\r\n  render(element, container, true);\r\n\r\n  return {\r\n    unmount: () => unmount(container),\r\n  };\r\n}\r\n\r\nexport { hydrateRoot };\r\n","import { h } from '@dark-engine/core';\r\nimport { hydrateRoot } from '@dark-engine/platform-browser';\r\n\r\nimport { App } from './app';\r\n\r\nhydrateRoot(document.getElementById('root'), <App />);\r\n"],"names":["detectIsFunction","o","detectIsUndefined","detectIsNumber","detectIsString","detectIsBoolean","detectIsArray","Array","isArray","detectIsNull","detectIsEmpty","getTime","Date","now","dummyFn","flatten","source","list","levelMap","idx","level","item","length","push","keyBy","fn","value","reduce","acc","x","detectIsDepsDifferent","deps","prevDeps","i","TYPE","ATTR_KEY","ATTR_REF","ATTR_FLAG","TaskPriority","Flag","NodeType","$$virtualNode","Symbol","VirtualNode","type","constructor","this","TagVirtualNode","name","attrs","children","super","TAG","TextVirtualNode","text","TEXT","CommentVirtualNode","COMMENT","detectIsVirtualNode","vNode","detectIsTagVirtualNode","detectIsTextVirtualNode","detectIsVirtualNodeFactory","factory","createReplacer","getChildren","map","toString","createElement","tag","props","def","as","slot","_void","key","flag","View","from","platform","createNativeElement","Error","requestAnimationFrame","cancelAnimationFrame","scheduleCallback","shouldYeildToHost","applyCommit","finishCommitWork","detectIsDynamic","detectIsPortal","unmountPortal","rootId","stores","Map","Store","wipRoot","currentRoot","nextUnitOfWork","events","unsubscribers","deletions","Set","fiberMount","navigation","isDeepWalking","componentFiber","effects","layoutEffects","insertionEffects","isLayoutEffectsZone","isInserionEffectsZone","isUpdateHookZone","isBatchZone","isHydrateZone","rootStore","id","get","set","getRootId","store","wipRootStore","fiber","nextUnitOfWorkStore","currentFiberStore","deletionsStore","add","fiberMountStore","effectsStore","reset","effect","layoutEffectsStore","insertionEffectsStore","isInsertionEffectsZone","defaultOptions","displayName","defaultProps","token","ComponentFactory","ref","shouldUpdate","options","computedOptions","mprops","detectIsComponentFactory","$$memo","detectIsMemo","EffectTag","cloneTagMap","CREATE","SKIP","$$useEffect","useEffect","hasEffects","dropEffects","createEffect","hook","values","runEffect","undefined","cleanup","some","$$useLayoutEffect","useLayoutEffect","hasLayoutEffects","dropLayoutEffects","$$useInsertionEffect","useInsertionEffect","hasInsertionEffects","dropInsertionEffects","walkFiber","onLoop","nextFiber","isReturn","isStopped","visitedMap","detectCanVisit","resetIsDeepWalking","stop","child","newFiber","nextSibling","parent","unmountFiber","insertionEffectHost","layoutEffectHost","effectHost","portalHost","instance","$$fragment","Fragment","Fiber","nativeElement","alternate","move","effectTag","provider","childrenCount","childrenElementsCount","marker","isUsed","elementIdx","batched","catchException","static","nextId","mutate","keys","Object","markEffectHost","markLayoutEffectHost","markInsertionEffectHost","markPortalHost","incrementChildrenElementsCount","count","force","fromUpdate","wipFiber","setError","error","workLoop","shouldYield","hasMoreWork","Boolean","performUnitOfWork","isDynamic","onComplete","forEach","diff","parentFiber","getParentFiberWithNativeElement","isRight","syncElementIndices","setTimeout","currentRootStore","skip","commitChanges","hasChildrenProp","fiber$","instance$","performChild","fiber$$","performSibling","nextLevel","getHook","pertformInstance","performAlternate","performFiber","performMemo","parentInstance","childrenIdx","hasAlternate","isSameKeys","getElementKey","isUpdate","getInstanceType","UPDATE","insertToFiber","DELETE","createConditionalFiber","alternateType","isSameType","getVirtualNodeFactoryFlag","getElementFlag","hasNoMovesFlag","HAS_NO_MOVES","prevKeys","nextKeys","prevKeysMap","nextKeysMap","keyedFibersMap","prevKey","createIndexKey","nextKey","extractKeys","result","size","Math","max","p","n","prevKeyFiber","nextKeyFiber","has","prevFactory","nextFactory","prevProps","nextProps","deep","performedInstance","elements","splice","mountInstance","isComponentFactory","detectIsFragment","err","args","console","supportConditional","getVirtualNodeFactoryKey","element","prevInstance","nextInstance","detectIsSameComponentFactoryTypesWithSameKeys","Memo","processValue","getValue","isDepsDifferent","check","wrap","useMemo","hookValue","computedGetValue","$$portal","rest","innerHTML","getPortalContainer","container","SyntheticEvent","sourceEvent","target","propagation","stopPropagation","preventDefault","getPropagation","delegateEvent","eventName","handler","eventsMap","handlerMap","rootHandler","event","fireEvent","syntheticEvent","parentElement","dispatchEvent","WeakMap","document","addEventListener","removeEventListener","detectIsEvent","attrName","startsWith","getEventName","slice","toLowerCase","attrBlackListMap","fragmentsMap","moves","svgTagNamesMap","split","voidTagNamesMap","createNativeElementMap","tagNode","tagName","createElementNS","textNode","createTextNode","commentNode","createComment","applyRef","mutableRef","hasOwnProperty","detectIsMutableRef","current","patchProperties","attrValue","patchPropertiesSpecialCasesMap","prototype","getPrototypeOf","getOwnPropertyDescriptor","includes","input","checked","autofocus","textarea","String","commitCreation","childNodes","Text","splitText","fragment","createDocumentFragment","callback","appendChild","append","insertBefore","insert","attrNames","tagElement","setAttribute","addAttributes","applyCommitMap","sourceNodes","collectElements","sourceFragment","DocumentFragment","node","removeChild","replaceChild","textContent","nextVNode","prevAttrValue","nextAttrValue","removeAttribute","updateAttributes","commitUpdate","commitDeletion","queueByPriority","animations","hight","normal","low1","low2","scheduledCallback","deadline","isMessageLoopRunning","currentTask","Task","time","timeoutMs","priority","forceSync","nextTaskId","NORMAL","task","ANIMATION","HIGH","LOW","executeTasks","pick","queue","shift","isAnimation","requestCallbackSync","port","postMessage","checkOverdueTasks","requestIdleCallback","channel","MessageChannel","port2","port1","onmessage","isInjected","roots","useUpdate","scope","onStart","forceStart","createUpdateCallback","window","clearTimeout","App","setCount","initialValue","update","setState","sourceValue","prevValue","newValue","is","setValue","useState","log","class","onClick","getElementById","hydrate","bind","inject","Element","isMounted"],"sourceRoot":""}